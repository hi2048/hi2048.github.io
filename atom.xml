<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>苏小蜂的个人博客</title>
  
  <subtitle>放慢脚步，享受生活！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hi2048.github.io/"/>
  <updated>2022-03-16T12:44:17.024Z</updated>
  <id>http://hi2048.github.io/</id>
  
  <author>
    <name>Jsu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Sailboat retrospective</title>
    <link href="http://hi2048.github.io/2022/02/20/Sailboat-retrospective/"/>
    <id>http://hi2048.github.io/2022/02/20/Sailboat-retrospective/</id>
    <published>2022-02-19T16:00:00.000Z</published>
    <updated>2022-03-16T12:44:17.024Z</updated>
    
    <content type="html"><![CDATA[<h1 id="The-Sailboat-Retrospective"><a href="#The-Sailboat-Retrospective" class="headerlink" title="The Sailboat Retrospective"></a>The Sailboat Retrospective</h1><ul><li>Surface what is helping and hindering your scrum team.</li></ul><p><strong>Start by listing your Crew and the Goals you had, then detail the Drags you experienced, Barriers you encountered and Accellerators that pushed you along, ending by sharing what you Learned.</strong></p><hr><h1 id="The-crew"><a href="#The-crew" class="headerlink" title="The crew"></a>The crew</h1><ul><li>Check-in<br><strong>Take a seat at the table, Drag an emoji that reflects your mood</strong></li></ul><hr><h1 id="Goals"><a href="#Goals" class="headerlink" title="Goals"></a>Goals</h1><ul><li>What goals did we have?<br><strong>What was our destination? What did we want to achieve?</strong></li></ul><hr><h1 id="Accellerators"><a href="#Accellerators" class="headerlink" title="Accellerators"></a>Accellerators</h1><ul><li>What accellerated us?<br><strong>What’s helped us to move forward? What did we do well and right?</strong><br><strong>What mechanisms were in place that helped the team? Where there any standout teammates to celebrate or sponsors to thank?</strong></li></ul><hr><h1 id="Barriers"><a href="#Barriers" class="headerlink" title="Barriers"></a>Barriers</h1><ul><li>What barriers did we encounter?<br><strong>What risks did we need to navigate around? What were the impacts?</strong><br><strong>What created an obstruction to your progress? What were the impacts on your team and the work?</strong></li></ul><hr><h1 id="Drags"><a href="#Drags" class="headerlink" title="Drags"></a>Drags</h1><ul><li>What drag did we overcome?<br><strong>Focus upon what could have been done better.</strong><br><strong>What slowed us down? Were we able to foresee the friction or was it hidden from view?</strong></li></ul><hr><h1 id="Voting"><a href="#Voting" class="headerlink" title="Voting"></a>Voting</h1><ul><li>Time to prioritize items to focus on what really matters</li></ul><hr><h1 id="Learnings"><a href="#Learnings" class="headerlink" title="Learnings"></a>Learnings</h1><ul><li>What did we learn?<br><strong>What were the big takeaways from this experience and how can we use them to ease our next journey?</strong><br><strong>individual or team learnings</strong></li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;The-Sailboat-Retrospective&quot;&gt;&lt;a href=&quot;#The-Sailboat-Retrospective&quot; class=&quot;headerlink&quot; title=&quot;The Sailboat Retrospective&quot;&gt;&lt;/a&gt;The Sail
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="Agile" scheme="http://hi2048.github.io/tags/Agile/"/>
    
      <category term="Mural" scheme="http://hi2048.github.io/tags/Mural/"/>
    
  </entry>
  
  <entry>
    <title>Happiness</title>
    <link href="http://hi2048.github.io/2022/02/15/Happiness/"/>
    <id>http://hi2048.github.io/2022/02/15/Happiness/</id>
    <published>2022-02-14T16:00:00.000Z</published>
    <updated>2022-03-09T05:54:06.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Pursing-Happiness"><a href="#Pursing-Happiness" class="headerlink" title="Pursing Happiness"></a>Pursing Happiness</h1><p><strong>The data showed that chasing happiness can make people unhappy.</strong></p><hr><h1 id="Pursing-Happiness-1"><a href="#Pursing-Happiness-1" class="headerlink" title="Pursing Happiness"></a>Pursing Happiness</h1><p><strong>According to the research, what predicts this despair is not a lack of happiness. It’s a lack of something else, a lack of having meaning in life.</strong></p><hr><h1 id="What-is-the-difference-between-being-happy-and-having-meaning-in-life"><a href="#What-is-the-difference-between-being-happy-and-having-meaning-in-life" class="headerlink" title="What is the difference between being happy and having meaning in life?"></a>What is the difference between being happy and having meaning in life?</h1><p><strong>Many psychologists define happiness as a state of comfort and ease, feeling good in the moment. Meaning, though, is deeper.</strong></p><p><strong>The renowned psychologist Martin Seligman says meaning comes from belonging to and serving something beyond yourself and from developing the best within you.</strong></p><hr><h1 id="How-can-we-each-live-more-meaningfully"><a href="#How-can-we-each-live-more-meaningfully" class="headerlink" title="How can we each live more meaningfully?"></a>How can we each live more meaningfully?</h1><p><strong>Four pillars of a meaning ful life: belonging, purpose, transcendence, storytelling.</strong></p><hr><h1 id="Belonging"><a href="#Belonging" class="headerlink" title="Belonging"></a>Belonging</h1><p><strong>True belonging springs from love.</strong><br><strong>When you lead with love, you create a bond that lifts each of you up. For many people, belonging is the moset essential source of meaning, those bonds to family and friends.</strong></p><hr><h1 id="Purpose"><a href="#Purpose" class="headerlink" title="Purpose"></a>Purpose</h1><p><strong>Purpose is less about what you want than about what you give.</strong><br><strong>The key to purpose is using your strengths to serve others.</strong></p><hr><h1 id="Transcendence"><a href="#Transcendence" class="headerlink" title="Transcendence"></a>Transcendence</h1><p><strong>Transcendent states are those rare moments when you’re lifted above the hustle and bustle of daily life, your sense of self fades away, and you feel connected to a higher reality.</strong></p><hr><h1 id="Transcendence-1"><a href="#Transcendence-1" class="headerlink" title="Transcendence"></a>Transcendence</h1><p><strong>One study had students look up at 200-feet-tall eucalyptus trees for one minute. But after wards they felt less self-centered, and they even behaved more generously when given the chance to help someone.</strong></p><hr><h1 id="Storytelling"><a href="#Storytelling" class="headerlink" title="Storytelling"></a>Storytelling</h1><p><strong>The story you tell yourself about yourself.</strong></p><p><strong>We’re the authors of our stories and can change the way we’re telling them. Your life isn’t just a list of events. You can edit, interpret and retell your story, even as you’re constrained by the facts.</strong></p><hr><h1 id="Redemptive-story"><a href="#Redemptive-story" class="headerlink" title="Redemptive story"></a>Redemptive story</h1><p><strong>The psychologist Dan McAdams calls this a “redemptive story,” where the bad is redeemed by the good. People leading meaningful lives, he’s found, tend to tell stories about their lives defined by redemption, growth and love.</strong></p><hr><h1 id="Meaning"><a href="#Meaning" class="headerlink" title="Meaning"></a>Meaning</h1><p><strong>The studies show that people who have meaning in life, they’re more resilient, they do better in school and at work, and they even live logner.</strong></p><hr><p><strong>Happiness comes and goes. But when life is really good and when things are really bad, having meaning gives you something to hold on to.</strong></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Pursing-Happiness&quot;&gt;&lt;a href=&quot;#Pursing-Happiness&quot; class=&quot;headerlink&quot; title=&quot;Pursing Happiness&quot;&gt;&lt;/a&gt;Pursing Happiness&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Th
      
    
    </summary>
    
      <category term="杂谈" scheme="http://hi2048.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="TED" scheme="http://hi2048.github.io/tags/TED/"/>
    
  </entry>
  
  <entry>
    <title>typescript todo</title>
    <link href="http://hi2048.github.io/2022/01/18/typescript-todo/"/>
    <id>http://hi2048.github.io/2022/01/18/typescript-todo/</id>
    <published>2022-01-17T16:00:00.000Z</published>
    <updated>2022-03-09T05:50:09.653Z</updated>
    
    <content type="html"><![CDATA[<p>– todo <a href="https://github.com/hi2048/typescript-todo" title="todo" target="_blank" rel="noopener">github</a></p><pre><code>-- App.tsximport React, { useState } from &apos;react&apos;;import &apos;antd/dist/antd.css&apos;;import &apos;./App.css&apos;;import TodoInput from &apos;./todoInput&apos;;import { TodoList } from &apos;./todoList&apos;;import { todoListDate } from &apos;./model/todo&apos;;import { Actions } from &apos;./model/actions&apos;;function App() {  const [ todos, setTodos ] = useState(todoListDate);  const todoSubmit = (value: any) =&gt; {    setTodos([...todos, { ...value, isComplete: false, date: new Date().toLocaleString() }])  }  const onActions = (actions: Actions) =&gt; (id: string) =&gt; {    switch(actions) {      case Actions.COMPLETE:        setTodos(todos.map(todo =&gt; {          if(todo.id === id) {            return { ...todo, isComplete: !todo.isComplete}          }          return todo;        }));        break;      case Actions.DELETE:        setTodos(todos.filter(todo =&gt; todo.id !== id));        break;    }  }  return (    &lt;div className=&quot;App&quot;&gt;      &lt;header className=&quot;container header&quot;&gt;        &lt;TodoInput value=&quot;todo input&quot; onSubmit={todoSubmit} /&gt;      &lt;/header&gt;      &lt;div className=&quot;container content&quot;&gt;        &lt;TodoList values={ todos } onActions={onActions} /&gt;      &lt;/div&gt;    &lt;/div&gt;  );}export default App;-- todoInput.tsximport React, { useRef } from &apos;react&apos;;import { Form, Input, Button } from &apos;antd&apos;;import { Todo, guid } from &apos;./model/todo&apos;;interface TodoInputProps {  value?: string;  onSubmit?: (value: Todo) =&gt; void;}function TodoInput(props: TodoInputProps) {  const { value, onSubmit } = props;  const ref = useRef&lt;Input&gt;(null);  const todoSubmit = () =&gt; {    onSubmit &amp;&amp; onSubmit({ id: guid(), content: ref.current?.state.value });  }  return (    &lt;Form layout=&quot;inline&quot; className=&quot;form&quot; onFinish={todoSubmit}&gt;      &lt;Form.Item name=&quot;todo&quot;&gt;        &lt;Input placeholder=&quot;please input your todo&quot; value={ value } ref={ref} /&gt;      &lt;/Form.Item&gt;      &lt;Form.Item&gt;        &lt;Button type=&quot;primary&quot; htmlType=&quot;submit&quot;&gt;Submit&lt;/Button&gt;      &lt;/Form.Item&gt;    &lt;/Form&gt;  );}export default TodoInput;-- todoList.tsximport React from &apos;react&apos;;import { Todo } from &apos;./model/todo&apos;;import { Actions } from &apos;./model/actions&apos;;import { List } from &apos;antd&apos;;interface TodoListProps {  values?: Todo[],  onActions: (action: Actions) =&gt; (id: string) =&gt; void;}export const TodoList = (props: TodoListProps) =&gt; {  const { values, onActions } = props;  const onComplete = (e: any) =&gt; {    onActions(Actions.COMPLETE)(e.target.id);  }  const onDelete = (e: any) =&gt; {    onActions(Actions.DELETE)(e.target.id);  }  return (    &lt;List itemLayout=&quot;horizontal&quot; dataSource={values} renderItem={item =&gt; (      &lt;List.Item actions={[&lt;a id={item.id} key=&quot;list-loadmore-complete&quot; onClick={onComplete}&gt;Complete&lt;/a&gt;, &lt;a id={item.id} key=&quot;list-loadmore-delete&quot; onClick={onDelete}&gt;Delete&lt;/a&gt;]}&gt;        &lt;div style={{ textDecoration: item.isComplete?"line-through" : "none" }}&gt;{item.content}&lt;/div&gt;      &lt;/List.Item&gt;    )} /&gt;  )}-- todo.tsexport interface Todo {  id: string;  content: string;  date?: string;  isComplete?: boolean;}export const todoListDate: Todo[] = [];-- actions.tsexport enum Actions {  COMPLETE,  DELETE};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;– todo &lt;a href=&quot;https://github.com/hi2048/typescript-todo&quot; title=&quot;todo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-- App.t
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="TypeScript" scheme="http://hi2048.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>一维数组转换二维数组</title>
    <link href="http://hi2048.github.io/2022/01/01/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
    <id>http://hi2048.github.io/2022/01/01/一维数组转换二维数组/</id>
    <published>2021-12-31T16:00:00.000Z</published>
    <updated>2022-01-12T04:34:07.758Z</updated>
    
    <content type="html"><![CDATA[<pre><code>/*** 给你一个下标从 0 开始的一维整数数组 original 和两个整数 m 和  n 。你需要使用 original 中 所有 元素创建一个 m 行 n 列的二维数组。* */function construct2DArray(original: number[], m: number, n: number): number[][] {  const ret = [];  if(original.length !== m * n) {    return [];  } else {    for(let i = 0; i &lt; original.length; i += n) {        ret.push(original.slice(i, i + n));    }  }  return ret;};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;/**
* 给你一个下标从 0 开始的一维整数数组 original 和两个整数 m 和  n 。你需要使用 original 中 所有 元素创建一个 m 行 n 列的二维数组。
* 
*/

function construct2DArray(origin
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="TypeScript" scheme="http://hi2048.github.io/tags/TypeScript/"/>
    
      <category term="Leetcode" scheme="http://hi2048.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Speed Car Retrospective</title>
    <link href="http://hi2048.github.io/2021/12/01/Speed-Car-Retrospective/"/>
    <id>http://hi2048.github.io/2021/12/01/Speed-Car-Retrospective/</id>
    <published>2021-11-30T16:00:00.000Z</published>
    <updated>2021-12-29T10:57:24.433Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Speed Car Retrospective</li></ol><ul><li>Parachute: What has been slowing us down?</li><li>Engine: What has been pushing us forward? Making us move faster?</li><li>Abyss: representative of the future obstachles that we can see today</li><li>Bridge: representative of ways we might overcome these obstachles tomorrow</li></ul><ol start="2"><li>Looking Back</li></ol><ul><li>Engine and Parachute</li></ul><ol start="3"><li>Looking Ahead</li></ol><ul><li>Abyss and Bridge</li></ul><ol start="4"><li><p>Dot Voting</p></li><li><p>Discussion</p></li></ol><ul><li>Retrospective: Parachute Engine</li><li>Futurespective: Abyss Bridge</li></ul><p>6 Action Plan</p><ul><li>collect action items</li><li>transform to actionable items and plan in next/future sprint.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;Speed Car Retrospective&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Parachute: What has been slowing us down?&lt;/li&gt;
&lt;li&gt;Engine: What has been pushing us for
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="Agile" scheme="http://hi2048.github.io/tags/Agile/"/>
    
  </entry>
  
  <entry>
    <title>学生出勤记录3</title>
    <link href="http://hi2048.github.io/2021/11/22/%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%953/"/>
    <id>http://hi2048.github.io/2021/11/22/学生出勤记录3/</id>
    <published>2021-11-21T16:00:00.000Z</published>
    <updated>2021-11-22T15:19:48.852Z</updated>
    
    <content type="html"><![CDATA[<pre><code>/*** 学生出勤记录 II* 给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：* &apos;A&apos;：Absent，缺勤* &apos;L&apos;：Late，迟到* &apos;P&apos;：Present，到场* 如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：* 按 总出勤 计，学生缺勤（&apos;A&apos;）严格 少于两天。* 学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（&apos;L&apos;）记录。* 给你一个整数 n，表示出勤记录的长度(次数)。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 数量 。答案可能很大，所以返回对 109 + 7 取余 结果。* * method1: dfs* method2: dp* * @param {number} n* @return {number}*/var checkRecord = function(n) {  const Mod = 1000000007;  const dp = new Array(n).fill(0).map(() =&gt; new Array(2).fill(0).map(() =&gt; new Array(3).fill(0)));  //p  dp[0][0][0] = 1;  //A  dp[0][1][0] = 1;  //L  dp[0][0][1] = 1;  for(let i = 1; i &lt; n; i++) {    //p    dp[i][0][0] = (dp[i - 1][0][0] + dp[i - 1][0][1] + dp[i - 1][0][2]) % Mod;    dp[i][1][0] = (dp[i - 1][1][0] + dp[i - 1][1][1] + dp[i - 1][1][2]) % Mod;    //A    dp[i][1][0] = (dp[i][1][0] + dp[i - 1][0][0] + dp[i - 1][0][1] + dp[i - 1][0][2]) % Mod;    //L    dp[i][0][1] = dp[i - 1][0][0];    dp[i][0][2] = dp[i - 1][0][1];    dp[i][1][1] = dp[i - 1][1][0];    dp[i][1][2] = dp[i - 1][1][1];  }  let sum = 0;  for(let i = 0; i &lt; 2; i++) {    for(let j = 0; j &lt; 3; j++) {      sum = (sum + dp[n - 1][i][j]) % Mod;    }  }  return sum;};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;/**
* 学生出勤记录 II
* 给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：
* &amp;apos;A&amp;apos;：Absent，缺勤
* &amp;apos;L&amp;apos;：Late，
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="Leetcode" scheme="http://hi2048.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>study notes</title>
    <link href="http://hi2048.github.io/2021/11/01/study-notes-english/"/>
    <id>http://hi2048.github.io/2021/11/01/study-notes-english/</id>
    <published>2021-10-31T16:00:00.000Z</published>
    <updated>2021-11-10T04:42:03.212Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>和则两利，斗则俱伤<br>A peachful and harmonious bilateral relationship between these two countries will make both winners. While a confrontational one wil make both losers.</p></li><li><p>行百里者半九十<br>Half of the people who have embarked on a one-hundred-mile journey may fail by the wayside.</p></li><li><p>华山再高，顶有过路<br>No matter how hign the mountain is, one can always ascend to it’s top.</p></li><li><p>我深深爱着我的国家，没有一片土地让我这样深情和激动，没有一条河流让我这样沉思和祈福，余心之所善兮，虽九死而其尤未悔。<br>I have deep love for this country. I love erery inch of its land. I love every river that flows on this piece of earth with deep passion and deep affection. For the ideal that I hold dear to my heart. I will not regret a thousand depth to die.</p></li><li><p>人或加讪，心无疵兮<br>As a Chinese proverb goes, my conscience stays untained in spite of rumors and slanders from the outside.</p></li><li><p>兄弟虽有小忿，不废懿亲<br>Differences between brothers cannot server their blood ties.</p></li><li><p>不畏浮云遮望眼，只缘身在最高层。<br>As a Chinese poem reads, we have no fear of the clouds that may block our sight, as we are already at the top of the height.</p></li><li><p>入则恳恳以尽忠，出则谦谦以自诲<br>When one is in office he should discharge his duty conscientiously. When leaving office he should conduct himself with humanity and exercise self-reflection.</p></li><li><p>苟利国家生死以，岂因祸福避趋之<br>I shall dedicate myself to the interests of the country in life and death inrrespective of personal weal and woe.</p></li><li><p>知我罪我，其惟春秋<br>There are people who will appreciate what I have done but there are also people who will criticize me. Ultimately, history will have the final say.</p></li><li><p>守职而不废，处义而不回<br>In my last year in office, I will not waver and carrying out my duties, and will remain true to my conviction. I will always be with the people.</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;和则两利，斗则俱伤&lt;br&gt;A peachful and harmonious bilateral relationship between these two countries will make both winners. While a confro
      
    
    </summary>
    
    
      <category term="英文" scheme="http://hi2048.github.io/tags/%E8%8B%B1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>学生出勤记录2</title>
    <link href="http://hi2048.github.io/2021/10/25/%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%952/"/>
    <id>http://hi2048.github.io/2021/10/25/学生出勤记录2/</id>
    <published>2021-10-24T16:00:00.000Z</published>
    <updated>2021-11-22T15:19:25.851Z</updated>
    
    <content type="html"><![CDATA[<pre><code>/*** 学生出勤记录 II* 给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：* &apos;A&apos;：Absent，缺勤* &apos;L&apos;：Late，迟到* &apos;P&apos;：Present，到场* 如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：* 按 总出勤 计，学生缺勤（&apos;A&apos;）严格 少于两天。* 学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（&apos;L&apos;）记录。* 给你一个整数 n，表示出勤记录的长度(次数)。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 数量 。答案可能很大，所以返回对 109 + 7 取余 结果。* * method1: dfs* method2: dp* * @param {number} n* @return {number}*/const dfs = (day, n, absents, lates, memo) =&gt; {  if(day &gt;= n)    return 1;  if(memo[day][absents][lates] !== 0)    return memo[day][absents][lates];  let ans = 0, MOD = 1000000007;  //P  ans = (ans + dfs(day + 1, n, absents, 0, memo)) % MOD;  //A  if(absents &lt; 1) {    ans = (ans + dfs(day + 1, n, 1, 0, memo)) % MOD;  }  //L  if(lates &lt; 2) {    ans = (ans + dfs(day + 1, n, absents, lates + 1, memo)) % MOD;  }  memo[day][absents][lates] = ans;  return ans;}var checkRecord = function(n) {  const memo = new Array(n + 1).fill(0).map(() =&gt; new Array(2).fill(0).map(() =&gt; new Array(3).fill(0)));  return dfs(0, n, 0, 0, memo);};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;/**
* 学生出勤记录 II
* 给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：
* &amp;apos;A&amp;apos;：Absent，缺勤
* &amp;apos;L&amp;apos;：Late，
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="Leetcode" scheme="http://hi2048.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>排列硬币</title>
    <link href="http://hi2048.github.io/2021/10/10/%E6%8E%92%E5%88%97%E7%A1%AC%E5%B8%81/"/>
    <id>http://hi2048.github.io/2021/10/10/排列硬币/</id>
    <published>2021-10-09T16:00:00.000Z</published>
    <updated>2021-11-20T03:44:42.829Z</updated>
    
    <content type="html"><![CDATA[<pre><code>/*** 排列硬币* 你总共有 n 枚硬币，并计划将它们按阶梯状排列。对于一个由 k 行组成的阶梯，其第 i 行必须正好有 i 枚硬币。阶梯的最后一行 可能 是不完整的* 给你一个数字 n ，计算并返回可形成 完整阶梯行 的总行数。* @param {number} n* @return {number}*/const getTotal = n =&gt; {  return (1 + n) * n / 2;}var arrangeCoins = function(n) {  let maxRow = 0;  for(let i = 0; i &lt;= n; i++) {    if(getTotal(i) &lt;= n) {      maxRow = i;    } else {      return maxRow;    }  }  return maxRow;};/*** @param {number} n* @return {number}*/var arrangeCoins = function(n) {  let left = 1, right = n;  while(left &lt; right) {    const mid = Math.floor((right - left + 1) / 2) + left;    if(n &gt;= mid * (mid + 1) / 2) {      left = mid;    } else {      right = mid - 1;    }  }  return left;};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;/**
* 排列硬币
* 你总共有 n 枚硬币，并计划将它们按阶梯状排列。对于一个由 k 行组成的阶梯，其第 i 行必须正好有 i 枚硬币。阶梯的最后一行 可能 是不完整的
* 给你一个数字 n ，计算并返回可形成 完整阶梯行 的总行数。
* @param 
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="Leetcode" scheme="http://hi2048.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>只有两个键的键盘</title>
    <link href="http://hi2048.github.io/2021/09/19/%E5%8F%AA%E6%9C%89%E4%B8%A4%E4%B8%AA%E9%94%AE%E7%9A%84%E9%94%AE%E7%9B%98/"/>
    <id>http://hi2048.github.io/2021/09/19/只有两个键的键盘/</id>
    <published>2021-09-18T16:00:00.000Z</published>
    <updated>2021-11-26T03:59:12.191Z</updated>
    
    <content type="html"><![CDATA[<pre><code>/*** 只有两个键的键盘* 最初记事本上只有一个字符 &apos;A&apos; 。你每次可以对这个记事本进行两种操作：* Copy All（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。* Paste（粘贴）：粘贴 上一次 复制的字符。* 给你一个数字 n ，你需要使用最少的操作次数，在记事本上输出 恰好 n 个 &apos;A&apos; 。返回能够打印出 n 个 &apos;A&apos; 的最少操作次数。* i = j * i/j, i % j === 0,  j or i / j &lt; sqrt(i)* dp(i) = min(dp(i), dp(j) + i / j, dp(i / j) + j)* */function minSteps(n: number): number {  const dp = new Array(n + 1).fill(0);  for(let i = 2; i &lt;= n; i++) {    dp[i] = Number.MAX_SAFE_INTEGER;    for(let j = 1; j &lt;= Math.sqrt(i); j++) {      if(i % j === 0) {        dp[i] = Math.min(dp[i], dp[j] + i / j);        dp[i] = Math.min(dp[i], dp[i / j] + j);      }    }  }  return dp[n];};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;/**
* 只有两个键的键盘
* 最初记事本上只有一个字符 &amp;apos;A&amp;apos; 。你每次可以对这个记事本进行两种操作：
* Copy All（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。
* Paste（粘贴）：粘贴 上一次 复制
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="Leetcode" scheme="http://hi2048.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>系统性思维</title>
    <link href="http://hi2048.github.io/2021/09/01/%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%80%9D%E7%BB%B4/"/>
    <id>http://hi2048.github.io/2021/09/01/系统性思维/</id>
    <published>2021-08-31T16:00:00.000Z</published>
    <updated>2021-09-05T02:58:19.188Z</updated>
    
    <content type="html"><![CDATA[<p>系统性思维与局部性思维</p><p>  <strong> 系统性思维做出决策，然后在局部中做出选择 </strong>。<strong> 先有方向再有选择 </strong>，而不是随便做出了选择，然后再从选择中确定方向。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;系统性思维与局部性思维&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt; 系统性思维做出决策，然后在局部中做出选择 &lt;/strong&gt;。&lt;strong&gt; 先有方向再有选择 &lt;/strong&gt;，而不是随便做出了选择，然后再从选择中确定方向。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学生出勤记录1</title>
    <link href="http://hi2048.github.io/2021/08/17/%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%951/"/>
    <id>http://hi2048.github.io/2021/08/17/学生出勤记录1/</id>
    <published>2021-08-16T16:00:00.000Z</published>
    <updated>2021-11-22T15:18:59.679Z</updated>
    
    <content type="html"><![CDATA[<pre><code>/*** 学生出勤记录 I* 给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：* &apos;A&apos;：Absent，缺勤* &apos;L&apos;：Late，迟到* &apos;P&apos;：Present，到场* 如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：* 按 总出勤 计，学生缺勤（&apos;A&apos;）严格 少于两天。* 学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（&apos;L&apos;）记录。* 如果学生可以获得出勤奖励，返回 true ；否则，返回 false 。* * @param {string} s* @return {boolean}*/var checkRecord = function(s) {  let absents = 0, lates = 0;  for(let i = 0; i &lt; s.length; i++) {    const c = s[i];    if(c === &apos;A&apos;) {      absents ++;      if(absents &gt;= 2) {          return false;      }    }    if(c === &apos;L&apos;) {      lates ++;      if(lates &gt;= 3) {        return false;      }    } else {      lates = 0;    }  }  return true;};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;/**
* 学生出勤记录 I
* 给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：
* &amp;apos;A&amp;apos;：Absent，缺勤
* &amp;apos;L&amp;apos;：Late，迟
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="Leetcode" scheme="http://hi2048.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>连续子数组的最大和</title>
    <link href="http://hi2048.github.io/2021/07/17/%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <id>http://hi2048.github.io/2021/07/17/连续子数组的最大和/</id>
    <published>2021-07-16T16:00:00.000Z</published>
    <updated>2021-11-24T12:02:06.386Z</updated>
    
    <content type="html"><![CDATA[<pre><code>/*** 剑指 Offer: 连续子数组的最大和* 输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。* 要求时间复杂度为O(n)。* dp(i)以i结尾的连续最大子数组* dp(i - 1) &lt;= 0, dp(i) = n[i]* dp(i - 1 ) &gt; 0, dp(i) = dp(i - 1) + n[i]* * @param {number[]} nums* @return {number}*/var maxSubArray = function(nums) {  const dp = new Array(nums.length).fill(nums[0]);  let max = nums[0];  for(let i = 1; i &lt; nums.length; i++) {    if(dp[i - 1] &lt;= 0) {      dp[i] = nums[i];    } else {      dp[i] = dp[i - 1] + nums[i];    }    max = Math.max(max, dp[i]);  }  return max;};var maxSubArray = function(nums) {  let dp = nums[0], max = nums[0];  for(let i = 1; i &lt; nums.length; i++) {    if(dp &lt;= 0) {      dp = nums[i];    } else {      dp += nums[i];    }    max = Math.max(max, dp);  }  return max;};var maxSubArray = function(nums) {  let dp = nums[0], max = nums[0];  for(let i = 1; i &lt; nums.length; i++) {    dp = Math.max(dp + nums[i], nums[i]);    max = Math.max(max, dp);  }  return max;};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;/**
* 剑指 Offer: 连续子数组的最大和
* 输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。
* 要求时间复杂度为O(n)。
* dp(i)以i结尾的连续最大子数组
* dp(i - 1) &amp;lt;= 0, 
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="Leetcode" scheme="http://hi2048.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>石子游戏</title>
    <link href="http://hi2048.github.io/2021/06/16/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/"/>
    <id>http://hi2048.github.io/2021/06/16/石子游戏/</id>
    <published>2021-06-15T16:00:00.000Z</published>
    <updated>2021-11-25T04:53:11.191Z</updated>
    
    <content type="html"><![CDATA[<pre><code>/*** 石子游戏* * 亚历克斯和李 用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。* 游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。* 亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。* 假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。* dp(i)(j) [i, j]中当前玩家与另一玩家的差值* dp(i)(i) = piles[i]* dp(i)(j) = max(piles[i] - dp(i + 1)(j), piles[j] - dp(i)(j - 1) )* * @param {number[]} piles* @return {boolean}*/var stoneGame = function(piles) {  const dp = new Array(piles.length).fill(0).map((arrItem1, i) =&gt; new Array(piles.length).fill(0).map((arrItem2, j) =&gt; {    if(i == j) {      return piles[i];    } else {      return 0;    }  }));  for(let i = piles.length - 2; i &gt;= 0; i--) {    for(let j = i + 1; j &lt; piles.length; j++) {      dp[i][j] = Math.max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1]);    }  }  return dp[0][piles.length - 1] &gt; 0;};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;/**
* 石子游戏
* 
* 亚历克斯和李 用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。
* 游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。
* 亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="Leetcode" scheme="http://hi2048.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Scrum笔记</title>
    <link href="http://hi2048.github.io/2021/05/02/Scrum%E7%AC%94%E8%AE%B0/"/>
    <id>http://hi2048.github.io/2021/05/02/Scrum笔记/</id>
    <published>2021-05-02T06:21:41.000Z</published>
    <updated>2021-09-05T02:24:18.442Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Scrum 采用<strong>迭代、增量</strong>的方法来优化可预见性并控制风险。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;Scrum 采用&lt;strong&gt;迭代、增量&lt;/strong&gt;的方法来优化可预见性并控制风险。&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>商品折扣后的最终价格</title>
    <link href="http://hi2048.github.io/2021/04/06/%E5%95%86%E5%93%81%E6%8A%98%E6%89%A3%E5%90%8E%E7%9A%84%E6%9C%80%E7%BB%88%E4%BB%B7%E6%A0%BC/"/>
    <id>http://hi2048.github.io/2021/04/06/商品折扣后的最终价格/</id>
    <published>2021-04-05T16:00:00.000Z</published>
    <updated>2021-11-20T02:05:41.003Z</updated>
    
    <content type="html"><![CDATA[<pre><code>/*** 给你一个数组 prices ，其中 prices[i] 是商店里第 i 件商品的价格。* 商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 prices[j] 相等的折扣，* 其中 j 是满足 j &gt; i 且 prices[j] &lt;= prices[i]的 最小下标 ，如果没有满足条件的 j ，你将没有任何折扣。* 请你返回一个数组，数组中第 i 个元素是折扣后你购买商品 i 最终需要支付的价格。* * Notice: ** Array.sort ** will change the original array, ** Array.map ** will not change the original array, and both will return new created array* * @param {number[]} prices* @return {number[]}*/const getDiscount = (prices, index) =&gt; {  for(let i = index + 1; i &lt; prices.length; i++) {    if(prices[i] &lt;= prices[index]) {      return prices[i]    }  }  return 0;}var finalPrices = function(prices) {  return prices.map((price, index, prices) =&gt; price - getDiscount(prices, index));};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;/**
* 给你一个数组 prices ，其中 prices[i] 是商店里第 i 件商品的价格。
* 商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 prices[j] 相等的折扣，
* 其中 j 是满足 j &amp;gt; i 且 pric
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="Leetcode" scheme="http://hi2048.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>俄罗斯套娃信封问题</title>
    <link href="http://hi2048.github.io/2021/03/15/%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98/"/>
    <id>http://hi2048.github.io/2021/03/15/俄罗斯套娃信封问题/</id>
    <published>2021-03-14T16:00:00.000Z</published>
    <updated>2021-11-19T11:35:33.661Z</updated>
    
    <content type="html"><![CDATA[<pre><code>/*** 俄罗斯套娃信封问题* 给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。* 当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。* 请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。* @param {number[][]} envelopes* @return {number}* envelopes sort by first value, and sort by second value for the same first value envelopes* dp(i) = max(dp(i), dp(j) + 1)*/var maxEnvelopes = function(envelopes) {  const dp = new Array(envelopes.length).fill(1);  envelopes.sort((item1, item2) =&gt; {    return item1[0] - item2[0];  }).sort((item1, item2) =&gt; {    if(item1[0] === item2[0]) {      return item2[1] - item1[1];    }    return 0;  });  for(let i = 0; i &lt; envelopes.length; i++ ) {    for(let j = 0; j &lt; i; j++) {      if(envelopes[i][1] &gt; envelopes[j][1]) {        dp[i] = Math.max(dp[i], dp[j] + 1);      }    }  }  return Math.max(...dp);};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;/**
* 俄罗斯套娃信封问题
* 给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。
* 当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="Leetcode" scheme="http://hi2048.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>最长递增子序列</title>
    <link href="http://hi2048.github.io/2021/02/05/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://hi2048.github.io/2021/02/05/最长递增子序列/</id>
    <published>2021-02-04T16:00:00.000Z</published>
    <updated>2021-11-19T11:32:13.065Z</updated>
    
    <content type="html"><![CDATA[<pre><code>/*** 最长递增子序列* 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。* @param {number[]} nums* @return {number}* dp(i) = max(dp(i), dp(j) + 1)*/var lengthOfLIS = function(nums) {  const dp = new Array(nums.length).fill(1);  for(let i = 0; i &lt; nums.length; i++) {    for(let j = 0; j &lt; i; j++) {      if(nums[j] &lt; nums[i]) {        dp[i] = Math.max(dp[i], dp[j] + 1);      }    }  }  return Math.max(...dp);};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;/**
* 最长递增子序列
* 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
* @param {number[]} nums
* @return {number}
* dp(i) = max(dp(i), dp(j) + 1)
*/
v
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="Leetcode" scheme="http://hi2048.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>理财笔记</title>
    <link href="http://hi2048.github.io/2021/02/01/%E7%90%86%E8%B4%A2%E7%AC%94%E8%AE%B0/"/>
    <id>http://hi2048.github.io/2021/02/01/理财笔记/</id>
    <published>2021-01-31T16:00:00.000Z</published>
    <updated>2021-09-12T16:05:41.164Z</updated>
    
    <content type="html"><![CDATA[<p>市场概率：1. 胜率 2. 赔率： 即盈亏比 3. 破产率：仓位控制或者资金管理 </p><p>赔率才是交易员要考虑的根本问题。<br>你正确或错误并不是最重要的，最重要的是你正确的时候能赚多少钱，错误的时候会亏多少钱。 – 索罗斯</p><p><strong>赚大赔小，生存第一。</strong></p><p>第一保住本金，第二保住本金，第三认真考虑第一第二条。 – 巴菲特</p><p>一律：纪律，用纪律去统领一切概率的可能性。 1. 胜败：<strong>趋势掌控能力</strong>，行情是否按照计划的大概率事件进行 2. 对错：<strong>计划执行能力</strong>，整体策略的执行力结果 3. 盈亏</p><p>信念： 大道至简，坚信自己可以成功，信念的坚定其实是中庸之道。</p><p>左倾冒进主义： 盲目自信，扛单，频繁交易，重仓交易，赌气交易。<br>右倾投降主义： 做单太谨小慎微，明明是很好的机会，不敢下单，<strong>错失机会</strong>。</p><p>知识与智慧： 知识是可以通过学习获得，智慧只能通过体悟和实践获得。</p><p>熟知与真知： 通过学习知道与通过实践知道的区别。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;市场概率：1. 胜率 2. 赔率： 即盈亏比 3. 破产率：仓位控制或者资金管理 &lt;/p&gt;
&lt;p&gt;赔率才是交易员要考虑的根本问题。&lt;br&gt;你正确或错误并不是最重要的，最重要的是你正确的时候能赚多少钱，错误的时候会亏多少钱。 – 索罗斯&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;赚大赔小
      
    
    </summary>
    
      <category term="杂谈" scheme="http://hi2048.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="理财" scheme="http://hi2048.github.io/tags/%E7%90%86%E8%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript notes</title>
    <link href="http://hi2048.github.io/2021/01/09/TypeScript-notes/"/>
    <id>http://hi2048.github.io/2021/01/09/TypeScript-notes/</id>
    <published>2021-01-08T16:00:00.000Z</published>
    <updated>2021-11-27T07:03:34.058Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>origin data type: number, string, boolean, null, undefined, void, symbol, bigint</p></li><li><p>non-origin data type: object, array, tuple, enum</p><pre><code>const arr: string[] = [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;]const tuple: [string, number, string] = [&apos;1&apos;, 2, &apos;3&apos;]</code></pre></li><li><p>any, unknown, never<br>any 类型的变量是可以进行任意进行赋值、实例化、函数执行等操作，但是 unknown 只允许赋值，不允许实例化、函数执行等操作<br>never 的字面意思是 “永不”，在 TS 中代表不存在的值类型，一般用于给函数进行类型声明，函数绝不会有返回值的时候使用，比如函数内抛出错误</p></li><li><p>interface</p><pre><code>interface Todo {  content: string;  readonly user: string;  time?: string;  isComplete: boolean;  [propName: string]: any;}</code></pre></li><li><p>enum</p><pre><code>enum UserId {  tuture = &apos;666&apos;,  mRcfps = 6,}</code></pre></li><li><p>函数类型</p><pre><code>const add: (x: number, y: number, z?: number): number = function(x, y) {  // ...  return x + y;}</code></pre></li></ol><p>7.1 交叉类型 &amp;<br>        interface ErrorHandling {<br>          success: boolean;<br>          error?: { message: string };<br>        }<br>        interface ArtistsData {<br>          artists: { name: string }[];<br>        }<br>        const handleArtistsResponse = (response: ArtistsData &amp; ErrorHandling) =&gt; {<br>          if(response.error) {<br>            console.error(response.error.message);<br>            return;<br>          }<br>          console.log(response.artists);<br>        }</p><p>7.2 联合类型 |<br>        const padLeft = (value: string, padding: string | number) =&gt; void</p><ol start="8"><li><p>字面量类型<br>字面量可是说是 TS 类型系统里面最小的类型。<br>数字字面量<br>let tuture: 520<br>字符串字面量<br>let tuture: ‘520’</p></li><li><p>类型守卫<br>联合类型+字面量类型<br>主要用于在进行 ”联合“ 的多个类型之间，存在相同的字段，也存在不同的字段，然后需要区分具体什么时候是使用哪个类型</p></li><li><p>类型别名</p><pre><code>type NameParams = &apos;string&apos; | () =&gt; &apos;string&apos;;function getName(n: NameParams): string {}</code></pre></li><li><p>类型别名与接口</p><pre><code>type name = &apos;string&apos;type tuture ={  tutureCommunity: string;  editure: string;  tutureDocs: string;}interface Tuture {  tutureCommunity: string;  editure: string;  tutureDocs: string;}</code></pre></li><li><p>类<br>ES6<br>构造函数<br>属性<br>实例属性<br>静态属性<br>方法<br>实例方法<br>静态方法<br>TS<br>注解构造函数<br>注解属性<br>访问限定符: public/protected/private<br>修饰符: readonly<br>注解方法<br>访问限定符: public/protected/private</p><pre><code>class Animal {  name: string;  static isAnimal(a: Animal): boolean {    return a instanceof Animal;  }  constructor(name: string) {    this.name = name;  }  move(distance: number) {    console.log(`${this.name} moved ${distance}m.`);  }}</code></pre><p>Public<br>public 代表公共的，表示被此访问限定符修饰的属性，方法可以任何地方访问到：1）类中 2）类的实例对象 3）类的子类中 4）子类的实例对象 等，默认所有类的和方法都是 public 修饰的<br>Protected<br>在类和子类中访问，不能被类的实例对象访问也不能被子类的实例对象访问<br>Private<br>在类的内部访问<br>只读修饰符<br>readonly<br>抽象类<br>抽象类与抽象方法</p><pre><code>abstract class Animal {  abstract makeSound(): void;  move(): void {    console.log(&quot;Roaming the earth...&quot;);  }}</code></pre><p>抽象类的继承</p><pre><code>class Bird extends Animal {  makeSound(): void {    console.log(&apos;Tuture tuture tuture.&apos;);  }}</code></pre><p>构造函数<br>声明的 Animal 类型不包括构造函数 constructor 以及类中的静态方法和静态属性，就像实例对象中是不包含类的构造函数、静态方法和静态属性一样<br>类与接口<br>类实现接口</p><pre><code>interface Alarm {  alert(): void;}interface Light {  lightOn(): void;  lightOff(): void;}class Car implements Alarm, Light {  alert() {    console.log(&apos;Car alarm&apos;);  }  lightOn() {    console.log(&apos;Car light on&apos;);  }  lightOff() {    console.log(&apos;Car light off&apos;);  }}class Door implements Alarm {  alert() {    console.log(&apos;Door alarm&apos;);  }}</code></pre><p>接口继承类</p><pre><code>class Point {  x: number;  y: number; }interface Point3D extends Point {  z: number;}</code></pre><p>接口继承的是声明 Point 类时同时声明的用于注解类实例的那个类型, 而这个类型只包含类的实例属性和方法，所以接口继承类也是继承此类的实例属性和方法的类型<br>类作为接口使用<br>1）多个类实现同一个接口来复用接口的属性或者方法 2）一个类实现多个接口 3）接口也可以继承类，只不过是继承类声明时同时声明的同名类型 4）类作为接口，通过进一步应用类声明的两个内容来简化 React 组件代码，提高代码的逻辑性和可复用性</p></li><li><p>泛型<br>配置TypeScript npx tsc –init</p><pre><code>tsconfig.json{  &quot;compilerOptions&quot;: {    &quot;outDir&quot;: &quot;./dist&quot; // 设置编译输出的文件夹  },  &quot;include&quot;: [    // 需要编译的ts文件一个*表示文件匹配**表示忽略文件的深度问题    &quot;./src/**/*.ts&quot;  ],  &quot;exclude&quot;: [&quot;node_modules&quot;, &quot;dist&quot;, &quot;**/*.test.ts&quot;] // 排除不需要编译的文件夹}&quot;build:w&quot;: &quot;tsc -w&quot; // watch 模式</code></pre><p>类型的函数</p><pre><code>function getTutureTutorialsInfo&lt;T, U&gt;(info: T[], profile: U): T[] {  console.log(info.length);  console.log(profile);  return info;}getTutureTutorialsInfo&lt;string, object&gt;([&apos;hello tuture&apos;, &apos;hello world&apos;], { username: &apos;tuture&apos; });</code></pre><p>泛型是在调用时再限定类型<br>我们在定义泛型的时候，是一系列类型变量，如 T 、 U 等，这些变量实际的类型我们在定义的时候是不知道的，只有在进行泛型调用的时候，由用户给定实际的类型以这里有一种延迟声明类型的作用。<br>匿名函数泛型</p><pre><code>const getTUtureTutorialsInfo: &lt;T&gt;(info: T[]) =&gt; T[] = (info) =&gt; {  console.log(info.length);  return info;}</code></pre><p>泛型默认类型参数<br>&lt;T, U = number&gt;<br>泛型数组 Array<t><br>类泛型<br>class TodoInput extends React.Component&lt;TodoInputProps, TodoInputState&gt;<br>接口泛型</t></p><pre><code>interface Profile&lt;T&gt; {  username: string;  nickName: string;  avatar: string;  age: T;}type ProfileWithAge = Profile&lt;string&gt;</code></pre><p>类型别名泛型</p><pre><code>type Profile&lt;T&gt; = {  username: string;  age: T;}type ProfileWithAge = Profile&lt;string&gt;;</code></pre><p>泛型约束</p><pre><code>type Profile&lt;T&gt; = {  username: string;  age: T;}function getTutureTutorialsInfo&lt;T, U extends Profile&lt;string&gt;&gt;(info: T[], profile: U): T[] {  console.log(info.length);  console.log(profile);  return info;}</code></pre></li></ol><p>类：<br>        class Profile<t>{<br>          username: string;<br>          age: T;<br>        }</t></p><p>接口:<br>        interface Profile<t> {<br>          username: string;<br>          age: T;<br>        }</t></p><p>类型别名：<br>        type Profile<t> = {<br>          username: string;<br>          age: T;<br>        }</t></p><p>duck typing<br>当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。<br>TS 类型是鸭子类型, 是基于代码的实际样子来进行类型注解的<br>构造函数的注解<br>        interface ConstructorFunction<c> {<br>          new (): C;<br>        }</c></p><p>类在声明的时候会声明两个东西：1）用于注解此类实例的类型 2）以及此类的构造函数。<br>        const profileConstructor: ConstructorFunction&lt;Profile<string>&gt; = Profile;</string></p><p>注解构造函数<br>        class Profile<t> {<br>          username: string;<br>          age: T;<br>        }<br>        class TutureProfile extends Profile<string> {<br>          github: string;<br>          remote: string[];<br>        }<br>        interface ConstructorFunction<c> {<br>          new (): C;<br>        }<br>        function createInstance&lt;A extends Profile<string>&gt;(B: ConstructorFunction<a>) {<br>          return new B();<br>        }<br>        const myTutureProfile = createInstance(TutureProfile);</a></string></c></string></t></p><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/144004258" target="_blank" rel="noopener">一只图雀 类型即正义</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;origin data type: number, string, boolean, null, undefined, void, symbol, bigint&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;non-origin data type: object, 
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="TypeScript" scheme="http://hi2048.github.io/tags/TypeScript/"/>
    
  </entry>
  
</feed>
