<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>苏小蜂的个人博客</title>
  
  <subtitle>放慢脚步，享受生活！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hi2048.github.io/"/>
  <updated>2019-09-16T04:33:10.127Z</updated>
  <id>http://hi2048.github.io/</id>
  
  <author>
    <name>Jsu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript哈希</title>
    <link href="http://hi2048.github.io/2019/09/16/JavaScript%E5%93%88%E5%B8%8C/"/>
    <id>http://hi2048.github.io/2019/09/16/JavaScript哈希/</id>
    <published>2019-09-15T16:00:00.000Z</published>
    <updated>2019-09-16T04:33:10.127Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 表结构与JS对象结构转换，将数据结构A转换为数据结构B。 </strong></p><pre><code>// 定义数据结构const nodeAStruct = function(id, pid, data) {  this.id = id;  this.pid = pid;  this.data = data;}const nodeBStruct = function(id, children, data) {  this.id = id;  this.children = children;  this.data = data;}// 打印：深度遍历const print = (tree) =&gt; {  console.log(tree.data);  if(tree.children &amp;&amp; tree.children.length &gt; 0){    const children = tree.children;    children.forEach(child =&gt; {      print(child);    });  }}// 方法一：递归遍历const convert2Tree = (nodes = [], pid) =&gt; {  const result = [];  let temp = [];  nodes.forEach((node) =&gt; {    if(node.pid === pid){      const nodeB = new nodeBStruct(node.id, [], node.data);      temp = convert2Tree(nodes, node.id);      if(temp.length &gt; 0){        nodeB.children = temp;      }      result.push(nodeB);    }  });  return result;}// 方法二：hash处理const convertNodes2Hash = (nodes = []) =&gt; {  const hash = {};  nodes.forEach((node) =&gt; {    const nodeB = new nodeBStruct(node.id, [], node.data);    if(hash[node.pid]){      hash[node.pid].push(nodeB);    } else{      hash[node.pid] = [nodeB];    }  });  return hash;}const convertR = (hash, pid) =&gt; {  hash[pid].forEach(hp =&gt; {    const hc = hash[hp.id];    hp.children = hc?hc : [];    if(hc){      convertR(hash, hp.id);    }  });  return hash;}const convert2TreeByHash = (nodes = []) =&gt; {  const hash = convertNodes2Hash(nodes);  convertR(hash, -1);  return hash[-1];}const nodes = [];nodes.push(new nodeAStruct(0, -1, &apos;data0&apos;))nodes.push(new nodeAStruct(1, 0, &apos;data1&apos;))nodes.push(new nodeAStruct(2, 0, &apos;data2&apos;))nodes.push(new nodeAStruct(3, 1, &apos;data3&apos;))nodes.push(new nodeAStruct(4, 1, &apos;data4&apos;))nodes.push(new nodeAStruct(5, 2, &apos;data5&apos;))nodes.push(new nodeAStruct(6, 2, &apos;data6&apos;))let tree = convert2TreeByHash(nodes);print(tree[0]);console.log(tree[0])console.log(&apos;-----------------------&apos;);tree = convert2Tree(nodes, -1);print(tree[0]);console.log(tree[0])</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 表结构与JS对象结构转换，将数据结构A转换为数据结构B。 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 定义数据结构
const nodeAStruct = function(id, pid, data) {
  this.id = id;
  
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>最大气球</title>
    <link href="http://hi2048.github.io/2019/09/15/%E6%9C%80%E5%A4%A7%E6%B0%94%E7%90%83/"/>
    <id>http://hi2048.github.io/2019/09/15/最大气球/</id>
    <published>2019-09-14T16:00:00.000Z</published>
    <updated>2019-09-16T03:29:09.212Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>LeetCode - “气球” 的最大数量<br><strong> 给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 “balloon”（气球）。 </strong><br><strong> 字符串 text 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 “balloon”。 </strong></p><pre><code>/** * @param {string} text * @return {number} 输入：text = &quot;nlaebolko&quot; 输出：1 输入：text = &quot;loonbalxballpoon&quot; 输出：2 输入：text = &quot;leetcode&quot; 输出：0 提示：  - 1 &lt;= text.length &lt;= 10^4  - text 全部由小写英文字母组成 */var getAlphaFromText = (text, alpha) =&gt; {  const reg = new RegExp(`${alpha}`, &apos;g&apos;);  if(reg.test(text)){    return text.match(reg).length;  }  return 0;}//balloonvar maxNumberOfBalloons = function(text) {    if(!text || (text &amp;&amp; text.length === 0)) return 0;    const balloonByteChars = [&apos;b&apos;, &apos;a&apos;, &apos;l&apos;, &apos;o&apos;, &apos;n&apos;];    const ret = balloonByteChars.reduce((count, b) =&gt; {      let len = getAlphaFromText(text, b);      if(b === &apos;l&apos; || b === &apos;o&apos;){        len = Math.floor(len / 2);      }      if(count &gt; len){        count = len;      }      return count;    }, text.length);    return ret;};</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;LeetCode - “气球” 的最大数量&lt;br&gt;&lt;strong&gt; 给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 “balloon”（气球）。 &lt;/strong&gt;&lt;br&gt;&lt;strong&gt; 字符串 text 中的每个字母最多只
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>状态管理</title>
    <link href="http://hi2048.github.io/2019/09/02/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    <id>http://hi2048.github.io/2019/09/02/状态管理/</id>
    <published>2019-09-01T16:00:00.000Z</published>
    <updated>2019-09-05T14:59:46.811Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>vuex</p><ul><li>vuex 是一个专门为vue.js应用程序开发的状态管理模式。</li></ul></li><li><p>状态自管理应用</p><ul><li>state, view, actions<br><a href="/assets/vue-flow.png"><img src="/assets/vue-flow.png" alt="vue-flow"></a></li></ul></li><li><p>vuex应用</p><p><a href="/assets/vuex.png"><img src="/assets/vuex.png" alt="vuex"></a></p></li><li><p>为什么引入状态管理模式</p><ul><li>多个视图依赖于同一状态。</li><li>来自不同视图的行为需要变更同一状态。</li></ul><p><strong> 传统的vue在解决上述问题时，会导致代码复杂与难于维护，vuex采用全局单例模式管理，可以使得代码更结构化且易维护。 </strong></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;vuex&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vuex 是一个专门为vue.js应用程序开发的状态管理模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;状态自管理应用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;state, view, actions&lt;br&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="React" scheme="http://hi2048.github.io/tags/React/"/>
    
      <category term="vue" scheme="http://hi2048.github.io/tags/vue/"/>
    
      <category term="vuex" scheme="http://hi2048.github.io/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>Vue生命周期</title>
    <link href="http://hi2048.github.io/2019/08/02/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://hi2048.github.io/2019/08/02/Vue生命周期/</id>
    <published>2019-08-01T16:00:00.000Z</published>
    <updated>2019-09-05T14:58:52.372Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>Vue实例有一个完整的生命周期，也就是说从开始创建、初始化数据、编译模板、挂在DOM、渲染-更新-渲染、卸载等一系列过程，我们成为Vue 实例的生命周期，钩子就是在某个阶段给你一个做某些处理的机会。</p></li><li><p>Vue生命周期钩子</p><ul><li>beforeCreate</li><li>created</li><li>beforeMount</li><li>mounted</li><li>beforeUpdate</li><li>updated</li><li>beforeDestroy</li><li>destroyed</li></ul></li></ol><p><a href="/assets/lifecycle-vue.png"><img src="/assets/lifecycle-vue.png" alt="vue-生命周期"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;Vue实例有一个完整的生命周期，也就是说从开始创建、初始化数据、编译模板、挂在DOM、渲染-更新-渲染、卸载等一系列过程，我们成为Vue 实例的生命周期，钩子就是在某个阶段给你一个做某些处理的机会。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Vue生命周期钩子&lt;/
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="vue" scheme="http://hi2048.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>compose</title>
    <link href="http://hi2048.github.io/2019/06/10/compose/"/>
    <id>http://hi2048.github.io/2019/06/10/compose/</id>
    <published>2019-06-09T16:00:00.000Z</published>
    <updated>2019-09-10T15:47:32.356Z</updated>
    
    <content type="html"><![CDATA[<p><strong> JavaScript函数式编程：compose方法 </strong></p><pre><code>const compose = (arr) =&gt; {    return arr.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))}const composeT = (arr) =&gt; {  return arr.reduce((a, b) =&gt; {    return (...args) =&gt; {      console.log(`${a.name}(${b.name}(${args}))`);      return a(b(...args));    }  }, ()=&gt;{})}const a = (a, b) =&gt; {console.log(&quot;a: &quot;, a); return a;}const b = (a, b) =&gt; {console.log(&quot;b: &quot;, a); return a;}const c = (a, b) =&gt; {console.log(&quot;c: &quot;, a, b); return [a, b];}composeT([a,b,c])(&apos;1&apos;,&apos;2&apos;)(c(1,2))c:  1 2(b(1,2))b:  [ &apos;1&apos;, &apos;2&apos; ](a(1,2))a:  [ &apos;1&apos;, &apos;2&apos; ]</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; JavaScript函数式编程：compose方法 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const compose = (arr) =&amp;gt; {
    return arr.reduce((a, b) =&amp;gt; (...args) =&amp;
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>数组去重</title>
    <link href="http://hi2048.github.io/2019/02/18/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
    <id>http://hi2048.github.io/2019/02/18/数组去重/</id>
    <published>2019-02-17T16:00:00.000Z</published>
    <updated>2019-09-18T14:31:10.318Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>使用Array的filter方法</p><pre><code>const distinctFilter = (arr) =&gt; (arr.filter((item, index) =&gt; (arr.indexOf(item) === index)))</code></pre></li><li><p>使用ES6的Set</p><pre><code>const distinctSet = (arr) =&gt; (Array.from(new Set(arr)));</code></pre></li><li><p>使用Hash方法</p><pre><code>const distinctHash = (arr) =&gt; {  const hash = {};  let disArr = [];  for(let i of arr){    if(!hash[i]){      disArr.push(i);      hash[i] = [i];    }  }  return disArr;}</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用Array的filter方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const distinctFilter = (arr) =&amp;gt; (arr.filter((item, index) =&amp;gt; (arr.indexOf(item) === index)
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>LRU算法</title>
    <link href="http://hi2048.github.io/2019/02/10/LRU%E7%AE%97%E6%B3%95/"/>
    <id>http://hi2048.github.io/2019/02/10/LRU算法/</id>
    <published>2019-02-09T16:00:00.000Z</published>
    <updated>2019-09-18T13:24:33.512Z</updated>
    
    <content type="html"><![CDATA[<p><strong> LRU (least recently used) 缓存机制：实现get, put方法。 </strong></p><pre><code>/** * 元素置顶 */const popItemFromArray = (arr, key) =&gt;{  arr.splice(arr.indexOf(key), 1);  arr.push(key);  return arr;}/** * 实现思路：ES6 Map [+ 有序数组（或者双向链表）] **/var LRUCache = function(capacity) {    this.cache = new Map();    this.lruArr = new Array();    this.curLen = 0;    this.capacity = capacity;};LRUCache.prototype.get = function(key) {    if(this.cache.has(key)){      const value = this.cache.get(key);      popItemFromArray(this.lruArr, key);      return value;    }    return -1;};LRUCache.prototype.lruDel = function(){  const minKey = this.lruArr.shift();  const isucc = this.cache.delete(minKey);  if(isucc){    this.curLen--;  }  return isucc;}// iorder : false descend true ascendLRUCache.prototype.sort = function(iorder) {  return this.lruArr.sort((c1, c2) =&gt; {    return c1 - c2;  });}LRUCache.prototype.put = function(key, value) {    if(this.cache.has(key)){      // pop key from lru array      popItemFromArray(this.lruArr, key);      return this.cache.set(key, value);    }    if(this.curLen === this.capacity){      this.lruDel();    }    this.curLen++;    this.lruArr.push(key);    return this.cache.set(key, value);};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; LRU (least recently used) 缓存机制：实现get, put方法。 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 元素置顶
 */
const popItemFromArray = (arr, key) =&amp;gt;{
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Heap实现</title>
    <link href="http://hi2048.github.io/2019/01/19/Heap%E5%AE%9E%E7%8E%B0/"/>
    <id>http://hi2048.github.io/2019/01/19/Heap实现/</id>
    <published>2019-01-18T16:00:00.000Z</published>
    <updated>2019-09-19T11:46:09.241Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 小根堆实现，大根堆类似 </strong></p><pre><code>// 通过 up down方法实现 堆的有效性class Heap {  constructor(){    this.heap = new Array();  }  swap(id1, id2) {    let temp = this.heap[id1];    this.heap[id1] = this.heap[id2];    this.heap[id2] = temp;  }  up(id) {    let pid = Math.floor((id - 1) / 2);    if(id !== 0 &amp;&amp; this.heap[pid] &gt; this.heap[id]){      this.swap(pid, id);      this.up(pid);    }  }  down(id) {    let leftChildId = id * 2 + 1;    let rightChildId = id * 2 + 2;    let len = this.heap.length;    if(leftChildId &lt; len &amp;&amp; this.heap[leftChildId] &lt; this.heap[id]){      this.swap(leftChildId, id);      this.down(leftChildId);    }    if(rightChildId &lt; len &amp;&amp; this.heap[rightChildId] &lt; this.heap[id]){      this.swap(rightChildId, id);      this.down(rightChildId);    }  }  insert(x) {    this.heap.push(x);    this.up(this.heap.length - 1);  }  remove(){    this.swap(0, this.heap.length - 1);    const ret = this.heap.pop();    this.down(0);    return ret;  }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 小根堆实现，大根堆类似 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 通过 up down方法实现 堆的有效性
class Heap {
  constructor(){
    this.heap = new Array();
  }

  s
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>React16为什么更新</title>
    <link href="http://hi2048.github.io/2018/12/11/React16%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9B%B4%E6%96%B0/"/>
    <id>http://hi2048.github.io/2018/12/11/React16为什么更新/</id>
    <published>2018-12-10T16:00:00.000Z</published>
    <updated>2019-09-11T09:35:37.523Z</updated>
    
    <content type="html"><![CDATA[<p><strong> React16更新的根本原因是提升用户体验，解决同步更新带来的界面卡顿问题。 </strong></p><ol><li><p>React16之前的版本中，更新过程是同步的，为什么会导致界面卡顿？<br><strong> 大量的同步计算任务阻塞了浏览器的UI渲染 </strong></p><ul><li>JavaScript是单线程的。</li><li>JavaScript运算、页面布局和页面绘制都是运行在浏览器的主线程当中，他们之间是互斥的关系。</li><li>React加载或者更新时，会调用生命周期函数，计算和对比Virtual DOM，更新UI，整个过程是同步的，如果需要更新的组件数量过大或者计算过于复杂，就会出现用户卡顿的体验。</li></ul></li><li><p>React是如何解决上述问题的？</p><p><strong> 引入了异步渲染(Async Rendering)机制 </strong></p><p>采用分片的思路，提出了Fiber的解决方案。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; React16更新的根本原因是提升用户体验，解决同步更新带来的界面卡顿问题。 &lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;React16之前的版本中，更新过程是同步的，为什么会导致界面卡顿？&lt;br&gt;&lt;strong&gt; 大量的同步计算任务阻塞了浏览器的
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="React" scheme="http://hi2048.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>快乐数</title>
    <link href="http://hi2048.github.io/2018/12/08/%E5%BF%AB%E4%B9%90%E6%95%B0/"/>
    <id>http://hi2048.github.io/2018/12/08/快乐数/</id>
    <published>2018-12-07T16:00:00.000Z</published>
    <updated>2019-09-08T13:53:44.932Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>快乐数：<br>正整数，求出每个位置的数字平方和，重复此过程，可以得到数字1，则为快乐数。<br>求取平方和过程中如果重复之前的平方和，则非快乐数。</p><pre><code>var getSquaresSum = function(n){    var ss = n.toString().split(&apos;&apos;);    return ss.reduce(function(count, s){        return count + Math.pow(parseInt(s), 2);    }, 0)}var isHappy = function(n) {    var rets = [n];    var count = n;    while(true){        count = getSquaresSum(count);        if(count === 1){            return true;        }        var index = rets.indexOf(count);        if(index !== -1){            return false;        }        rets.push(count);    }};</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;快乐数：&lt;br&gt;正整数，求出每个位置的数字平方和，重复此过程，可以得到数字1，则为快乐数。&lt;br&gt;求取平方和过程中如果重复之前的平方和，则非快乐数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var getSquaresSum = function(n){
    v
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>React生命周期</title>
    <link href="http://hi2048.github.io/2018/12/02/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://hi2048.github.io/2018/12/02/React生命周期/</id>
    <published>2018-12-01T16:00:00.000Z</published>
    <updated>2019-09-11T08:42:28.187Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>React生命周期 - React16前</p><p><strong> React生命周期总体上分为4个阶段：初始化阶段（initialization），挂载阶段（Mounting），更新阶段（update），卸载阶段（Unmount） </strong></p><ul><li><p>initialization：初始化props和state。<br>constructor</p></li><li><p>mounting：执行一次。<br>componentWillMount, render, componentDidMount</p></li><li><p>update：setState引起的state更新或者父组件重新render引起的props更新。<br>componentWillReceiveProps, shouldComponentUpdate, componentWillUpdate, render, componentDidUpdate</p></li><li><p>unmount: 执行一次<br>componentWillUnmount</p></li></ul><p><a href="/assets/React-lifecycle-before.png"><img src="/assets/React-lifecycle-before.png" alt="React生命周期"></a></p></li></ol><ol start="2"><li><p>React生命周期</p><ul><li>引入了两个新的生命周期函数<br>getDerivedStateFromProps，getSnapshotBeforeUpdate</li></ul><p><a href="/assets/React-lifecycle.png"><img src="/assets/React-lifecycle.png" alt="React16生命周期"></a></p></li><li><p>为什么会变化</p><p><strong> React16推出Fiber，如果开启async rendering，会导致render函数之前的所有函数，有可能被执行多次。 </strong></p><ul><li>componentWillMount</li><li>componentWillReceiveProps</li><li>componentWillUpdate</li><li>shouldComponentUpdate</li></ul><p>其中shouldComponentUpdate为纯函数，返回Boolean，没有副作用，而其他三个函数，开发者如果在里面执行有副作用的操作，如Ajax等，会产生不可预期的结果。所以其余三个统一被getDerivedStateFromProps替代，并且<strong> 采用静态函数，用禁止来替代以前的建议 </strong>。</p><p>react的component中static属性，里面放函数，官方解释：<br><strong> you can run them before any component instances are created, and the methods do not have access to the props or state of your components. </strong></p><p><strong> 静态函数getDerivedStateFromProps来取代被deprecate的几个生命周期函数，就是强制开发者在render之前只做无副作用的操作，而且能做的操作局限在根据props和state决定新的state。 </strong></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;React生命周期 - React16前&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; React生命周期总体上分为4个阶段：初始化阶段（initialization），挂载阶段（Mounting），更新阶段（update），卸载阶段（Unmount） &lt;/strong
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="React" scheme="http://hi2048.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React之setState</title>
    <link href="http://hi2048.github.io/2018/10/11/React%E4%B9%8BsetState/"/>
    <id>http://hi2048.github.io/2018/10/11/React之setState/</id>
    <published>2018-10-10T16:00:00.000Z</published>
    <updated>2019-09-11T12:14:16.446Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>setState是异步还是同步</p><ul><li>合成事件（react自定义的事件，如在组件中的onClick等）和生命周期函数中是“异步”的。这里的异步并非是真正的异步实现，其本身还是属于同步操作，只是采用了批处理机制。</li><li><p>原生事件（DOM中的原生事件，如通过addEventListener添加的等）和 setTimeout 中都是同步的</p><p>   setState(updater[, callback])</p><p>   updater可以是一个函数或者一个对象。<br>   如果是对象，则执行对象跟state的浅合并。<br>   如果传入一个函数，则会把函数的返回对象跟state进行浅合并。这个函数会传入两个参数state和props，返回一个对象<br>   (state, props) =&gt; stateChange</p><p>   第二个参数，state更新完毕之后调用的回调函数。如果有需要在state更新之后的操作，可以放在这里。不过官方更建议在componentDidUpdate里面处理更新之后的操作。</p></li></ul></li><li><p>使用注意事项</p><ul><li>不要直接修改state</li><li>setState不能保证是同步的</li><li>setState造成不必要的渲染</li></ul></li><li><p>setState的优化</p><ul><li>声名变量能用const就不要用let</li><li>减少setState的调用次数，如可以一次set多个值，不要一个一个set。</li><li>多利用shouldComponentUpdate</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;setState是异步还是同步&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;合成事件（react自定义的事件，如在组件中的onClick等）和生命周期函数中是“异步”的。这里的异步并非是真正的异步实现，其本身还是属于同步操作，只是采用了批处理机制。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="React" scheme="http://hi2048.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>秋</title>
    <link href="http://hi2048.github.io/2018/10/05/%E7%A7%8B/"/>
    <id>http://hi2048.github.io/2018/10/05/秋/</id>
    <published>2018-10-04T16:00:00.000Z</published>
    <updated>2019-09-05T14:51:31.779Z</updated>
    
    <content type="html"><![CDATA[<p>秋风送爽，炎暑渐消，此时宜甘味以益气，进补应坚持“燥者濡之”，“上燥清气，中燥增液，下燥养血。”同时应早睡早起，早餐宜营养丰富，以预防抑郁症，保持乐观轻松心情。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;秋风送爽，炎暑渐消，此时宜甘味以益气，进补应坚持“燥者濡之”，“上燥清气，中燥增液，下燥养血。”同时应早睡早起，早餐宜营养丰富，以预防抑郁症，保持乐观轻松心情。&lt;/p&gt;

      
    
    </summary>
    
      <category term="未分类" scheme="http://hi2048.github.io/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>Swagger</title>
    <link href="http://hi2048.github.io/2018/09/12/Swagger/"/>
    <id>http://hi2048.github.io/2018/09/12/Swagger/</id>
    <published>2018-09-11T16:00:00.000Z</published>
    <updated>2019-09-06T06:24:46.889Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>Swagger解决了什么问题？<br><strong> 接口文档的一致性与可维护性 </strong></p></li><li><p>Swagger是什么？</p><ul><li>通过自己定义的描述文件（yml或json格式），更新接口文档，以及生成各端代码.</li></ul></li><li><p>Swagger可以做什么？</p><ul><li>可以做到生成各种格式的接口文档，生成多种语言的客户端和服务端的代码，以及在线接口调试页面等等。</li></ul></li><li><p>Springfox-swagger</p><ul><li>通过扫描代码去生成这个描述文件</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;Swagger解决了什么问题？&lt;br&gt;&lt;strong&gt; 接口文档的一致性与可维护性 &lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swagger是什么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过自己定义的描述文件（yml或json格式），更新接口文档，以及生
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="Spring" scheme="http://hi2048.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Fiber</title>
    <link href="http://hi2048.github.io/2018/06/11/Fiber/"/>
    <id>http://hi2048.github.io/2018/06/11/Fiber/</id>
    <published>2018-06-10T16:00:00.000Z</published>
    <updated>2019-09-11T10:00:46.794Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>什么是Fiber<br><strong> React Fibler 采用分片的思路实现UI的异步渲染。 </strong><br>React Fiber把更新过程碎片化，分成很多小片，当分配给小片的时间用尽时，则将控制权交出，如果有优先级更高的任务，就开始做新的任务，没有就断续原来的更新。</p></li><li><p>Fiber运行原理<br><strong> React Fiber一个更新过程被分为两个阶段(Phase)：第一个阶段Reconciliation Phase和第二阶段Commit Phase。 </strong></p><ul><li><p>Reconciliation Phase， 可以被打断，计算与对比虚拟DOM，找出需要更新的DOM<br>componentWillMount<br>componentWillReceiveProps<br>shouldComponentUpdate<br>componentWillUpdate</p></li><li><p>Commit Phase， 无法打断，更新DOM<br>componentDidMount<br>componentDidUpdate<br>componentWillUnmount</p></li></ul></li></ol><ol start="3"><li><p>React16前的生命周期函数componentWillUpdate等，为什么会多次执行？</p><ul><li>requestIdleCallback</li><li>cancelIdleCallback</li></ul><p><strong> 异步渲染的时候，会调用requestIdleCallback API，在回调函数中可以获得当前callback参数（也就是fiber的分片任务），包括执行时间，如果时间不够，分片任务会被打断（使用cancelIdleCallback API），再次执行则会在空闲时重新执行。 </strong></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;什么是Fiber&lt;br&gt;&lt;strong&gt; React Fibler 采用分片的思路实现UI的异步渲染。 &lt;/strong&gt;&lt;br&gt;React Fiber把更新过程碎片化，分成很多小片，当分配给小片的时间用尽时，则将控制权交出，如果有优先级更高的任务，就开始
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="React" scheme="http://hi2048.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React高阶组件</title>
    <link href="http://hi2048.github.io/2018/06/10/React%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/"/>
    <id>http://hi2048.github.io/2018/06/10/React高阶组件/</id>
    <published>2018-06-09T16:00:00.000Z</published>
    <updated>2019-09-18T13:09:21.246Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>高阶组件：higher order Component，装饰器模式</p><p> 基本形式：const EnhancedComponent = higherOrderComponent(WrappedComponent);</p></li><li><p>高阶组件两种常见用法：</p><ul><li><p>属性代理 Props Proxy: 通过WrappedComponent的Props来进行操作</p><pre><code>function hocPropsProxy(WrappedComponent) {  return class hocComponent extends React.Component {    constructor(){      super(props);      this.state = {        name: &apos;&apos;      }    }    render() {      const props = {        name: this.state.name      }      return (          &lt;div className=&quot;layout&quot;&gt;            &lt;WrappedComponent {...this.props} {...props} /&gt;          &lt;/div&gt;        )    }  }}</code></pre></li><li><p>继承反转 Inheritance Inversion：继承自WrappedComponent</p><pre><code>function hocInheritanceInversion(WrappedComponent){  return class hocComponent extends WrappedComponent {    render() {      // 可以实现渲染劫持，实现Loading等功能      return super.render();    }  }}</code></pre></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;高阶组件：higher order Component，装饰器模式&lt;/p&gt;
&lt;p&gt; 基本形式：const EnhancedComponent = higherOrderComponent(WrappedComponent);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="React" scheme="http://hi2048.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React组件</title>
    <link href="http://hi2048.github.io/2018/05/15/React%E7%BB%84%E4%BB%B6/"/>
    <id>http://hi2048.github.io/2018/05/15/React组件/</id>
    <published>2018-05-14T16:00:00.000Z</published>
    <updated>2019-09-16T07:20:38.604Z</updated>
    
    <content type="html"><![CDATA[<ol><li>无状态组件：采用函数式定义<br><strong> 不含状态管理 </strong><ul><li>不包含任何状态，但可以包含属性，同样的props会得到同样的渲染结果，不会有副作用；</li><li>无状态组件生成时不会实例化，整体渲染性能得到提升；</li><li>无状态组件没有this，ref和生命周期；<pre><code>function Welcome(props){  return (&lt;h1&gt;Hello, {props.name}&lt;/h1&gt;);}</code></pre></li></ul></li></ol><ol start="2"><li><p>有状态组件：采用ES6 Component形式定义<br><strong> 实例化的，并且可以访问组件的生命周期方法 </strong></p><pre><code>class Welcome extends React.Component{  constructor(props){    super(props);    this.state = {      iShow: true    }  }  render(){    return (        this.state.iShow?(&lt;h1&gt; Hello, {this.props.name} &lt;/h1&gt;) : null      )  }}</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;无状态组件：采用函数式定义&lt;br&gt;&lt;strong&gt; 不含状态管理 &lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;不包含任何状态，但可以包含属性，同样的props会得到同样的渲染结果，不会有副作用；&lt;/li&gt;
&lt;li&gt;无状态组件生成时不会实例化，整体渲染性能得到提升；&lt;/l
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="React" scheme="http://hi2048.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>同构字符串</title>
    <link href="http://hi2048.github.io/2018/05/09/%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://hi2048.github.io/2018/05/09/同构字符串/</id>
    <published>2018-05-08T16:00:00.000Z</published>
    <updated>2019-09-09T14:36:53.724Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>判断两个长度相同的字符串是否是同构字符串。同构字符串为将一个字符串中的相同字符进行替换可以得到另一个字符串。<br><strong> 同构代表两个字符串中每个位置上字符在自身第一次出现的索引相同 </strong></p><pre><code>var isPositionSame = function(ss, ts, index){    var sIndex = ss.indexOf(ss[index]);    var tIndex = ts.indexOf(ts[index]);    return sIndex === tIndex;}var isIsomorphic = function(s, t) {    var ss = s.split(&apos;&apos;);    var ts = t.split(&apos;&apos;);    for(var i = 0, len = ts.length; i &lt; len; i++){        if(!isPositionSame(ss, ts, i)){            return false;        }    }    return true;};</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;判断两个长度相同的字符串是否是同构字符串。同构字符串为将一个字符串中的相同字符进行替换可以得到另一个字符串。&lt;br&gt;&lt;strong&gt; 同构代表两个字符串中每个位置上字符在自身第一次出现的索引相同 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var i
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>React通信</title>
    <link href="http://hi2048.github.io/2018/01/12/React%E9%80%9A%E4%BF%A1/"/>
    <id>http://hi2048.github.io/2018/01/12/React通信/</id>
    <published>2018-01-11T16:00:00.000Z</published>
    <updated>2019-09-18T13:35:13.015Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>父组件向子组件通信: props</p></li><li><p>子组件向父组件通信: 回调函数</p></li><li><p>跨级组件通信: context</p></li><li><p>非嵌套组件间通信: 自定义事件（发布-订阅模式或者观察者模式）emit</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;父组件向子组件通信: props&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;子组件向父组件通信: 回调函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;跨级组件通信: context&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;非嵌套组件间通信: 自定义事件（发布-订阅模式或者观察者
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="React" scheme="http://hi2048.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>twoSum</title>
    <link href="http://hi2048.github.io/2018/01/11/twoSum/"/>
    <id>http://hi2048.github.io/2018/01/11/twoSum/</id>
    <published>2018-01-10T16:00:00.000Z</published>
    <updated>2019-09-10T16:00:16.268Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 求数组中两个数值之和为指定值的下标，可以采用hash来解决 </strong></p><pre><code>const twoSum = (nums, target) =&gt; {  let hash = {};  for(let i = 0, len = nums.length; i &lt; len; i++){    if(typeof hash[target - nums[i]] !== &apos;undefined&apos;){      return [hash[target - nums[i]], i];    }    hash[nums[i]] = i;  }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 求数组中两个数值之和为指定值的下标，可以采用hash来解决 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const twoSum = (nums, target) =&amp;gt; {
  let hash = {};
  for(let i = 0, l
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
