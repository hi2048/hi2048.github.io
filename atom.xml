<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>苏小蜂的个人博客</title>
  
  <subtitle>放慢脚步，享受生活！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hi2048.github.io/"/>
  <updated>2019-09-05T14:59:46.811Z</updated>
  <id>http://hi2048.github.io/</id>
  
  <author>
    <name>Jsu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>状态管理</title>
    <link href="http://hi2048.github.io/2019/09/02/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    <id>http://hi2048.github.io/2019/09/02/状态管理/</id>
    <published>2019-09-01T16:00:00.000Z</published>
    <updated>2019-09-05T14:59:46.811Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>vuex</p><ul><li>vuex 是一个专门为vue.js应用程序开发的状态管理模式。</li></ul></li><li><p>状态自管理应用</p><ul><li>state, view, actions<br><a href="/assets/vue-flow.png"><img src="/assets/vue-flow.png" alt="vue-flow"></a></li></ul></li><li><p>vuex应用</p><p><a href="/assets/vuex.png"><img src="/assets/vuex.png" alt="vuex"></a></p></li><li><p>为什么引入状态管理模式</p><ul><li>多个视图依赖于同一状态。</li><li>来自不同视图的行为需要变更同一状态。</li></ul><p><strong> 传统的vue在解决上述问题时，会导致代码复杂与难于维护，vuex采用全局单例模式管理，可以使得代码更结构化且易维护。 </strong></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;vuex&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vuex 是一个专门为vue.js应用程序开发的状态管理模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;状态自管理应用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;state, view, actions&lt;br&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="React" scheme="http://hi2048.github.io/tags/React/"/>
    
      <category term="vue" scheme="http://hi2048.github.io/tags/vue/"/>
    
      <category term="vuex" scheme="http://hi2048.github.io/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>Vue生命周期</title>
    <link href="http://hi2048.github.io/2019/08/02/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://hi2048.github.io/2019/08/02/Vue生命周期/</id>
    <published>2019-08-01T16:00:00.000Z</published>
    <updated>2019-09-05T14:58:52.372Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>Vue实例有一个完整的生命周期，也就是说从开始创建、初始化数据、编译模板、挂在DOM、渲染-更新-渲染、卸载等一系列过程，我们成为Vue 实例的生命周期，钩子就是在某个阶段给你一个做某些处理的机会。</p></li><li><p>Vue生命周期钩子</p><ul><li>beforeCreate</li><li>created</li><li>beforeMount</li><li>mounted</li><li>beforeUpdate</li><li>updated</li><li>beforeDestroy</li><li>destroyed</li></ul></li></ol><p><a href="/assets/lifecycle-vue.png"><img src="/assets/lifecycle-vue.png" alt="vue-生命周期"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;Vue实例有一个完整的生命周期，也就是说从开始创建、初始化数据、编译模板、挂在DOM、渲染-更新-渲染、卸载等一系列过程，我们成为Vue 实例的生命周期，钩子就是在某个阶段给你一个做某些处理的机会。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Vue生命周期钩子&lt;/
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="vue" scheme="http://hi2048.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>compose</title>
    <link href="http://hi2048.github.io/2019/06/10/compose/"/>
    <id>http://hi2048.github.io/2019/06/10/compose/</id>
    <published>2019-06-09T16:00:00.000Z</published>
    <updated>2019-09-10T15:47:32.356Z</updated>
    
    <content type="html"><![CDATA[<p><strong> JavaScript函数式编程：compose方法 </strong></p><pre><code>const compose = (arr) =&gt; {    return arr.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))}const composeT = (arr) =&gt; {  return arr.reduce((a, b) =&gt; {    return (...args) =&gt; {      console.log(`${a.name}(${b.name}(${args}))`);      return a(b(...args));    }  }, ()=&gt;{})}const a = (a, b) =&gt; {console.log(&quot;a: &quot;, a); return a;}const b = (a, b) =&gt; {console.log(&quot;b: &quot;, a); return a;}const c = (a, b) =&gt; {console.log(&quot;c: &quot;, a, b); return [a, b];}composeT([a,b,c])(&apos;1&apos;,&apos;2&apos;)(c(1,2))c:  1 2(b(1,2))b:  [ &apos;1&apos;, &apos;2&apos; ](a(1,2))a:  [ &apos;1&apos;, &apos;2&apos; ]</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; JavaScript函数式编程：compose方法 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const compose = (arr) =&amp;gt; {
    return arr.reduce((a, b) =&amp;gt; (...args) =&amp;
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>闭包</title>
    <link href="http://hi2048.github.io/2019/06/08/%E9%97%AD%E5%8C%85/"/>
    <id>http://hi2048.github.io/2019/06/08/闭包/</id>
    <published>2019-06-07T16:00:00.000Z</published>
    <updated>2019-09-05T15:00:17.012Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>闭包概念</p><ul><li>能够读取其他函数内部变量的函数。</li><li><p>或简单理解为定义在一个函数内部的函数，内部函数持有外部函数内变量的引用。</p><pre><code>function outFunc(){  var outAttr = &quot;outAttr&quot;;  function innerFunc(){    console.log(outAttr);  }  return innerFunc;}var myFunc = outFunc(); // myFunc为一个引入outAttr的闭包</code></pre></li></ul></li><li><p>为什么有闭包</p><ul><li>避免污染全局变量</li><li>利于代码的封装</li><li>使用时注意内在泄露</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;闭包概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能够读取其他函数内部变量的函数。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;或简单理解为定义在一个函数内部的函数，内部函数持有外部函数内变量的引用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function outFunc(){
  var out
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript类与继承</title>
    <link href="http://hi2048.github.io/2019/05/05/JavaScript%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF/"/>
    <id>http://hi2048.github.io/2019/05/05/JavaScript类与继承/</id>
    <published>2019-05-04T16:00:00.000Z</published>
    <updated>2019-09-05T15:00:02.295Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>定义类</p><pre><code>//定义属性function MyClass(attr1, attr2) {  this.attr1 = attr1;  this.attr2 = attr2;}//定义方法MyClass.prototype = {  constructor : MyClass,  myFunc : function() {      console.log(this.attr1);  }};</code></pre></li><li><p>继承类</p><pre><code>//定义父类function SuperClass(attr) {    this.attr = attr;}SuperClass.prototype = {    superFunc : function() {        console.log(this.attr);    }};//继承父类function SubClass(attr, subAttr) {    //继承属性    SuperClass.call(this, attr);    this.subAttr = subAttr;}//继承方法SubClass.prototype = new SuperClass();</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;定义类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//定义属性
function MyClass(attr1, attr2) {
  this.attr1 = attr1;
  this.attr2 = attr2;
}

//定义方法
MyClass.prototy
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>判断素数</title>
    <link href="http://hi2048.github.io/2019/02/01/%E5%88%A4%E6%96%AD%E7%B4%A0%E6%95%B0/"/>
    <id>http://hi2048.github.io/2019/02/01/判断素数/</id>
    <published>2019-02-01T00:00:00.000Z</published>
    <updated>2019-09-06T14:16:59.316Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>判断素数</p><pre><code>function isPrimeN(n) {  if(n == 0 || n==1){      return false;  }  if(n==2){      return true;  }  for(var i = 2; i &lt;= Math.sqrt(n); i++){      if(n % i == 0){          return false;      }  }  return true;}</code></pre></li><li><p>http和https的区别</p><ul><li>https 需要ca证书</li><li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li><li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;判断素数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function isPrimeN(n) {
  if(n == 0 || n==1){
      return false;
  }

  if(n==2){
      return true;
  }

  
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>快乐数</title>
    <link href="http://hi2048.github.io/2018/12/08/%E5%BF%AB%E4%B9%90%E6%95%B0/"/>
    <id>http://hi2048.github.io/2018/12/08/快乐数/</id>
    <published>2018-12-07T16:00:00.000Z</published>
    <updated>2019-09-08T13:53:44.932Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>快乐数：<br>正整数，求出每个位置的数字平方和，重复此过程，可以得到数字1，则为快乐数。<br>求取平方和过程中如果重复之前的平方和，则非快乐数。</p><pre><code>var getSquaresSum = function(n){    var ss = n.toString().split(&apos;&apos;);    return ss.reduce(function(count, s){        return count + Math.pow(parseInt(s), 2);    }, 0)}var isHappy = function(n) {    var rets = [n];    var count = n;    while(true){        count = getSquaresSum(count);        if(count === 1){            return true;        }        var index = rets.indexOf(count);        if(index !== -1){            return false;        }        rets.push(count);    }};</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;快乐数：&lt;br&gt;正整数，求出每个位置的数字平方和，重复此过程，可以得到数字1，则为快乐数。&lt;br&gt;求取平方和过程中如果重复之前的平方和，则非快乐数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var getSquaresSum = function(n){
    v
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>秋</title>
    <link href="http://hi2048.github.io/2018/10/05/%E7%A7%8B/"/>
    <id>http://hi2048.github.io/2018/10/05/秋/</id>
    <published>2018-10-04T16:00:00.000Z</published>
    <updated>2019-09-05T14:51:31.779Z</updated>
    
    <content type="html"><![CDATA[<p>秋风送爽，炎暑渐消，此时宜甘味以益气，进补应坚持“燥者濡之”，“上燥清气，中燥增液，下燥养血。”同时应早睡早起，早餐宜营养丰富，以预防抑郁症，保持乐观轻松心情。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;秋风送爽，炎暑渐消，此时宜甘味以益气，进补应坚持“燥者濡之”，“上燥清气，中燥增液，下燥养血。”同时应早睡早起，早餐宜营养丰富，以预防抑郁症，保持乐观轻松心情。&lt;/p&gt;

      
    
    </summary>
    
      <category term="未分类" scheme="http://hi2048.github.io/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>Swagger</title>
    <link href="http://hi2048.github.io/2018/09/12/Swagger/"/>
    <id>http://hi2048.github.io/2018/09/12/Swagger/</id>
    <published>2018-09-11T16:00:00.000Z</published>
    <updated>2019-09-06T06:24:46.889Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>Swagger解决了什么问题？<br><strong> 接口文档的一致性与可维护性 </strong></p></li><li><p>Swagger是什么？</p><ul><li>通过自己定义的描述文件（yml或json格式），更新接口文档，以及生成各端代码.</li></ul></li><li><p>Swagger可以做什么？</p><ul><li>可以做到生成各种格式的接口文档，生成多种语言的客户端和服务端的代码，以及在线接口调试页面等等。</li></ul></li><li><p>Springfox-swagger</p><ul><li>通过扫描代码去生成这个描述文件</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;Swagger解决了什么问题？&lt;br&gt;&lt;strong&gt; 接口文档的一致性与可维护性 &lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swagger是什么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过自己定义的描述文件（yml或json格式），更新接口文档，以及生
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="Spring" scheme="http://hi2048.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>同构字符串</title>
    <link href="http://hi2048.github.io/2018/05/09/%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://hi2048.github.io/2018/05/09/同构字符串/</id>
    <published>2018-05-08T16:00:00.000Z</published>
    <updated>2019-09-09T14:36:53.724Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>判断两个长度相同的字符串是否是同构字符串。同构字符串为将一个字符串中的相同字符进行替换可以得到另一个字符串。<br><strong> 同构代表两个字符串中每个位置上字符在自身第一次出现的索引相同 </strong></p><pre><code>var isPositionSame = function(ss, ts, index){    var sIndex = ss.indexOf(ss[index]);    var tIndex = ts.indexOf(ts[index]);    return sIndex === tIndex;}var isIsomorphic = function(s, t) {    var ss = s.split(&apos;&apos;);    var ts = t.split(&apos;&apos;);    for(var i = 0, len = ts.length; i &lt; len; i++){        if(!isPositionSame(ss, ts, i)){            return false;        }    }    return true;};</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;判断两个长度相同的字符串是否是同构字符串。同构字符串为将一个字符串中的相同字符进行替换可以得到另一个字符串。&lt;br&gt;&lt;strong&gt; 同构代表两个字符串中每个位置上字符在自身第一次出现的索引相同 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var i
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>twoSum</title>
    <link href="http://hi2048.github.io/2018/01/11/twoSum/"/>
    <id>http://hi2048.github.io/2018/01/11/twoSum/</id>
    <published>2018-01-10T16:00:00.000Z</published>
    <updated>2019-09-10T16:00:16.268Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 求数组中两个数值之和为指定值的下标，可以采用hash来解决 </strong></p><pre><code>const twoSum = (nums, target) =&gt; {  let hash = {};  for(let i = 0, len = nums.length; i &lt; len; i++){    if(typeof hash[target - nums[i]] !== &apos;undefined&apos;){      return [hash[target - nums[i]], i];    }    hash[nums[i]] = i;  }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 求数组中两个数值之和为指定值的下标，可以采用hash来解决 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const twoSum = (nums, target) =&amp;gt; {
  let hash = {};
  for(let i = 0, l
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>arrayTwoSum</title>
    <link href="http://hi2048.github.io/2018/01/10/arrayTwoSum/"/>
    <id>http://hi2048.github.io/2018/01/10/arrayTwoSum/</id>
    <published>2018-01-09T16:00:00.000Z</published>
    <updated>2019-09-10T15:52:00.476Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 求数组下标，下标区间数值之和为指定值 </strong></p><pre><code>const twoSum = (nums, target) =&gt;{    let count = 0;    for(let i = 0, len = nums.length; i &lt; len;){        count = nums[i];        if(count &gt; target){            i++        } else if(count === target){            return [i, i];        } else{          for(let j = i + 1; j &lt; len; j++){              count += nums[j];              if(count &gt; target){                  i++;                  break;              } else if(count === target){                  return [i, j];              }          }        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 求数组下标，下标区间数值之和为指定值 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const twoSum = (nums, target) =&amp;gt;{
    let count = 0;

    for(let i = 0, len = nu
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>移除链表元素</title>
    <link href="http://hi2048.github.io/2017/12/10/%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
    <id>http://hi2048.github.io/2017/12/10/移除链表元素/</id>
    <published>2017-12-09T16:00:00.000Z</published>
    <updated>2019-09-09T03:41:44.275Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>删除单向链表中值为 val 的所有节点。</p><p><strong>思路：可以添加指向头结节的Head*节点，然后进行删除操作。</strong></p><pre><code>function removeLinkNodes(head, val) {  if(!head) return null;  var prevElement = {    this.next = head;  }  var sPointer = prevElement;  while(sPointer.next){    if(sPointer.next.val === val){      sPointer.next = sPointer.next.next;    } else{      sPointer = sPointer.next;    }  }  return prevElement.next;};</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;删除单向链表中值为 val 的所有节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路：可以添加指向头结节的Head*节点，然后进行删除操作。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function removeLinkNodes(head, val) {
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的循环中断</title>
    <link href="http://hi2048.github.io/2017/11/10/JavaScript%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%B8%AD%E6%96%AD/"/>
    <id>http://hi2048.github.io/2017/11/10/JavaScript中的循环中断/</id>
    <published>2017-11-09T16:00:00.000Z</published>
    <updated>2019-09-10T15:25:41.717Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 循环中断break, continue, return 比较 </strong></p><pre><code>// break continue return// break跳出当前循环 continue结束当前条件 return 返回函数值console.log(&quot;normal: &quot;)for(var i = 0; i &lt; 2; i++){  console.log(`${i} `);  for(var j = 3; j &lt; 6; j++){    console.log(`${j} `);  }}console.log(&quot;break: &quot;)for(var i = 0; i &lt; 2; i++){  console.log(`${i} `);  for(var j = 3; j &lt; 6; j++){    if(j === 4) break;    console.log(`${j} `);  }}console.log(&quot;continue: &quot;)for(var i = 0; i &lt; 2; i++){  console.log(`${i} `);  for(var j = 3; j &lt; 6; j++){    if(j === 4) continue;    console.log(`${j} `);  }}console.log(&quot;return: &quot;)for(var i = 0; i &lt; 2; i++){  console.log(`${i} `);  for(var j = 3; j &lt; 6; j++){    if(j === 4){      return;    }    console.log(`${j} `);  }}normal:03451345 break:0313continue:035135return:03</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 循环中断break, continue, return 比较 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// break continue return
// break跳出当前循环 continue结束当前条件 return 返回函数值
cons
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>js笔记</title>
    <link href="http://hi2048.github.io/2017/09/01/js%E7%AC%94%E8%AE%B0/"/>
    <id>http://hi2048.github.io/2017/09/01/js笔记/</id>
    <published>2017-09-01T00:00:00.000Z</published>
    <updated>2019-09-05T15:00:49.612Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>JS基本数据类型：Number、String 、Boolean 、Null、Undefined</p></li><li><p>null，undefined的区别？</p><ul><li><p>null表示一个对象被定义了，但存放了空指针，转换为数值时为0。</p></li><li><p>undefined表示声明的变量未初始化，转换为数值时为NAN。</p><p>typeof(null) – object;<br>typeof(undefined) – undefined</p></li></ul></li><li><p>同源<br> 要同时满足以下3个条件，才能叫同源：</p><p> 协议相同<br> 端口相同<br> 主机相同</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;JS基本数据类型：Number、String 、Boolean 、Null、Undefined&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;null，undefined的区别？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;null表示一个对象被定义了，但存放了空指针，转换为数值
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CD数量</title>
    <link href="http://hi2048.github.io/2017/05/10/CD%E6%95%B0%E9%87%8F/"/>
    <id>http://hi2048.github.io/2017/05/10/CD数量/</id>
    <published>2017-05-09T16:00:00.000Z</published>
    <updated>2019-09-10T15:35:24.506Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 你作为一名出道的歌手终于要出自己的第一份专辑了，你计划收录 n 首歌而且每首歌的长度都是 s 秒，每首歌必须完整地收录于一张 CD 当中。每张 CD 的容量长度都是 L 秒，而且你至少得保证同一张 CD 内相邻两首歌中间至少要隔 1 秒。为了辟邪，你决定任意一张 CD 内的歌数不能被 13 这个数字整除，那么请问你出这张专辑至少需要多少张 CD ？</strong></p><p><strong> 需要考虑剩余为13倍数的情况，每张歌曲数量可以通过计算得来。 </strong></p><pre><code>function getCDCount(n, s, l){  //计算每张CD歌曲数量  var countPerCD = Math.floor((l + 1) / (s + 1));  countPerCD = countPerCD &gt; n?n : countPerCD;  if(countPerCD % 13 === 0){      countPerCD --;  }  var count = n / countPerCD;  count = Math.ceil(count);  //最后剩余数量为13的倍数且比每张少1，则总CD需要+1  var leftCount = n % countPerCD;  if(leftCount !== 0 &amp;&amp; leftCount % 13 === 0 &amp;&amp; leftCount === countPerCD - 1){      count ++;  }  console.log(count);  return count;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 你作为一名出道的歌手终于要出自己的第一份专辑了，你计划收录 n 首歌而且每首歌的长度都是 s 秒，每首歌必须完整地收录于一张 CD 当中。每张 CD 的容量长度都是 L 秒，而且你至少得保证同一张 CD 内相邻两首歌中间至少要隔 1 秒。为了辟邪，你决定任
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>reduce方法</title>
    <link href="http://hi2048.github.io/2017/01/10/reduce%E6%96%B9%E6%B3%95/"/>
    <id>http://hi2048.github.io/2017/01/10/reduce方法/</id>
    <published>2017-01-09T16:00:00.000Z</published>
    <updated>2019-09-10T15:41:06.816Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 数组reduce方法 </strong></p><pre><code>// reduce a,b传入初始值则 b为数组第1个值，否则a为第1个，b为第2个，第二次运行则a为上一次的数据，b为第3个值//array.reduce(function(total, currentValue, currentIndex, arr), initialValue)[1,2,3,4,5].reduce(function(a,b){  console.log(`${a}:${b}:${a + b}`)  return a+b;}, 0);// 0:1:1// 1:2:3// 3:3:6// 6:4:10// 10:5:15[1,2,3,4,5].reduce(function(a,b){  console.log(`${a}:${b}:${a + b}`)  return a+b;});// 1:2:3// 3:3:6// 6:4:10// 10:5:15</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 数组reduce方法 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// reduce a,b传入初始值则 b为数组第1个值，否则a为第1个，b为第2个，第二次运行则a为上一次的数据，b为第3个值
//array.reduce(function(tot
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>那年真的如风</title>
    <link href="http://hi2048.github.io/2016/05/18/%E9%82%A3%E5%B9%B4%E7%9C%9F%E7%9A%84%E5%A6%82%E9%A3%8E/"/>
    <id>http://hi2048.github.io/2016/05/18/那年真的如风/</id>
    <published>2016-05-18T11:46:27.000Z</published>
    <updated>2019-08-28T14:39:04.087Z</updated>
    
    <content type="html"><![CDATA[<p>太多太多的事情，让我们分心，时间久了，慢慢地不记得了当初年少时的梦。</p><p>两年时间说长不长，说短也不短，经历了好多，却发现最不能忘却的还是曾经的自己，好想时光重回到2年前的那个傍晚，夕阳洒在脸膀。</p><p>这一次我想更加细细的走过。</p><p>&nbsp;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;太多太多的事情，让我们分心，时间久了，慢慢地不记得了当初年少时的梦。&lt;/p&gt;
&lt;p&gt;两年时间说长不长，说短也不短，经历了好多，却发现最不能忘却的还是曾经的自己，好想时光重回到2年前的那个傍晚，夕阳洒在脸膀。&lt;/p&gt;
&lt;p&gt;这一次我想更加细细的走过。&lt;/p&gt;
&lt;p&gt;&amp;nbsp
      
    
    </summary>
    
      <category term="杂谈" scheme="http://hi2048.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>工作之感悟</title>
    <link href="http://hi2048.github.io/2015/11/10/%E5%B7%A5%E4%BD%9C%E4%B9%8B%E6%84%9F%E6%82%9F/"/>
    <id>http://hi2048.github.io/2015/11/10/工作之感悟/</id>
    <published>2015-11-09T16:00:00.000Z</published>
    <updated>2019-09-05T13:41:19.043Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉间，已经工作1年多了，从开春的3月，如今却已快入冬，时间就在你不经意间，悄悄划过，不留一丝的痕迹。</p><p>每天都在忙碌，每天都在重复，每天都在感叹时间太少，可是却也不曾做成什么不一样的事情。</p><p>从最初的最简单的JS函数写起，再到应用面向对象，再到后来的模块化编程，了解了函数式编程，再到AngularJS。研究了JS内存泄漏问题，特别喜欢HTML5与CSS3做出来的动画，喜欢Google的material design，做出了各种圆周运动的效果。如今却不知道前途如何，以后应该做些什么，在技术的道路一直走下去，还是去做点不一样的东西。</p><p>再回过头来看，自己确实是成长了不少。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不知不觉间，已经工作1年多了，从开春的3月，如今却已快入冬，时间就在你不经意间，悄悄划过，不留一丝的痕迹。&lt;/p&gt;
&lt;p&gt;每天都在忙碌，每天都在重复，每天都在感叹时间太少，可是却也不曾做成什么不一样的事情。&lt;/p&gt;
&lt;p&gt;从最初的最简单的JS函数写起，再到应用面向对象，再到
      
    
    </summary>
    
      <category term="杂谈" scheme="http://hi2048.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>定寅时歌诀</title>
    <link href="http://hi2048.github.io/2014/11/13/%E5%AE%9A%E5%AF%85%E6%97%B6%E6%AD%8C%E8%AF%80/"/>
    <id>http://hi2048.github.io/2014/11/13/定寅时歌诀/</id>
    <published>2014-11-13T10:57:34.000Z</published>
    <updated>2016-05-31T16:43:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>正七五更二点徹，</p><p>二八五更四点歇，</p><p>三七平光是寅时，</p><p>四六日出定无别，</p><p>五月日高三太地，</p><p>十月十二四更一，</p><p>仲冬继到四更初，</p><p>此是寅时君须记。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;正七五更二点徹，&lt;/p&gt;
&lt;p&gt;二八五更四点歇，&lt;/p&gt;
&lt;p&gt;三七平光是寅时，&lt;/p&gt;
&lt;p&gt;四六日出定无别，&lt;/p&gt;
&lt;p&gt;五月日高三太地，&lt;/p&gt;
&lt;p&gt;十月十二四更一，&lt;/p&gt;
&lt;p&gt;仲冬继到四更初，&lt;/p&gt;
&lt;p&gt;此是寅时君须记。&lt;/p&gt;

      
    
    </summary>
    
      <category term="周易" scheme="http://hi2048.github.io/categories/%E5%91%A8%E6%98%93/"/>
    
    
  </entry>
  
</feed>
