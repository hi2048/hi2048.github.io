<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>苏小蜂的个人博客</title>
  
  <subtitle>放慢脚步，享受生活！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hi2048.github.io/"/>
  <updated>2020-03-14T19:43:09.987Z</updated>
  <id>http://hi2048.github.io/</id>
  
  <author>
    <name>Jsu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>logger</title>
    <link href="http://hi2048.github.io/2020/03/12/logger/"/>
    <id>http://hi2048.github.io/2020/03/12/logger/</id>
    <published>2020-03-11T16:00:00.000Z</published>
    <updated>2020-03-14T19:43:09.987Z</updated>
    
    <content type="html"><![CDATA[<p>– logger <a href="https://github.com/hi2048/hi2048-utils/tree/master/site/src/utils/log" title="logger" target="_blank" rel="noopener">github</a>  <a href="https://www.npmjs.com/package/hi2048-utils" title="hi2048-utils" target="_blank" rel="noopener">npm</a>  <a href="http://blog.hi2048.com/hi2048-utils/" title="logger" target="_blank" rel="noopener">demo</a></p><pre><code>-- index.jsimport { isFunction, isString } from &apos;../type&apos;;const log = type =&gt; (target, name, descriptor) =&gt; {  if(isFunction(target[name])) {    const originFunction = descriptor.value;    descriptor.value = function(...args) {      console.log(`${target.constructor.name}: `);      console.log(`${type} start: ${name} (${args}).`);      try {        const ret = originFunction.call(this, ...args);        console.log(`${type} succeed: ${name} (${args} =&gt; ${ret}).`);      } catch(err) {        console.log(`${type} failed: ${name} (${args} =&gt; ${err}).`);      }    }  }  return descriptor;}export const logger = (...args) =&gt; {  if(!isString(args[0])) {    return log(&apos;&apos;)(...args);  }  return log(...args);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;– logger &lt;a href=&quot;https://github.com/hi2048/hi2048-utils/tree/master/site/src/utils/log&quot; title=&quot;logger&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gi
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="hi2048" scheme="http://hi2048.github.io/tags/hi2048/"/>
    
      <category term="hi2048-utils" scheme="http://hi2048.github.io/tags/hi2048-utils/"/>
    
  </entry>
  
  <entry>
    <title>creater</title>
    <link href="http://hi2048.github.io/2020/03/10/creater/"/>
    <id>http://hi2048.github.io/2020/03/10/creater/</id>
    <published>2020-03-09T16:00:00.000Z</published>
    <updated>2020-03-14T19:09:24.196Z</updated>
    
    <content type="html"><![CDATA[<p>– creater <a href="https://github.com/hi2048/hi2048-utils/tree/master/site/src/utils/creater" title="creater" target="_blank" rel="noopener">github</a>  <a href="https://www.npmjs.com/package/hi2048-utils" title="hi2048-utils" target="_blank" rel="noopener">npm</a>  <a href="http://blog.hi2048.com/hi2048-utils/" title="creater" target="_blank" rel="noopener">demo</a></p><pre><code>-- index.jsimport { isFunction } from &apos;../type&apos;;export const creater = Target =&gt; config =&gt; class {  constructor(...args) {    if(isFunction(config)) {      return new Target(config, ...args);    }    return new Target(Object.assign(config, ...args));  }};const builder = creater =&gt; array =&gt; array.map(item =&gt; creater(item));export const factory = Target =&gt; builder(creater(Target));</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;– creater &lt;a href=&quot;https://github.com/hi2048/hi2048-utils/tree/master/site/src/utils/creater&quot; title=&quot;creater&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="hi2048" scheme="http://hi2048.github.io/tags/hi2048/"/>
    
      <category term="hi2048-utils" scheme="http://hi2048.github.io/tags/hi2048-utils/"/>
    
  </entry>
  
  <entry>
    <title>unicode</title>
    <link href="http://hi2048.github.io/2020/03/08/unicode/"/>
    <id>http://hi2048.github.io/2020/03/08/unicode/</id>
    <published>2020-03-07T16:00:00.000Z</published>
    <updated>2020-03-14T19:09:03.238Z</updated>
    
    <content type="html"><![CDATA[<p>– unicode <a href="https://github.com/hi2048/hi2048-utils/tree/master/site/src/utils/unicode" title="unicode" target="_blank" rel="noopener">github</a>  <a href="https://www.npmjs.com/package/hi2048-utils" title="hi2048-utils" target="_blank" rel="noopener">npm</a>  <a href="http://blog.hi2048.com/hi2048-utils/" title="unicode" target="_blank" rel="noopener">demo</a></p><pre><code>-- index.jsimport { isFunction } from &apos;../type&apos;;import { random } from &apos;../random&apos;;import { familyNames, firstNames } from &apos;./index.config&apos;;export const encode = str =&gt; `\\u${Array.from(str).map(char =&gt; `00${char.charCodeAt().toString(16)}`.slice(-4)).join(&apos;\\u&apos;)}`;export const decode = par =&gt; {  let str = par;  if(isFunction(par)) {    str = par();  }  return unescape(str.replace(/\\/g, &apos;%&apos;));};export const create = () =&gt; `\\u${(random(20901) + 19968).toString(16)}`;export const createWord = () =&gt; decode(create);export const createRandomName = () =&gt; {  const count = random(2, 4);  const result = [];  for(let i = 0; i &lt; count; i++) {    result.push(createWord());  }  return result.join(&apos;&apos;);};export const createName = () =&gt; {  return `${familyNames[random(familyNames.length)]}${firstNames[random(firstNames.length)]}`;};export const unicode = {  encode,  decode,  create,  createWord,  createName,  createRandomName};-- index.test.jsimport { encode, decode, create, createWord, createName, createRandomName } from &apos;.&apos;;test(&apos;encode&apos;, () =&gt; expect(encode(&apos;苏小蜂&apos;)).toBe(&quot;\\u82cf\\u5c0f\\u8702&quot;));test(&apos;decode&apos;, () =&gt; expect(decode(&apos;\\u82cf\\u5c0f\\u8702&apos;)).toBe(&apos;苏小蜂&apos;));test(&apos;create&apos;, () =&gt; expect(create()).toBeDefined());test(&apos;create&apos;, () =&gt; expect(createWord()).toBeDefined());test(&apos;create&apos;, () =&gt; expect(createName()).toBeDefined());test(&apos;create&apos;, () =&gt; expect(createRandomName()).toBeDefined());</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;– unicode &lt;a href=&quot;https://github.com/hi2048/hi2048-utils/tree/master/site/src/utils/unicode&quot; title=&quot;unicode&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="hi2048" scheme="http://hi2048.github.io/tags/hi2048/"/>
    
      <category term="hi2048-utils" scheme="http://hi2048.github.io/tags/hi2048-utils/"/>
    
  </entry>
  
  <entry>
    <title>简单对象</title>
    <link href="http://hi2048.github.io/2020/03/06/%E7%AE%80%E5%8D%95%E5%AF%B9%E8%B1%A1/"/>
    <id>http://hi2048.github.io/2020/03/06/简单对象/</id>
    <published>2020-03-05T16:00:00.000Z</published>
    <updated>2020-03-14T19:08:17.499Z</updated>
    
    <content type="html"><![CDATA[<p>– isPlainObject <a href="https://github.com/hi2048/hi2048-utils/tree/master/site/src/utils/isPlainObject" title="isPlainObject" target="_blank" rel="noopener">github</a>  <a href="https://www.npmjs.com/package/hi2048-utils" title="hi2048-utils" target="_blank" rel="noopener">npm</a>  <a href="http://blog.hi2048.com/hi2048-utils/" title="isPlainObject" target="_blank" rel="noopener">demo</a></p><pre><code>-- index.jsimport { isObject } from &apos;../type&apos;;export const isPlainObject = obj =&gt; {  if(isObject(obj)) {    return Object.getPrototypeOf(obj) === Object.prototype;  }  return false;};-- index.test.jsimport { isPlainObject } from &apos;.&apos;;test(&quot;isPlainObject&quot;, () =&gt; expect(isPlainObject({ x: 1 })).toBeTruthy());test(&quot;isPlainObject&quot;, () =&gt; expect(isPlainObject(new Object({ x: 1 }))).toBeTruthy());test(&quot;isPlainObject&quot;, () =&gt; expect(isPlainObject(new class Test{})).toBeFalsy());</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;– isPlainObject &lt;a href=&quot;https://github.com/hi2048/hi2048-utils/tree/master/site/src/utils/isPlainObject&quot; title=&quot;isPlainObject&quot; target=&quot;_
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="hi2048" scheme="http://hi2048.github.io/tags/hi2048/"/>
    
      <category term="hi2048-utils" scheme="http://hi2048.github.io/tags/hi2048-utils/"/>
    
  </entry>
  
  <entry>
    <title>array基本操作</title>
    <link href="http://hi2048.github.io/2020/02/25/array%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://hi2048.github.io/2020/02/25/array基本操作/</id>
    <published>2020-02-24T16:00:00.000Z</published>
    <updated>2020-03-14T19:07:33.558Z</updated>
    
    <content type="html"><![CDATA[<p>– array <a href="https://github.com/hi2048/hi2048-utils/tree/master/site/src/utils/array" title="array" target="_blank" rel="noopener">github</a>  <a href="https://www.npmjs.com/package/hi2048-utils" title="hi2048-utils" target="_blank" rel="noopener">npm</a>  <a href="http://blog.hi2048.com/hi2048-utils/" title="array" target="_blank" rel="noopener">demo</a></p><pre><code>-- index.jsexport const add = array =&gt; item =&gt; array.push(item);export const remove = array =&gt; item =&gt; array = array.filter(v =&gt; v !== item);export const array = { add, remove };</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;– array &lt;a href=&quot;https://github.com/hi2048/hi2048-utils/tree/master/site/src/utils/array&quot; title=&quot;array&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gi
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="hi2048" scheme="http://hi2048.github.io/tags/hi2048/"/>
    
      <category term="hi2048-utils" scheme="http://hi2048.github.io/tags/hi2048-utils/"/>
    
  </entry>
  
  <entry>
    <title>curry, compose and pipe</title>
    <link href="http://hi2048.github.io/2020/02/20/curry-compose-and-pipe/"/>
    <id>http://hi2048.github.io/2020/02/20/curry-compose-and-pipe/</id>
    <published>2020-02-19T16:00:00.000Z</published>
    <updated>2020-02-29T12:51:42.148Z</updated>
    
    <content type="html"><![CDATA[<p>– curry, compose, pipe实现 <a href="https://github.com/hi2048/utils/tree/master/curry" title="curry" target="_blank" rel="noopener">github</a>  <a href="https://www.npmjs.com/package/hi2048-utils" title="hi2048-utils" target="_blank" rel="noopener">npm</a></p><pre><code>-- index.js/*** * @param  {...function} funs * f1, f2, f3 ... = f1(f2(f3(...)))*/const compose = (...funs) =&gt; funs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)));/*** * @param  {...function} funs * f1, f2, f3 ... = ...f3(f2(f1(args)))*/const pipe = (...funs) =&gt; compose(...funs.reverse());/*** * @param {function} fun * @param {array} args * f(a, b, c, ...) = f(a)(b)(c)...*/const curry = (fun, args = []) =&gt; args.length === fun.length?fun(...args) : (...arg1) =&gt; curry(fun, [...args, ...arg1]);module.exports = { compose, pipe, curry };-- index.test.jsconst assert = require(&apos;assert&apos;);const { compose, pipe, curry } = require(&apos;.&apos;);assert.equal(compose(Math.abs, a =&gt; a + 1, a =&gt; Math.pow(a, 2))(10), 101);assert.equal(pipe(Math.abs, a =&gt; a + 1, a =&gt; Math.pow(a, 2))(-10), 121);assert.equal(curry((a, b, c) =&gt; a + b - c)(10)(9)(11), 8);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;– curry, compose, pipe实现 &lt;a href=&quot;https://github.com/hi2048/utils/tree/master/curry&quot; title=&quot;curry&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github&lt;
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="hi2048" scheme="http://hi2048.github.io/tags/hi2048/"/>
    
      <category term="hi2048-utils" scheme="http://hi2048.github.io/tags/hi2048-utils/"/>
    
  </entry>
  
  <entry>
    <title>DynamicNumber</title>
    <link href="http://hi2048.github.io/2020/02/10/DynamicNumber/"/>
    <id>http://hi2048.github.io/2020/02/10/DynamicNumber/</id>
    <published>2020-02-09T16:00:00.000Z</published>
    <updated>2020-02-26T08:19:00.631Z</updated>
    
    <content type="html"><![CDATA[<p>– 数字跳动控件 <a href="https://github.com/hi2048/hi2048-design/tree/master/site/src/components/dynamicNumber" title="DynamicNumber" target="_blank" rel="noopener">github</a>  <a href="https://www.npmjs.com/package/hi2048-design" title="hi2048-design" target="_blank" rel="noopener">npm</a>  <a href="http://blog.hi2048.com/hi2048-design/" title="DynamicNumber" target="_blank" rel="noopener">demo</a></p><pre><code>-- index.jsimport React, { useState, useEffect } from &apos;react&apos;;import { NORMAL, getSpeed } from &apos;./config&apos;;import { random } from &apos;hi2048-utils&apos;;import &apos;./style.css&apos;;export const DynamicNumber = props =&gt; {  const { start = 100, end = 0, stepping = 1, isRandom = true, speed = NORMAL } = props;  const [count, setCount] = useState(start);  const dynamic = () =&gt; {    let dynamicStepping = stepping;    let distance = end - start;    const direction = distance &lt; 0?-1 : 1;    const timer = setInterval(() =&gt; {      if(isRandom) {        dynamicStepping = random(stepping);      }      if(Math.abs(distance) &lt; dynamicStepping) {        distance = 0;        setCount(end);        return clearInterval(timer);      }      distance -= dynamicStepping * direction;      setCount(count =&gt; count + dynamicStepping * direction);    }, getSpeed(speed))  }  useEffect(dynamic, []);  return (    &lt;div className=&quot;hi2048 dynamic-number-container&quot;&gt;      &lt;span className=&quot;counter&quot;&gt;{ count }&lt;/span&gt;    &lt;/div&gt;  );};-- config.jsconst SPEED_TYPES = {  FASTER: &apos;faster&apos;,  FAST: &apos;fast&apos;,  NORMAL: &apos;normal&apos;,  SLOW: &apos;slow&apos;,  SLOWER: &apos;slower&apos;};export const { FASTER, FAST, NORMAL, SLOW, SLOWER } = SPEED_TYPES;export const getSpeed = speed =&gt; {  switch(speed.toLowerCase()) {    case FASTER:      return 25;    case FAST:      return 50;    case NORMAL:      return 100;    case SLOW:      return 150;    case SLOWER:      return 200;  }};-- style.css.hi2048.dynamic-number-container {  &amp; .counter {    display: inline-block;    height: 22px;    width: auto;    min-width: 48px;    text-align: center;    color: #555;  }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;– 数字跳动控件 &lt;a href=&quot;https://github.com/hi2048/hi2048-design/tree/master/site/src/components/dynamicNumber&quot; title=&quot;DynamicNumber&quot; target=&quot;_b
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="React" scheme="http://hi2048.github.io/tags/React/"/>
    
      <category term="hi2048" scheme="http://hi2048.github.io/tags/hi2048/"/>
    
      <category term="hi2048-design" scheme="http://hi2048.github.io/tags/hi2048-design/"/>
    
  </entry>
  
  <entry>
    <title>类型判断</title>
    <link href="http://hi2048.github.io/2020/01/08/%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"/>
    <id>http://hi2048.github.io/2020/01/08/类型判断/</id>
    <published>2020-01-07T16:00:00.000Z</published>
    <updated>2020-02-29T12:44:07.258Z</updated>
    
    <content type="html"><![CDATA[<p>– 基本数据类型判断 <a href="https://github.com/hi2048/utils/tree/master/type" title="类型判断" target="_blank" rel="noopener">github</a>  <a href="https://www.npmjs.com/package/hi2048-utils" title="hi2048-utils" target="_blank" rel="noopener">npm</a></p><pre><code>-- type.jsconst types = {  &apos;Number&apos;: &apos;Number&apos;,  &apos;String&apos;: &apos;String&apos;,  &apos;Boolean&apos;: &apos;Boolean&apos;,  &apos;Object&apos;: &apos;Object&apos;,  &apos;Array&apos;: &apos;Array&apos;,  &apos;Function&apos;: &apos;Function&apos;,  &apos;Date&apos;: &apos;Date&apos;,  &apos;RegExp&apos;: &apos;RegExp&apos;,  &apos;Symbol&apos;: &apos;Symbol&apos;,  &apos;null&apos;: &apos;Null&apos;,  &apos;NaN&apos;: &apos;NaN&apos;,  &apos;undefined&apos;: &apos;Undefined&apos;};const isType = type =&gt; obj =&gt; Object.prototype.toString.call(obj) === `[object ${type}]`;const isTypeFactory = types =&gt; {  const isTypes = {};  for(let key of Object.keys(types)) {    if(types[key] === &apos;NaN&apos;) {      isTypes[&apos;isNaN&apos;] = isNaN;    } else if(types[key] === &apos;Number&apos;) {      isTypes[&apos;isNumber&apos;] = obj =&gt; {        if(isNaN(obj)) {          return false;        }        return isType(types[key])(obj);      };    } else {      isTypes[`is${types[key]}`] = isType(types[key]);    }  }  return isTypes;};module.exports = { isNumber, isString, isBoolean, isObject, isArray, isFunction, isDate, isRegExp, isSymbol, isNull, isNaN, isUndefined } = isTypeFactory(types);-- type.test.jsconst assert = require(&apos;assert&apos;);const { isNumber, isString, isBoolean, isObject, isArray, isFunction, isDate, isRegExp, isSymbol, isNull, isNaN, isUndefined } = require(&apos;.&apos;);assert.equal(isNumber(1), true);assert.equal(isNumber(&apos;a&apos;), false);assert.equal(isNumber(NaN), false);assert.equal(isString(&apos;a&apos;), true);assert.equal(isString({&apos;a&apos;: 1}), false);assert.equal(isBoolean(true), true);assert.equal(isBoolean(&apos;true&apos;), false);assert.equal(isObject({&apos;a&apos;: 1}), true);assert.equal(isObject([1,2]), false);assert.equal(isArray([1,2]), true);assert.equal(isArray({&apos;a&apos;: 1}), false);assert.equal(isFunction(console.log), true);assert.equal(isFunction(&apos;a&apos;), false);assert.equal(isDate(new Date()), true);assert.equal(isDate(&apos;a&apos;), false);assert.equal(isRegExp(/.*/g), true);assert.equal(isRegExp(&apos;a&apos;), false);assert.equal(isSymbol(Symbol()), true);assert.equal(isSymbol(&apos;a&apos;),false);assert.equal(isNull(null), true);assert.equal(isNull(&apos;null&apos;), false);assert.equal(isNaN(NaN), true);assert.equal(isNaN(&apos;NaN&apos;), true);assert.equal(isNaN(1), false);assert.equal(isUndefined(undefined), true);assert.equal(isUndefined(&apos;undefined&apos;), false);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;– 基本数据类型判断 &lt;a href=&quot;https://github.com/hi2048/utils/tree/master/type&quot; title=&quot;类型判断&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github&lt;/a&gt;  &lt;a href=&quot;ht
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="hi2048" scheme="http://hi2048.github.io/tags/hi2048/"/>
    
      <category term="hi2048-utils" scheme="http://hi2048.github.io/tags/hi2048-utils/"/>
    
  </entry>
  
  <entry>
    <title>最大最小值</title>
    <link href="http://hi2048.github.io/2019/12/25/%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
    <id>http://hi2048.github.io/2019/12/25/最大最小值/</id>
    <published>2019-12-24T16:00:00.000Z</published>
    <updated>2020-02-29T12:55:29.878Z</updated>
    
    <content type="html"><![CDATA[<p>– min and max value in args(array or numbers). </p><pre><code>const min = (...args) =&gt; {  return args.reduce((a, b) =&gt; {    b = Array.isArray(b)?min(...b) : b;    return a &lt; b?a : b;  }, Infinity);}const max = (...args) =&gt; {  return args.reduce((a, b) =&gt; {    b = Array.isArray(b)?max(...b) : b;    return a &gt; b?a : b;  }, -Infinity);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;– min and max value in args(array or numbers). &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const min = (...args) =&amp;gt; {
  return args.reduce((a, b) =&amp;gt; {
    b = 
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="utils" scheme="http://hi2048.github.io/tags/utils/"/>
    
  </entry>
  
  <entry>
    <title>“气球”的最大数量</title>
    <link href="http://hi2048.github.io/2019/11/18/%E2%80%9C%E6%B0%94%E7%90%83%E2%80%9D%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F/"/>
    <id>http://hi2048.github.io/2019/11/18/“气球”的最大数量/</id>
    <published>2019-11-17T16:00:00.000Z</published>
    <updated>2020-02-04T10:40:23.883Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 “balloon”（气球）。 </strong><br><strong> 字符串 text 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 “balloon”。 </strong></p><pre><code>const min = (...args) =&gt; {  return args.reduce((a, b) =&gt; a &lt; b?a : b);}var maxNumberOfBalloons = function(text) {    const hash = {b: 0, a: 0, l: 0, o: 0, n: 0};    for(let c of text) {        hash[c] = hash[c]?(++hash[c]) : 1;    }    return min(hash[&apos;b&apos;], hash[&apos;a&apos;], Math.floor(hash[&apos;l&apos;] / 2), Math.floor(hash[&apos;o&apos;] / 2), hash[&apos;n&apos;]);};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 “balloon”（气球）。 &lt;/strong&gt;&lt;br&gt;&lt;strong&gt; 字符串 text 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 “balloon”。
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="leetcode" scheme="http://hi2048.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>IndexedDB实践及封装</title>
    <link href="http://hi2048.github.io/2019/10/22/IndexedDB%E5%AE%9E%E8%B7%B5%E5%8F%8A%E5%B0%81%E8%A3%85/"/>
    <id>http://hi2048.github.io/2019/10/22/IndexedDB实践及封装/</id>
    <published>2019-10-21T16:00:00.000Z</published>
    <updated>2019-11-17T05:43:55.567Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>IndexedDB<br>utils for IndexedDB, crud operations.</p></li><li><p>代码实例 <a href="https://github.com/hi2048/IndexedDBOperator" title="IndexedDBOperator" target="_blank" rel="noopener">github</a></p><pre><code>-- config.jsexport default {  name: &quot;testDB&quot;}-- connect.jsimport config from &apos;./config&apos;;const connect = ({ name = config.name, version  }) =&gt; {  const promise = new Promise((resolve, reject) =&gt; {    let dbConnection;    const request = window.indexedDB.open(name, version);    request.onerror = e =&gt; {      reject(e);    }    request.onsuccess = e =&gt; {      dbConnection = request.result;      resolve(dbConnection);    }    request.onupgradeneeded = e =&gt; {      dbConnection = e.target.result;      resolve(dbConnection);    }  })  return promise;}export default connect;-- index.jsimport connect from &apos;./connect&apos;;class IndexedDBOperator {  constructor(version) {    if(!IndexedDBOperator.instance || version) {      this.dbConnection = connect({ version });      IndexedDBOperator.instance = this;    }    return IndexedDBOperator.instance;  }  static getInstance(version) {    return new IndexedDBOperator(version);  }  getVersion() {    return new Promise((resolve, reject) =&gt; {      this.dbConnection.then(db =&gt; resolve(db.version)).catch(err =&gt; reject(err));    });  }  containsObjectStore(name) {    return new Promise((resolve, reject) =&gt; {      this.dbConnection.then(db =&gt; {        try {          resolve(db.objectStoreNames.contains(name));        } catch(err) {          reject(err);        }      })    });  }  createObjectStore(name, keyPath) {    return new Promise((resolve, reject) =&gt; {      this.dbConnection.then(db =&gt; {        if(!db.objectStoreNames.contains(name)) {          try {            const objectStore = db.createObjectStore(name, { keyPath: keyPath, autoIncrement: true });            resolve(objectStore);          } catch(err) {            reject(err);          }        }      });    });  }  create(objectStore, data) {    return new Promise((resolve, reject) =&gt; {      this.dbConnection.then(db =&gt; {        const request = db.transaction([objectStore], &apos;readwrite&apos;).objectStore(objectStore).add(data);        request.onsuccess = e =&gt; {          resolve(e);        }        request.onerror = e =&gt; {          reject(e);        }      });    });  }  read(objectStore, searchIndex) {    return new Promise((resolve, reject) =&gt; {      this.dbConnection.then(db =&gt; {        const request = db.transaction([objectStore]).objectStore(objectStore).get(searchIndex);        request.onerror = e =&gt; {          reject(e);        };        request.onsuccess = e =&gt; {          resolve(request.result);        };      });    });  }  readAll(objectStore) {    return new Promise((resolve, reject) =&gt; {      this.dbConnection.then(db =&gt; {        const request = db.transaction([objectStore], &apos;readonly&apos;).objectStore(objectStore).openCursor();        const list = new Array();  // objectStore list        request.onsuccess = e =&gt; {          const cursor = event.target.result;          if(cursor) {            const { key, value } = cursor;            list.push({              key,              value            });            cursor.continue();          } else {            resolve(list);          }        };        request.onerror = e =&gt; {          reject(e);        };      });    });  }  update(objectStore, data) {    return new Promise((resolve, reject) =&gt; {      this.dbConnection.then(db =&gt; {        const request = db.transaction([objectStore], &apos;readwrite&apos;).objectStore(objectStore).put(data);        request.onsuccess = e =&gt; {          resolve(e);        };        request.onerror = e =&gt; {          reject(e);        };      });    });  }  delete(objectStore, searchIndex) {    return new Promise((resolve, reject) =&gt; {      this.dbConnection.then(db =&gt; {        const request = db.transaction([objectStore], &apos;readwrite&apos;).objectStore(objectStore).delete(searchIndex);        request.onsuccess = e =&gt; {          resolve(e);        };        request.onerror = e =&gt; {          reject(e);        };      });    });  }}export default IndexedDBOperator;</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;IndexedDB&lt;br&gt;utils for IndexedDB, crud operations.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;代码实例 &lt;a href=&quot;https://github.com/hi2048/IndexedDBOperator&quot; t
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="工具类" scheme="http://hi2048.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>UML实践</title>
    <link href="http://hi2048.github.io/2019/09/29/UML%E5%AE%9E%E8%B7%B5/"/>
    <id>http://hi2048.github.io/2019/09/29/UML实践/</id>
    <published>2019-09-28T16:00:00.000Z</published>
    <updated>2019-09-29T10:11:35.778Z</updated>
    
    <content type="html"><![CDATA[<ol><li>UML<br> <a href="/assets/UML类图.png"><img src="/assets/UML类图.png" alt="UML类图"></a></li><li><p>代码实例 <a href="https://github.com/hi2048/Design-And-Code/tree/master/Design-Patterns/UML" title="UML实践" target="_blank" rel="noopener">github</a></p><pre><code>-- water.jsclass Water {    constructor(){        console.log(&apos;Water constructor.&apos;);    }}module.exports = Water;-- o2.jsclass O2 {    constructor(){        console.log(&apos;O2 constructor.&apos;);    }}module.exports = O2;-- animal.js/*** 依赖关系：O2，Water----&gt;*/const O2 = require(&apos;./o2.js&apos;);const Water = require(&apos;./water.js&apos;);class Animal {    constructor(){        if(new.target === Animal)            throw new Error(`${Animal} cannot be initialized.`);        console.log(&apos;Animal constructor.&apos;);        this.life = true;    }    metaboly(o2 = new O2(), water = new Water()){        return;    }    breed(){}}module.exports = Animal;-- bird.js/*** 继承animal* 实线空心三角*/const Animal = require(&apos;./animal.js&apos;);const Wing = require(&apos;./wing.js&apos;);class Bird extends Animal {    constructor(feather) {        super();        console.log(&apos;Bird constructor.&apos;);        this.feather = feather;        this.wings = new Wing();    }    deposit() {}}module.exports = Bird;-- wing.js/*** 与鸟是组合关系* 鸟 实心菱形* 翅膀 实心箭头* 左右数字： 1   2， 1对2*/class Wing {    constructor(){        console.log(&apos;Wing constructor.&apos;)    }}module.exports = Wing;-- wildGoose.js/*** 继承鸟* 实线空心三角*/const Bird = require(&apos;./bird.js&apos;);class WildGoose extends Bird {    constructor() {        super();        console.log(&apos;WildGoose Construdtor.&apos;);    }    deposit() {        console.log(&apos;WildGoose Deposit.&apos;);    }    fly() {        console.log(&apos;WildGoose Fly.&apos;);    }}module.exports = WildGoose;-- gooseGroup.js/*** 与大雁： 聚合关系* 雁群： 空心菱形* 大雁： 实线箭头*/const WildGoose = require(&apos;./wildGoose.js&apos;);class GooseGroup {    constructor(){        this.wildGooses = new WildGoose();        console.log(&apos;GooseGroup Constructor.&apos;);    }}module.exports = GooseGroup;-- flyInterface.js/*** 接口*/class FlyInterface {    constructor() {        if(new.target === FlyInterface){            throw(&apos;Fly Interface cannot be initialized.&apos;);        }    }    fly() {        console.log(&apos;fly interface fly.&apos;);    }}module.exports = FlyInterface;-- duck.js/*** 继承自鸟* 实线空心三角*/class Duck extends Bird {    constructor() {        super();        console.log(&apos;Duck constructor.&apos;);    }}module.exports = Duck;-- donaldDuck.js/*** 实现接口： talkInterface* 虚线空心三角 或者 实线空心小圆*/const TalkInterface = require(&apos;./talkInterface.js&apos;);class DonaldDuck extends TalkInterface {    constructor(){        super();        console.log(&apos;Donald Duck Constructor.&apos;);    }    talk() {        super.talk();        console.log(&apos;Donald Duck talk.&apos;);    }}module.exports = DonaldDuck;-- talkInterface.jsclass TalkInterface {    constructor(){        if(new.target === TalkInterface){            throw new Error(&apos;Talk Interface cannot be initialized.&apos;);        }        console.log(&apos;Talk Interface Constructor.&apos;);    }    talk() {        console.log(&apos;talk interface talk.&apos;);    }}module.exports = TalkInterface;-- penguin.js/*** 继承自鸟* 实线空心三角*/const Bird = require(&apos;./bird.js&apos;);const Climate = require(&apos;./climate.js&apos;);class Penguin extends Bird {    constructor() {        super();        console.log(&apos;Penguin Constructor.&apos;);        this.climate = new Climate();    }}module.exports = Penguin;-- climate.js/*** 企鹅 关联关系-〉气候* 实线箭头*/class Climate {    constructor(){        console.log(&apos;Climate Constructor.&apos;);    }}module.exports = Climate;-- test.jsconst Animal = require(&apos;./animal.js&apos;);// const animal = new Animal();// animal.metaboly();const Bird = require(&apos;./bird.js&apos;);const bird = new Bird();bird.metaboly();const WildGoose = require(&apos;./wildGoose.js&apos;);// const wildGoose = new WildGoose();const GooseGroup = require(&apos;./gooseGroup.js&apos;);// const gooseGroup = new GooseGroup();const Penguin = require(&apos;./penguin.js&apos;);// const penguin = new Penguin();const DonaldDuck = require(&apos;./donaldDuck.js&apos;);// const donaldDuck = new DonaldDuck();// donaldDuck.talk();const TalkInterface = require(&apos;./talkInterface.js&apos;);// const talkInterface = new TalkInterface();</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;UML&lt;br&gt; &lt;a href=&quot;/assets/UML类图.png&quot;&gt;&lt;img src=&quot;/assets/UML类图.png&quot; alt=&quot;UML类图&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;代码实例 &lt;a href=&quot;https://github.com/hi20
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="设计模式" scheme="http://hi2048.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="大话设计模式" scheme="http://hi2048.github.io/tags/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>有向图的强连通分量算法</title>
    <link href="http://hi2048.github.io/2019/09/21/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://hi2048.github.io/2019/09/21/有向图的强连通分量算法/</id>
    <published>2019-09-20T16:00:00.000Z</published>
    <updated>2019-09-22T12:23:50.800Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 有向图的强连通分量： Tarjan算法 </strong></p><pre><code>const Stack = require(&apos;./Stack.js&apos;);// 有向图的强连通分量算法// dfs搜索class Tarjan {    constructor(n, connections, iDirected = true){        // 时间戳dfn: dfn[i] dfs搜索编号        this.dfn = [];        // 追溯值low: low[i] 初始值为 dfn[i]，后续可能会产生更新， low[i] = Math.min(low[i], [low|dfn][c]) i为父节点        this.low = [];        this.n = n;        this.connections = connections;        // dfs编号： 时间戳        this.index = 0;        this.stack = new Stack();        // 有向图的强连通分量        this.sccs = new Stack();        // 桥        this.bridges = [];        // true有向图， false单边无向图        this.iDirected = iDirected;    }    t(x, lastEdge) {        this.dfn[x] = this.low[x] = ++this.index;        this.stack.push(x);        for(let c of this.connections) {            // c = [x, y]            // 无向图重边处理            if(!this.iDirected &amp;&amp; c === lastEdge) continue;            // 默认为有向图            let directedX = c[0];            let directedY = c[1];            // 无向图            if(!this.iDirected){                if(x === c[1]){                    directedX = c[1];                    directedY = c[0];                }            }            if(directedX === x){                const y = directedY;                if(!this.dfn[y]){                    this.t(y, c);                    // 若𝑦没被访问过，则说明(𝑥,𝑦)是树枝边，递归访问𝑦,从𝑦回溯后，令𝑙𝑜𝑤[𝑥]=𝑚𝑖𝑛(𝑙𝑜𝑤[𝑥],𝑙𝑜𝑤[𝑦])                    this.low[x] = Math.min(this.low[x], this.low[y]);                    // 关键连接 - 桥                    if(this.low[y] &gt; this.dfn[x]){                        this.bridges.push(c);                    }                } else if(this.stack.has(y)){                    // 若𝑦被访问过且𝑦在栈中，令𝑙𝑜𝑤[𝑥]=𝑚𝑖𝑛(𝑙𝑜𝑤[𝑥],𝑑𝑓𝑛[𝑦])                    this.low[x] = Math.min(this.low[x], this.dfn[y]);                }            }        }        // 𝑙𝑜𝑤[𝑥]=𝑑𝑓𝑛[𝑥]成立，则栈中从𝑥到栈顶的所有节点构成一个强连通分量        if(this.dfn[x] === this.low[x]){            const scc = new Stack();            let y;            do{                y = this.stack.pop();                scc.push(y);            } while(x !== y);            this.sccs.push(scc);        }    }    execute() {        for(let i = 0; i &lt; this.n; i++) {            if(!this.dfn[i])                this.t(i);        }        return this.sccs;    }    getSccs() {        return this.sccs;    }    getBridges() {        return this.bridges;    }    contains(connection) {        const x = connection[0];        const y = connection[1];        for(let scc of this.sccs.getArray()){            if(scc.has(x) &amp;&amp; scc.has(y)){                return true;            }        }        return false;    }    print() {        this.sccs.print();    }}module.exports = Tarjan;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 有向图的强连通分量： Tarjan算法 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const Stack = require(&amp;apos;./Stack.js&amp;apos;);

// 有向图的强连通分量算法
// dfs搜索
class Tarja
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>求数据流的中位数</title>
    <link href="http://hi2048.github.io/2019/09/20/%E6%B1%82%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://hi2048.github.io/2019/09/20/求数据流的中位数/</id>
    <published>2019-09-19T16:00:00.000Z</published>
    <updated>2019-09-20T12:05:00.827Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 思路：将有序列表分为大小根堆，左侧为大根堆，右侧为小根堆，从而将中位数变成求取大小根堆的根值。 </strong></p><pre><code>class Heap {  constructor(iLarge = true){    this.heap = new Array();    this.isLarge = iLarge;  }  swap(id1, id2) {    let temp = this.heap[id1];    this.heap[id1] = this.heap[id2];    this.heap[id2] = temp;  }  up(id) {    let pid = Math.floor((id - 1) / 2);    if(this.isLarge){      if(id !== 0 &amp;&amp; this.heap[pid] &lt; this.heap[id]){        this.swap(pid, id);        this.up(pid);      }    } else {      if(id !== 0 &amp;&amp; this.heap[pid] &gt; this.heap[id]){        this.swap(pid, id);        this.up(pid);      }    }  }  down(id) {    let leftChildId = id * 2 + 1;    let rightChildId = id * 2 + 2;    let len = this.heap.length;    if(this.isLarge){      if(leftChildId &lt; len &amp;&amp; this.heap[leftChildId] &gt; this.heap[id]){        this.swap(leftChildId, id);        this.down(leftChildId);      }      if(rightChildId &lt; len &amp;&amp; this.heap[rightChildId] &gt; this.heap[id]){        this.swap(rightChildId, id);        this.down(rightChildId);      }    } else {      if(leftChildId &lt; len &amp;&amp; this.heap[leftChildId] &lt; this.heap[id]){        this.swap(leftChildId, id);        this.down(leftChildId);      }      if(rightChildId &lt; len &amp;&amp; this.heap[rightChildId] &lt; this.heap[id]){        this.swap(rightChildId, id);        this.down(rightChildId);      }    }  }  insert(x) {    this.heap.push(x);    this.up(this.heap.length - 1);  }  remove(){    this.swap(0, this.heap.length - 1);    const ret = this.heap.pop();    this.down(0);    return ret;  }  pop(){    return this.heap.pop();  }  getRoot(){    return this.heap[0]  }  getLength(){    return this.heap.length;  }}/** * initialize your data structure here. */var MedianFinder = function() {  // 思路：大小根堆 ， 左边为大根堆， 右边为小根堆  this.left = new Heap(true);  this.right = new Heap(false);};/** * @param {number} num * @return {void} */MedianFinder.prototype.addNum = function(num) {    // 具体算法： 如果num 大于 left 的最大值，则添加到右侧，添加完成后需要做大小根的平衡操作。    if(num &gt; this.left.getRoot()){      this.right.insert(num);      // 大小根平衡操作      if(this.right.getLength() &gt; this.left.getLength()){        this.left.insert(this.right.remove());      }    } else{      this.left.insert(num);      if(this.left.getLength() &gt; (this.right.getLength() + 1)){        this.right.insert(this.left.remove());      }    }};/** * @return {number} */MedianFinder.prototype.findMedian = function() {  let len = this.left.getLength() + this.right.getLength();  if(len % 2 === 0){    return (this.left.getRoot() + this.right.getRoot()) / 2;  } else{    return this.left.getRoot();  }};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 思路：将有序列表分为大小根堆，左侧为大根堆，右侧为小根堆，从而将中位数变成求取大小根堆的根值。 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Heap {
  constructor(iLarge = true){
    this.hea
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://hi2048.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript哈希</title>
    <link href="http://hi2048.github.io/2019/09/16/JavaScript%E5%93%88%E5%B8%8C/"/>
    <id>http://hi2048.github.io/2019/09/16/JavaScript哈希/</id>
    <published>2019-09-15T16:00:00.000Z</published>
    <updated>2019-09-16T04:33:10.127Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 表结构与JS对象结构转换，将数据结构A转换为数据结构B。 </strong></p><pre><code>// 定义数据结构const nodeAStruct = function(id, pid, data) {  this.id = id;  this.pid = pid;  this.data = data;}const nodeBStruct = function(id, children, data) {  this.id = id;  this.children = children;  this.data = data;}// 打印：深度遍历const print = (tree) =&gt; {  console.log(tree.data);  if(tree.children &amp;&amp; tree.children.length &gt; 0){    const children = tree.children;    children.forEach(child =&gt; {      print(child);    });  }}// 方法一：递归遍历const convert2Tree = (nodes = [], pid) =&gt; {  const result = [];  let temp = [];  nodes.forEach((node) =&gt; {    if(node.pid === pid){      const nodeB = new nodeBStruct(node.id, [], node.data);      temp = convert2Tree(nodes, node.id);      if(temp.length &gt; 0){        nodeB.children = temp;      }      result.push(nodeB);    }  });  return result;}// 方法二：hash处理const convertNodes2Hash = (nodes = []) =&gt; {  const hash = {};  nodes.forEach((node) =&gt; {    const nodeB = new nodeBStruct(node.id, [], node.data);    if(hash[node.pid]){      hash[node.pid].push(nodeB);    } else{      hash[node.pid] = [nodeB];    }  });  return hash;}const convertR = (hash, pid) =&gt; {  hash[pid].forEach(hp =&gt; {    const hc = hash[hp.id];    hp.children = hc?hc : [];    if(hc){      convertR(hash, hp.id);    }  });  return hash;}const convert2TreeByHash = (nodes = []) =&gt; {  const hash = convertNodes2Hash(nodes);  convertR(hash, -1);  return hash[-1];}const nodes = [];nodes.push(new nodeAStruct(0, -1, &apos;data0&apos;))nodes.push(new nodeAStruct(1, 0, &apos;data1&apos;))nodes.push(new nodeAStruct(2, 0, &apos;data2&apos;))nodes.push(new nodeAStruct(3, 1, &apos;data3&apos;))nodes.push(new nodeAStruct(4, 1, &apos;data4&apos;))nodes.push(new nodeAStruct(5, 2, &apos;data5&apos;))nodes.push(new nodeAStruct(6, 2, &apos;data6&apos;))let tree = convert2TreeByHash(nodes);print(tree[0]);console.log(tree[0])console.log(&apos;-----------------------&apos;);tree = convert2Tree(nodes, -1);print(tree[0]);console.log(tree[0])</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 表结构与JS对象结构转换，将数据结构A转换为数据结构B。 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 定义数据结构
const nodeAStruct = function(id, pid, data) {
  this.id = id;
  
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最大气球</title>
    <link href="http://hi2048.github.io/2019/09/15/%E6%9C%80%E5%A4%A7%E6%B0%94%E7%90%83/"/>
    <id>http://hi2048.github.io/2019/09/15/最大气球/</id>
    <published>2019-09-14T16:00:00.000Z</published>
    <updated>2019-09-16T03:29:09.212Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>LeetCode - “气球” 的最大数量<br><strong> 给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 “balloon”（气球）。 </strong><br><strong> 字符串 text 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 “balloon”。 </strong></p><pre><code>/** * @param {string} text * @return {number} 输入：text = &quot;nlaebolko&quot; 输出：1 输入：text = &quot;loonbalxballpoon&quot; 输出：2 输入：text = &quot;leetcode&quot; 输出：0 提示：  - 1 &lt;= text.length &lt;= 10^4  - text 全部由小写英文字母组成 */var getAlphaFromText = (text, alpha) =&gt; {  const reg = new RegExp(`${alpha}`, &apos;g&apos;);  if(reg.test(text)){    return text.match(reg).length;  }  return 0;}//balloonvar maxNumberOfBalloons = function(text) {    if(!text || (text &amp;&amp; text.length === 0)) return 0;    const balloonByteChars = [&apos;b&apos;, &apos;a&apos;, &apos;l&apos;, &apos;o&apos;, &apos;n&apos;];    const ret = balloonByteChars.reduce((count, b) =&gt; {      let len = getAlphaFromText(text, b);      if(b === &apos;l&apos; || b === &apos;o&apos;){        len = Math.floor(len / 2);      }      if(count &gt; len){        count = len;      }      return count;    }, text.length);    return ret;};</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;LeetCode - “气球” 的最大数量&lt;br&gt;&lt;strong&gt; 给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 “balloon”（气球）。 &lt;/strong&gt;&lt;br&gt;&lt;strong&gt; 字符串 text 中的每个字母最多只
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>状态管理</title>
    <link href="http://hi2048.github.io/2019/09/02/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    <id>http://hi2048.github.io/2019/09/02/状态管理/</id>
    <published>2019-09-01T16:00:00.000Z</published>
    <updated>2019-09-05T14:59:46.811Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>vuex</p><ul><li>vuex 是一个专门为vue.js应用程序开发的状态管理模式。</li></ul></li><li><p>状态自管理应用</p><ul><li>state, view, actions<br><a href="/assets/vue-flow.png"><img src="/assets/vue-flow.png" alt="vue-flow"></a></li></ul></li><li><p>vuex应用</p><p><a href="/assets/vuex.png"><img src="/assets/vuex.png" alt="vuex"></a></p></li><li><p>为什么引入状态管理模式</p><ul><li>多个视图依赖于同一状态。</li><li>来自不同视图的行为需要变更同一状态。</li></ul><p><strong> 传统的vue在解决上述问题时，会导致代码复杂与难于维护，vuex采用全局单例模式管理，可以使得代码更结构化且易维护。 </strong></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;vuex&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vuex 是一个专门为vue.js应用程序开发的状态管理模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;状态自管理应用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;state, view, actions&lt;br&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="React" scheme="http://hi2048.github.io/tags/React/"/>
    
      <category term="vue" scheme="http://hi2048.github.io/tags/vue/"/>
    
      <category term="vuex" scheme="http://hi2048.github.io/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>访问者模式</title>
    <link href="http://hi2048.github.io/2019/08/15/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://hi2048.github.io/2019/08/15/访问者模式/</id>
    <published>2019-08-14T16:00:00.000Z</published>
    <updated>2019-11-06T12:26:37.703Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>访问者模式（Visitor）<br> <a href="/assets/访问者模式.png"><img src="/assets/访问者模式.png" alt="访问者模式"></a></p></li><li><p>代码实例 <a href="https://github.com/hi2048/Design-And-Code/tree/master/Design-Patterns/Visitor" title="访问者模式" target="_blank" rel="noopener">github</a></p><pre><code>-- element.jsclass Element {    constructor() {        if(new.target === Element)            throw new Error(`${Element} cannot be initialized.`);    }    accept(vistor) {        throw new Error(`${this.accept} should be overwrite.`);    }}module.exports = Element;-- concreteElementA.jsconst Element = require(&apos;./element&apos;);class ConcreteElementA extends Element {    accept(visitor) {        visitor.visitConcreteElementA(this);    }    operatorA() {        console.log(&apos;ConcreteElementA operatorA.&apos;);    }}module.exports = ConcreteElementA;-- concreteElementB.jsconst Element = require(&apos;./element&apos;);class ConcreteElementB extends Element {    accept(visitor) {        visitor.visitConcreteElementB(this);    }    operatorB() {        console.log(`ConcreteElementB operatorB.`);    }}module.exports = ConcreteElementB;-- visitor.jsclass Visitor {    constructor() {        if(new.target === Visitor)            throw new Error(`${Visitor} cannot be initialized.`);    }    visitConcreteElementA(concreteElementA) {        throw new Error(`${this.visitConcreteElementA} should be overwrite.`);    }    visitConcreteElementB(concreteELementB) {        throw new Error(`${this.visitConcreteElementB} should be overwrite.`);    }}module.exports = Visitor;-- concreteVisitor1.jsconst Visitor = require(&apos;./visitor&apos;);class ConcreteVisitor1 extends Visitor {    visitConcreteElementA(concreteElementA) {        console.log(`${this.constructor.name} visitConcreteElementA ${concreteElementA.constructor.name} .`);    }    visitConcreteElementB(concreteElementB) {        console.log(`${this.constructor.name} visitConcreteElementB ${concreteElementB.constructor.name} .`);    }}module.exports = ConcreteVisitor1;-- concreteVisitor2.jsconst Visitor = require(&apos;./visitor&apos;);class ConcreteVisitor2 extends Visitor {    visitConcreteElementA(concreteElementA) {        console.log(`${this.constructor.name} visitConcreteElementA ${concreteElementA.constructor.name} .`);    }    visitConcreteElementB(concreteElementB) {        console.log(`${this.constructor.name} visitConcreteElementB ${concreteElementB.constructor.name} .`);    }}module.exports = ConcreteVisitor2;-- objectStructure.jsclass ObjectStructure {    constructor() {        this.elements = new Set();    }    add(element) {        return element &amp;&amp; this.elements.add(element);    }    remove(element) {        return this.elements.delete(element);    }    accept(visitor) {        this.elements.forEach(element =&gt; (element.accept(visitor)));    }}module.exports = ObjectStructure;-- client.jsconst ObjectStructure = require(&apos;./objectStructure&apos;);const ConcreteElementA = require(&apos;./concreteElementA&apos;);const ConcreteElementB = require(&apos;./concreteElementB&apos;);const ConcreteVisitor1 = require(&apos;./concreteVisitor1&apos;);const ConcreteVisitor2 = require(&apos;./concreteVisitor2&apos;);const objectStructure = new ObjectStructure();const concreteELementA = new ConcreteElementA();objectStructure.add(concreteELementA);objectStructure.add(new ConcreteElementB());const concreteVisitor1 = new ConcreteVisitor1();objectStructure.accept(concreteVisitor1);objectStructure.accept(new ConcreteVisitor2());</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;访问者模式（Visitor）&lt;br&gt; &lt;a href=&quot;/assets/访问者模式.png&quot;&gt;&lt;img src=&quot;/assets/访问者模式.png&quot; alt=&quot;访问者模式&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;代码实例 &lt;a href=&quot;http
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="设计模式" scheme="http://hi2048.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="大话设计模式" scheme="http://hi2048.github.io/tags/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Vue生命周期</title>
    <link href="http://hi2048.github.io/2019/08/02/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://hi2048.github.io/2019/08/02/Vue生命周期/</id>
    <published>2019-08-01T16:00:00.000Z</published>
    <updated>2019-09-05T14:58:52.372Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>Vue实例有一个完整的生命周期，也就是说从开始创建、初始化数据、编译模板、挂在DOM、渲染-更新-渲染、卸载等一系列过程，我们成为Vue 实例的生命周期，钩子就是在某个阶段给你一个做某些处理的机会。</p></li><li><p>Vue生命周期钩子</p><ul><li>beforeCreate</li><li>created</li><li>beforeMount</li><li>mounted</li><li>beforeUpdate</li><li>updated</li><li>beforeDestroy</li><li>destroyed</li></ul></li></ol><p><a href="/assets/lifecycle-vue.png"><img src="/assets/lifecycle-vue.png" alt="vue-生命周期"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;Vue实例有一个完整的生命周期，也就是说从开始创建、初始化数据、编译模板、挂在DOM、渲染-更新-渲染、卸载等一系列过程，我们成为Vue 实例的生命周期，钩子就是在某个阶段给你一个做某些处理的机会。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Vue生命周期钩子&lt;/
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="vue" scheme="http://hi2048.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>解释器模式</title>
    <link href="http://hi2048.github.io/2019/07/22/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://hi2048.github.io/2019/07/22/解释器模式/</id>
    <published>2019-07-21T16:00:00.000Z</published>
    <updated>2019-11-05T12:13:26.633Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>解释器模式（Interpreter）<br> <a href="/assets/解释器模式.png"><img src="/assets/解释器模式.png" alt="解释器模式"></a></p></li><li><p>代码实例 <a href="https://github.com/hi2048/Design-And-Code/tree/master/Design-Patterns/Interpreter" title="解释器模式" target="_blank" rel="noopener">github</a></p><pre><code>-- abstractExpression.jsclass AbstractExpression {    constructor() {        if(new.target === AbstractExpression) {            throw new Error(`${AbstractExpression} cannot be initialized.`);        }    }    interpret() {        throw new Error(`${this.interpret} should be overwrite.`);    }}module.exports = AbstractExpression;-- context.jsclass Context {    constructor(content) {        this.content = content;    }    setContent(content) {        return content &amp;&amp; (this.content = content);    }    getContent() {        return this.content;    }}module.exports = Context;-- terminalExpression.jsconst AbstractExpression = require(&apos;./abstractExpression&apos;);class TerminalExpression extends AbstractExpression {    interpret(context) {        console.log(`TerminalExpression interpret ${context}.`);    }}module.exports = TerminalExpression;-- nonterminalExpression.jsconst AbstractExpression = require(&apos;./abstractExpression&apos;);class NonterminalExpression extends AbstractExpression {    interpret(context) {        console.log(`NonterminalExpression interpret ${context}.`);    }}module.exports = NonterminalExpression;-- reTools.jsmodule.exports = {    numbers: /[0-9]/,    operators: /[+*/-]/,    verificationRule: /[0-9+*/-]/};-- abstractExpressionOperation.jsconst reTools = require(&apos;./reTools&apos;);class AbstractExpressionOperation {    constructor(operator) {        if(new.target === AbstractExpressionOperation)            throw new Error(`${AbstractExpressionOperation} cannot be initialized.`);        this.operator = operator;    }    interpret(operator = this.operator, prevExpresstion = this.prevExpresstion, nextExpression = this.nextExpression) {        if(new RegExp(reTools.verificationRule).test(operator)) {            return this.execute(operator, prevExpresstion, nextExpression);        }    }    execute(c, exp1, exp2) {        throw new Error(`${this.execute} should be overwrite.`);    }}module.exports = AbstractExpressionOperation;-- terminalExpressionNumber.jsconst AbstractExpressionOperation = require(&apos;./abstractExpressionOperation&apos;);class TerminalExpressionNumber extends AbstractExpressionOperation {    execute(number = this.operator) {        return number;    }}module.exports = TerminalExpressionNumber;-- nonterminalExpressionPlus.jsconst AbstractExpressionOperation = require(&apos;./abstractExpressionOperation&apos;);class NonterminalExpressionPlus extends AbstractExpressionOperation {    constructor(operator, prevExpression, nextExpression) {        super(operator);        this.prevExpression = prevExpression;        this.nextExpression = nextExpression;    }    setPrevExpression(prevExpression) {        return prevExpression &amp;&amp; (this.prevExpression = prevExpression);    }    setNextExpression(nextExpression) {        return nextExpression &amp;&amp; (this.nextExpression = nextExpression);    }    execute(operator = this.operator, expression1 = this.prevExpression, expression2 = this.nextExpression) {        console.log(`NonterminalExpressionPlus execute: ${expression1.interpret()} + ${expression2.interpret()} = ${+expression1.interpret() + +expression2.interpret()} .`);        return +expression1.interpret() + +expression2.interpret();    }}module.exports = NonterminalExpressionPlus;-- nonterminalExpressionMinus.jsconst AbstractExpressionOperation = require(&apos;./abstractExpressionOperation&apos;);class NonterminalExpressionMinus extends AbstractExpressionOperation {    constructor(operator, prevExpression, nextExpression) {        super(operator);        this.prevExpression = prevExpression;        this.nextExpression = nextExpression;    }    setPrevExpression(prevExpression) {        return prevExpression &amp;&amp; (this.prevExpression = prevExpression);    }    setNextExpression(nextExpression) {        return nextExpression &amp;&amp; (this.nextExpression = nextExpression);    }    execute(operator = this.operator, expression1 = this.prevExpression, expression2 = this.nextExpression) {        console.log(`NonterminalExpressionMinus execute: ${expression1.interpret()} - ${expression2.interpret()} = ${expression1.interpret() - expression2.interpret()} .`);        return expression1.interpret() - expression2.interpret();    }}module.exports = NonterminalExpressionMinus;-- client.jsconst Context = require(&apos;./context&apos;);const TerminalExpression = require(&apos;./terminalExpression&apos;);const NonterminalExpression = require(&apos;./nonterminalExpression&apos;);const reTools = require(&apos;./reTools&apos;);const TerminalExpressionNumber = require(&apos;./terminalExpressionNumber&apos;);const NonterminalExpressionPlus = require(&apos;./nonterminalExpressionPlus&apos;);const NonterminalExpressionMinus = require(&apos;./nonterminalExpressionMinus&apos;);const context = new Context(&apos;Interpreter DP&apos;);const terminalExpression = new TerminalExpression();const nonterminalExpression = new NonterminalExpression();const interpreter1 = new Set();interpreter1.add(terminalExpression);interpreter1.add(new TerminalExpression());interpreter1.add(nonterminalExpression);interpreter1.forEach(interpreter =&gt; (interpreter.interpret(context.getContent())));console.log(&apos;------&apos;);const context2 = new Context(&apos;1 + 2&apos;);const content = context2.getContent();let experssions = [];for(let c of content) {    if(new RegExp(reTools.numbers).test(c)) {        experssions.push(new TerminalExpressionNumber(c))    } else if(c === &apos;+&apos;) {        experssions.push(new NonterminalExpressionPlus(c));    } else if(c === &apos;-&apos;) {        experssions.push(new NonterminalExpressionMinus(c));    }}experssions.forEach((expression, index, expressions) =&gt; {    if(!(expression instanceof TerminalExpressionNumber)) {        expression.setPrevExpression(expressions[index - 1]);        expression.setNextExpression(expressions[index + 1]);        expression.interpret()    }});console.log(&apos;------&apos;);const context3 = new Context(&apos;2 - 3&apos;);const expressions3 = [];for(let c of context3.getContent()) {    if(new RegExp(reTools.numbers).test(c)) {        expressions3.push(new TerminalExpressionNumber(c));    } else if(c === &apos;+&apos;) {        expressions3.push(new NonterminalExpressionPlus(c));    } else if(c === &apos;-&apos;) {        expressions3.push(new NonterminalExpressionMinus(c));    }}expressions3.forEach((expression, index, expressions) =&gt; {    if(!(expression instanceof TerminalExpressionNumber)) {        expression.interpret(undefined, expressions[index - 1], expressions[index + 1]);    }});console.log(&apos;------&apos;);</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;解释器模式（Interpreter）&lt;br&gt; &lt;a href=&quot;/assets/解释器模式.png&quot;&gt;&lt;img src=&quot;/assets/解释器模式.png&quot; alt=&quot;解释器模式&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;代码实例 &lt;a href=&quot;
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="设计模式" scheme="http://hi2048.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="大话设计模式" scheme="http://hi2048.github.io/tags/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
