<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>苏小蜂的个人博客</title>
  
  <subtitle>放慢脚步，享受生活！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hi2048.github.io/"/>
  <updated>2019-09-29T10:11:35.778Z</updated>
  <id>http://hi2048.github.io/</id>
  
  <author>
    <name>Jsu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UML实践</title>
    <link href="http://hi2048.github.io/2019/09/29/UML%E5%AE%9E%E8%B7%B5/"/>
    <id>http://hi2048.github.io/2019/09/29/UML实践/</id>
    <published>2019-09-28T16:00:00.000Z</published>
    <updated>2019-09-29T10:11:35.778Z</updated>
    
    <content type="html"><![CDATA[<ol><li>UML<br> <a href="/assets/UML类图.png"><img src="/assets/UML类图.png" alt="UML类图"></a></li><li><p>代码实例 <a href="https://github.com/hi2048/Design-And-Code/tree/master/Design-Patterns/UML" title="UML实践" target="_blank" rel="noopener">github</a></p><pre><code>-- water.jsclass Water {    constructor(){        console.log(&apos;Water constructor.&apos;);    }}module.exports = Water;-- o2.jsclass O2 {    constructor(){        console.log(&apos;O2 constructor.&apos;);    }}module.exports = O2;-- animal.js/*** 依赖关系：O2，Water----&gt;*/const O2 = require(&apos;./o2.js&apos;);const Water = require(&apos;./water.js&apos;);class Animal {    constructor(){        if(new.target === Animal)            throw new Error(`${Animal} cannot be initialized.`);        console.log(&apos;Animal constructor.&apos;);        this.life = true;    }    metaboly(o2 = new O2(), water = new Water()){        return;    }    breed(){}}module.exports = Animal;-- bird.js/*** 继承animal* 实线空心三角*/const Animal = require(&apos;./animal.js&apos;);const Wing = require(&apos;./wing.js&apos;);class Bird extends Animal {    constructor(feather) {        super();        console.log(&apos;Bird constructor.&apos;);        this.feather = feather;        this.wings = new Wing();    }    deposit() {}}module.exports = Bird;-- wing.js/*** 与鸟是组合关系* 鸟 实心菱形* 翅膀 实心箭头* 左右数字： 1   2， 1对2*/class Wing {    constructor(){        console.log(&apos;Wing constructor.&apos;)    }}module.exports = Wing;-- wildGoose.js/*** 继承鸟* 实线空心三角*/const Bird = require(&apos;./bird.js&apos;);class WildGoose extends Bird {    constructor() {        super();        console.log(&apos;WildGoose Construdtor.&apos;);    }    deposit() {        console.log(&apos;WildGoose Deposit.&apos;);    }    fly() {        console.log(&apos;WildGoose Fly.&apos;);    }}module.exports = WildGoose;-- gooseGroup.js/*** 与大雁： 聚合关系* 雁群： 空心菱形* 大雁： 实线箭头*/const WildGoose = require(&apos;./wildGoose.js&apos;);class GooseGroup {    constructor(){        this.wildGooses = new WildGoose();        console.log(&apos;GooseGroup Constructor.&apos;);    }}module.exports = GooseGroup;-- flyInterface.js/*** 接口*/class FlyInterface {    constructor() {        if(new.target === FlyInterface){            throw(&apos;Fly Interface cannot be initialized.&apos;);        }    }    fly() {        console.log(&apos;fly interface fly.&apos;);    }}module.exports = FlyInterface;-- duck.js/*** 继承自鸟* 实线空心三角*/class Duck extends Bird {    constructor() {        super();        console.log(&apos;Duck constructor.&apos;);    }}module.exports = Duck;-- donaldDuck.js/*** 实现接口： talkInterface* 虚线空心三角 或者 实线空心小圆*/const TalkInterface = require(&apos;./talkInterface.js&apos;);class DonaldDuck extends TalkInterface {    constructor(){        super();        console.log(&apos;Donald Duck Constructor.&apos;);    }    talk() {        super.talk();        console.log(&apos;Donald Duck talk.&apos;);    }}module.exports = DonaldDuck;-- talkInterface.jsclass TalkInterface {    constructor(){        if(new.target === TalkInterface){            throw new Error(&apos;Talk Interface cannot be initialized.&apos;);        }        console.log(&apos;Talk Interface Constructor.&apos;);    }    talk() {        console.log(&apos;talk interface talk.&apos;);    }}module.exports = TalkInterface;-- penguin.js/*** 继承自鸟* 实线空心三角*/const Bird = require(&apos;./bird.js&apos;);const Climate = require(&apos;./climate.js&apos;);class Penguin extends Bird {    constructor() {        super();        console.log(&apos;Penguin Constructor.&apos;);        this.climate = new Climate();    }}module.exports = Penguin;-- climate.js/*** 企鹅 关联关系-〉气候* 实线箭头*/class Climate {    constructor(){        console.log(&apos;Climate Constructor.&apos;);    }}module.exports = Climate;-- test.jsconst Animal = require(&apos;./animal.js&apos;);// const animal = new Animal();// animal.metaboly();const Bird = require(&apos;./bird.js&apos;);const bird = new Bird();bird.metaboly();const WildGoose = require(&apos;./wildGoose.js&apos;);// const wildGoose = new WildGoose();const GooseGroup = require(&apos;./gooseGroup.js&apos;);// const gooseGroup = new GooseGroup();const Penguin = require(&apos;./penguin.js&apos;);// const penguin = new Penguin();const DonaldDuck = require(&apos;./donaldDuck.js&apos;);// const donaldDuck = new DonaldDuck();// donaldDuck.talk();const TalkInterface = require(&apos;./talkInterface.js&apos;);// const talkInterface = new TalkInterface();</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;UML&lt;br&gt; &lt;a href=&quot;/assets/UML类图.png&quot;&gt;&lt;img src=&quot;/assets/UML类图.png&quot; alt=&quot;UML类图&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;代码实例 &lt;a href=&quot;https://github.com/hi20
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="设计模式" scheme="http://hi2048.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="大话设计模式" scheme="http://hi2048.github.io/tags/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>有向图的强连通分量算法</title>
    <link href="http://hi2048.github.io/2019/09/21/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://hi2048.github.io/2019/09/21/有向图的强连通分量算法/</id>
    <published>2019-09-20T16:00:00.000Z</published>
    <updated>2019-09-22T12:23:50.800Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 有向图的强连通分量： Tarjan算法 </strong></p><pre><code>const Stack = require(&apos;./Stack.js&apos;);// 有向图的强连通分量算法// dfs搜索class Tarjan {    constructor(n, connections, iDirected = true){        // 时间戳dfn: dfn[i] dfs搜索编号        this.dfn = [];        // 追溯值low: low[i] 初始值为 dfn[i]，后续可能会产生更新， low[i] = Math.min(low[i], [low|dfn][c]) i为父节点        this.low = [];        this.n = n;        this.connections = connections;        // dfs编号： 时间戳        this.index = 0;        this.stack = new Stack();        // 有向图的强连通分量        this.sccs = new Stack();        // 桥        this.bridges = [];        // true有向图， false单边无向图        this.iDirected = iDirected;    }    t(x, lastEdge) {        this.dfn[x] = this.low[x] = ++this.index;        this.stack.push(x);        for(let c of this.connections) {            // c = [x, y]            // 无向图重边处理            if(!this.iDirected &amp;&amp; c === lastEdge) continue;            // 默认为有向图            let directedX = c[0];            let directedY = c[1];            // 无向图            if(!this.iDirected){                if(x === c[1]){                    directedX = c[1];                    directedY = c[0];                }            }            if(directedX === x){                const y = directedY;                if(!this.dfn[y]){                    this.t(y, c);                    // 若𝑦没被访问过，则说明(𝑥,𝑦)是树枝边，递归访问𝑦,从𝑦回溯后，令𝑙𝑜𝑤[𝑥]=𝑚𝑖𝑛(𝑙𝑜𝑤[𝑥],𝑙𝑜𝑤[𝑦])                    this.low[x] = Math.min(this.low[x], this.low[y]);                    // 关键连接 - 桥                    if(this.low[y] &gt; this.dfn[x]){                        this.bridges.push(c);                    }                } else if(this.stack.has(y)){                    // 若𝑦被访问过且𝑦在栈中，令𝑙𝑜𝑤[𝑥]=𝑚𝑖𝑛(𝑙𝑜𝑤[𝑥],𝑑𝑓𝑛[𝑦])                    this.low[x] = Math.min(this.low[x], this.dfn[y]);                }            }        }        // 𝑙𝑜𝑤[𝑥]=𝑑𝑓𝑛[𝑥]成立，则栈中从𝑥到栈顶的所有节点构成一个强连通分量        if(this.dfn[x] === this.low[x]){            const scc = new Stack();            let y;            do{                y = this.stack.pop();                scc.push(y);            } while(x !== y);            this.sccs.push(scc);        }    }    execute() {        for(let i = 0; i &lt; this.n; i++) {            if(!this.dfn[i])                this.t(i);        }        return this.sccs;    }    getSccs() {        return this.sccs;    }    getBridges() {        return this.bridges;    }    contains(connection) {        const x = connection[0];        const y = connection[1];        for(let scc of this.sccs.getArray()){            if(scc.has(x) &amp;&amp; scc.has(y)){                return true;            }        }        return false;    }    print() {        this.sccs.print();    }}module.exports = Tarjan;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 有向图的强连通分量： Tarjan算法 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const Stack = require(&amp;apos;./Stack.js&amp;apos;);

// 有向图的强连通分量算法
// dfs搜索
class Tarja
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>求数据流的中位数</title>
    <link href="http://hi2048.github.io/2019/09/20/%E6%B1%82%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://hi2048.github.io/2019/09/20/求数据流的中位数/</id>
    <published>2019-09-19T16:00:00.000Z</published>
    <updated>2019-09-20T12:05:00.827Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 思路：将有序列表分为大小根堆，左侧为大根堆，右侧为小根堆，从而将中位数变成求取大小根堆的根值。 </strong></p><pre><code>class Heap {  constructor(iLarge = true){    this.heap = new Array();    this.isLarge = iLarge;  }  swap(id1, id2) {    let temp = this.heap[id1];    this.heap[id1] = this.heap[id2];    this.heap[id2] = temp;  }  up(id) {    let pid = Math.floor((id - 1) / 2);    if(this.isLarge){      if(id !== 0 &amp;&amp; this.heap[pid] &lt; this.heap[id]){        this.swap(pid, id);        this.up(pid);      }    } else {      if(id !== 0 &amp;&amp; this.heap[pid] &gt; this.heap[id]){        this.swap(pid, id);        this.up(pid);      }    }  }  down(id) {    let leftChildId = id * 2 + 1;    let rightChildId = id * 2 + 2;    let len = this.heap.length;    if(this.isLarge){      if(leftChildId &lt; len &amp;&amp; this.heap[leftChildId] &gt; this.heap[id]){        this.swap(leftChildId, id);        this.down(leftChildId);      }      if(rightChildId &lt; len &amp;&amp; this.heap[rightChildId] &gt; this.heap[id]){        this.swap(rightChildId, id);        this.down(rightChildId);      }    } else {      if(leftChildId &lt; len &amp;&amp; this.heap[leftChildId] &lt; this.heap[id]){        this.swap(leftChildId, id);        this.down(leftChildId);      }      if(rightChildId &lt; len &amp;&amp; this.heap[rightChildId] &lt; this.heap[id]){        this.swap(rightChildId, id);        this.down(rightChildId);      }    }  }  insert(x) {    this.heap.push(x);    this.up(this.heap.length - 1);  }  remove(){    this.swap(0, this.heap.length - 1);    const ret = this.heap.pop();    this.down(0);    return ret;  }  pop(){    return this.heap.pop();  }  getRoot(){    return this.heap[0]  }  getLength(){    return this.heap.length;  }}/** * initialize your data structure here. */var MedianFinder = function() {  // 思路：大小根堆 ， 左边为大根堆， 右边为小根堆  this.left = new Heap(true);  this.right = new Heap(false);};/** * @param {number} num * @return {void} */MedianFinder.prototype.addNum = function(num) {    // 具体算法： 如果num 大于 left 的最大值，则添加到右侧，添加完成后需要做大小根的平衡操作。    if(num &gt; this.left.getRoot()){      this.right.insert(num);      // 大小根平衡操作      if(this.right.getLength() &gt; this.left.getLength()){        this.left.insert(this.right.remove());      }    } else{      this.left.insert(num);      if(this.left.getLength() &gt; (this.right.getLength() + 1)){        this.right.insert(this.left.remove());      }    }};/** * @return {number} */MedianFinder.prototype.findMedian = function() {  let len = this.left.getLength() + this.right.getLength();  if(len % 2 === 0){    return (this.left.getRoot() + this.right.getRoot()) / 2;  } else{    return this.left.getRoot();  }};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 思路：将有序列表分为大小根堆，左侧为大根堆，右侧为小根堆，从而将中位数变成求取大小根堆的根值。 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Heap {
  constructor(iLarge = true){
    this.hea
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="leetcode" scheme="http://hi2048.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript哈希</title>
    <link href="http://hi2048.github.io/2019/09/16/JavaScript%E5%93%88%E5%B8%8C/"/>
    <id>http://hi2048.github.io/2019/09/16/JavaScript哈希/</id>
    <published>2019-09-15T16:00:00.000Z</published>
    <updated>2019-09-16T04:33:10.127Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 表结构与JS对象结构转换，将数据结构A转换为数据结构B。 </strong></p><pre><code>// 定义数据结构const nodeAStruct = function(id, pid, data) {  this.id = id;  this.pid = pid;  this.data = data;}const nodeBStruct = function(id, children, data) {  this.id = id;  this.children = children;  this.data = data;}// 打印：深度遍历const print = (tree) =&gt; {  console.log(tree.data);  if(tree.children &amp;&amp; tree.children.length &gt; 0){    const children = tree.children;    children.forEach(child =&gt; {      print(child);    });  }}// 方法一：递归遍历const convert2Tree = (nodes = [], pid) =&gt; {  const result = [];  let temp = [];  nodes.forEach((node) =&gt; {    if(node.pid === pid){      const nodeB = new nodeBStruct(node.id, [], node.data);      temp = convert2Tree(nodes, node.id);      if(temp.length &gt; 0){        nodeB.children = temp;      }      result.push(nodeB);    }  });  return result;}// 方法二：hash处理const convertNodes2Hash = (nodes = []) =&gt; {  const hash = {};  nodes.forEach((node) =&gt; {    const nodeB = new nodeBStruct(node.id, [], node.data);    if(hash[node.pid]){      hash[node.pid].push(nodeB);    } else{      hash[node.pid] = [nodeB];    }  });  return hash;}const convertR = (hash, pid) =&gt; {  hash[pid].forEach(hp =&gt; {    const hc = hash[hp.id];    hp.children = hc?hc : [];    if(hc){      convertR(hash, hp.id);    }  });  return hash;}const convert2TreeByHash = (nodes = []) =&gt; {  const hash = convertNodes2Hash(nodes);  convertR(hash, -1);  return hash[-1];}const nodes = [];nodes.push(new nodeAStruct(0, -1, &apos;data0&apos;))nodes.push(new nodeAStruct(1, 0, &apos;data1&apos;))nodes.push(new nodeAStruct(2, 0, &apos;data2&apos;))nodes.push(new nodeAStruct(3, 1, &apos;data3&apos;))nodes.push(new nodeAStruct(4, 1, &apos;data4&apos;))nodes.push(new nodeAStruct(5, 2, &apos;data5&apos;))nodes.push(new nodeAStruct(6, 2, &apos;data6&apos;))let tree = convert2TreeByHash(nodes);print(tree[0]);console.log(tree[0])console.log(&apos;-----------------------&apos;);tree = convert2Tree(nodes, -1);print(tree[0]);console.log(tree[0])</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 表结构与JS对象结构转换，将数据结构A转换为数据结构B。 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 定义数据结构
const nodeAStruct = function(id, pid, data) {
  this.id = id;
  
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>最大气球</title>
    <link href="http://hi2048.github.io/2019/09/15/%E6%9C%80%E5%A4%A7%E6%B0%94%E7%90%83/"/>
    <id>http://hi2048.github.io/2019/09/15/最大气球/</id>
    <published>2019-09-14T16:00:00.000Z</published>
    <updated>2019-09-16T03:29:09.212Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>LeetCode - “气球” 的最大数量<br><strong> 给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 “balloon”（气球）。 </strong><br><strong> 字符串 text 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 “balloon”。 </strong></p><pre><code>/** * @param {string} text * @return {number} 输入：text = &quot;nlaebolko&quot; 输出：1 输入：text = &quot;loonbalxballpoon&quot; 输出：2 输入：text = &quot;leetcode&quot; 输出：0 提示：  - 1 &lt;= text.length &lt;= 10^4  - text 全部由小写英文字母组成 */var getAlphaFromText = (text, alpha) =&gt; {  const reg = new RegExp(`${alpha}`, &apos;g&apos;);  if(reg.test(text)){    return text.match(reg).length;  }  return 0;}//balloonvar maxNumberOfBalloons = function(text) {    if(!text || (text &amp;&amp; text.length === 0)) return 0;    const balloonByteChars = [&apos;b&apos;, &apos;a&apos;, &apos;l&apos;, &apos;o&apos;, &apos;n&apos;];    const ret = balloonByteChars.reduce((count, b) =&gt; {      let len = getAlphaFromText(text, b);      if(b === &apos;l&apos; || b === &apos;o&apos;){        len = Math.floor(len / 2);      }      if(count &gt; len){        count = len;      }      return count;    }, text.length);    return ret;};</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;LeetCode - “气球” 的最大数量&lt;br&gt;&lt;strong&gt; 给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 “balloon”（气球）。 &lt;/strong&gt;&lt;br&gt;&lt;strong&gt; 字符串 text 中的每个字母最多只
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>状态管理</title>
    <link href="http://hi2048.github.io/2019/09/02/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    <id>http://hi2048.github.io/2019/09/02/状态管理/</id>
    <published>2019-09-01T16:00:00.000Z</published>
    <updated>2019-09-05T14:59:46.811Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>vuex</p><ul><li>vuex 是一个专门为vue.js应用程序开发的状态管理模式。</li></ul></li><li><p>状态自管理应用</p><ul><li>state, view, actions<br><a href="/assets/vue-flow.png"><img src="/assets/vue-flow.png" alt="vue-flow"></a></li></ul></li><li><p>vuex应用</p><p><a href="/assets/vuex.png"><img src="/assets/vuex.png" alt="vuex"></a></p></li><li><p>为什么引入状态管理模式</p><ul><li>多个视图依赖于同一状态。</li><li>来自不同视图的行为需要变更同一状态。</li></ul><p><strong> 传统的vue在解决上述问题时，会导致代码复杂与难于维护，vuex采用全局单例模式管理，可以使得代码更结构化且易维护。 </strong></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;vuex&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vuex 是一个专门为vue.js应用程序开发的状态管理模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;状态自管理应用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;state, view, actions&lt;br&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="React" scheme="http://hi2048.github.io/tags/React/"/>
    
      <category term="vue" scheme="http://hi2048.github.io/tags/vue/"/>
    
      <category term="vuex" scheme="http://hi2048.github.io/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>Vue生命周期</title>
    <link href="http://hi2048.github.io/2019/08/02/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://hi2048.github.io/2019/08/02/Vue生命周期/</id>
    <published>2019-08-01T16:00:00.000Z</published>
    <updated>2019-09-05T14:58:52.372Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>Vue实例有一个完整的生命周期，也就是说从开始创建、初始化数据、编译模板、挂在DOM、渲染-更新-渲染、卸载等一系列过程，我们成为Vue 实例的生命周期，钩子就是在某个阶段给你一个做某些处理的机会。</p></li><li><p>Vue生命周期钩子</p><ul><li>beforeCreate</li><li>created</li><li>beforeMount</li><li>mounted</li><li>beforeUpdate</li><li>updated</li><li>beforeDestroy</li><li>destroyed</li></ul></li></ol><p><a href="/assets/lifecycle-vue.png"><img src="/assets/lifecycle-vue.png" alt="vue-生命周期"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;Vue实例有一个完整的生命周期，也就是说从开始创建、初始化数据、编译模板、挂在DOM、渲染-更新-渲染、卸载等一系列过程，我们成为Vue 实例的生命周期，钩子就是在某个阶段给你一个做某些处理的机会。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Vue生命周期钩子&lt;/
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="vue" scheme="http://hi2048.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>compose</title>
    <link href="http://hi2048.github.io/2019/06/10/compose/"/>
    <id>http://hi2048.github.io/2019/06/10/compose/</id>
    <published>2019-06-09T16:00:00.000Z</published>
    <updated>2019-09-10T15:47:32.356Z</updated>
    
    <content type="html"><![CDATA[<p><strong> JavaScript函数式编程：compose方法 </strong></p><pre><code>const compose = (arr) =&gt; {    return arr.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))}const composeT = (arr) =&gt; {  return arr.reduce((a, b) =&gt; {    return (...args) =&gt; {      console.log(`${a.name}(${b.name}(${args}))`);      return a(b(...args));    }  }, ()=&gt;{})}const a = (a, b) =&gt; {console.log(&quot;a: &quot;, a); return a;}const b = (a, b) =&gt; {console.log(&quot;b: &quot;, a); return a;}const c = (a, b) =&gt; {console.log(&quot;c: &quot;, a, b); return [a, b];}composeT([a,b,c])(&apos;1&apos;,&apos;2&apos;)(c(1,2))c:  1 2(b(1,2))b:  [ &apos;1&apos;, &apos;2&apos; ](a(1,2))a:  [ &apos;1&apos;, &apos;2&apos; ]</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; JavaScript函数式编程：compose方法 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const compose = (arr) =&amp;gt; {
    return arr.reduce((a, b) =&amp;gt; (...args) =&amp;
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的内存管理</title>
    <link href="http://hi2048.github.io/2019/03/23/JavaScript%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://hi2048.github.io/2019/03/23/JavaScript中的内存管理/</id>
    <published>2019-03-22T16:00:00.000Z</published>
    <updated>2019-09-23T04:29:27.352Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>内存管理的生命周期<br> <strong> Allocate Memory =&gt; Use Memory =&gt; Release Memory </strong></p></li><li><p>JavaScript中的GC机制</p><ul><li><p>引用机制：主要通过引用计数进行垃圾收集，将“对象是否不再需要”简化定义为“对象是否有引用存在”.<br><strong> 引用机制无法处理对象的循环引用 </strong></p></li><li><p>标记清除（Mark and Sweep）：算法假定设置一个根Root，定期从根开始递归寻找引用，从而获取所有可以获得的对象和不能获得的对象，因此也解决了循环引用的问题。<br><strong> 将“对象是否不再需要”简化定义为“对象是否可以获得”。 </strong></p></li></ul></li><li><p>内存泄露<br> <strong> 不再需要的内存, 无法被释放。 </strong></p></li><li><p>常见内存泄露案例</p><ul><li>全局变量</li><li>定时器和回调函数</li><li>闭包</li><li>Dom引用</li><li>Dom事件</li><li>console.log</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;内存管理的生命周期&lt;br&gt; &lt;strong&gt; Allocate Memory =&amp;gt; Use Memory =&amp;gt; Release Memory &lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;JavaScript中的GC机制&lt;/p&gt;
&lt;ul
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Stack实现</title>
    <link href="http://hi2048.github.io/2019/03/01/Stack%E5%AE%9E%E7%8E%B0/"/>
    <id>http://hi2048.github.io/2019/03/01/Stack实现/</id>
    <published>2019-02-28T16:00:00.000Z</published>
    <updated>2019-09-22T12:14:50.569Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 栈FILO：先进后出 </strong></p><pre><code>// 先进后出 FILO: first in last outclass Stack {    constructor(){        this.stack = new Array();    }    pop() {        return this.stack.pop();    }    push(x) {        this.stack.push(x);        return this;    }    empty() {        return this.size() === 0;    }    size() {        return this.stack.length;    }    top() {        return this.stack[this.stack.length - 1];    }    has(x) {        return this.stack.indexOf(x) !== -1;    }    getArray() {        return this.stack;    }    getRoot() {        return this.stack[0];    }    print() {        for(let s of [...this.stack]){        if(s.print){            console.log(`${s}：`);            s.print();        } else{            console.log(s);        }        }        return this;    }}module.exports = Stack;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 栈FILO：先进后出 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 先进后出 FILO: first in last out
class Stack {
    constructor(){
        this.stack = new Ar
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>数组去重</title>
    <link href="http://hi2048.github.io/2019/02/18/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
    <id>http://hi2048.github.io/2019/02/18/数组去重/</id>
    <published>2019-02-17T16:00:00.000Z</published>
    <updated>2019-09-18T14:31:10.318Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>使用Array的filter方法</p><pre><code>const distinctFilter = (arr) =&gt; (arr.filter((item, index) =&gt; (arr.indexOf(item) === index)))</code></pre></li><li><p>使用ES6的Set</p><pre><code>const distinctSet = (arr) =&gt; (Array.from(new Set(arr)));</code></pre></li><li><p>使用Hash方法</p><pre><code>const distinctHash = (arr) =&gt; {  const hash = {};  let disArr = [];  for(let i of arr){    if(!hash[i]){      disArr.push(i);      hash[i] = [i];    }  }  return disArr;}</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用Array的filter方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const distinctFilter = (arr) =&amp;gt; (arr.filter((item, index) =&amp;gt; (arr.indexOf(item) === index)
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>LRU算法</title>
    <link href="http://hi2048.github.io/2019/02/10/LRU%E7%AE%97%E6%B3%95/"/>
    <id>http://hi2048.github.io/2019/02/10/LRU算法/</id>
    <published>2019-02-09T16:00:00.000Z</published>
    <updated>2019-09-18T13:24:33.512Z</updated>
    
    <content type="html"><![CDATA[<p><strong> LRU (least recently used) 缓存机制：实现get, put方法。 </strong></p><pre><code>/** * 元素置顶 */const popItemFromArray = (arr, key) =&gt;{  arr.splice(arr.indexOf(key), 1);  arr.push(key);  return arr;}/** * 实现思路：ES6 Map [+ 有序数组（或者双向链表）] **/var LRUCache = function(capacity) {    this.cache = new Map();    this.lruArr = new Array();    this.curLen = 0;    this.capacity = capacity;};LRUCache.prototype.get = function(key) {    if(this.cache.has(key)){      const value = this.cache.get(key);      popItemFromArray(this.lruArr, key);      return value;    }    return -1;};LRUCache.prototype.lruDel = function(){  const minKey = this.lruArr.shift();  const isucc = this.cache.delete(minKey);  if(isucc){    this.curLen--;  }  return isucc;}// iorder : false descend true ascendLRUCache.prototype.sort = function(iorder) {  return this.lruArr.sort((c1, c2) =&gt; {    return c1 - c2;  });}LRUCache.prototype.put = function(key, value) {    if(this.cache.has(key)){      // pop key from lru array      popItemFromArray(this.lruArr, key);      return this.cache.set(key, value);    }    if(this.curLen === this.capacity){      this.lruDel();    }    this.curLen++;    this.lruArr.push(key);    return this.cache.set(key, value);};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; LRU (least recently used) 缓存机制：实现get, put方法。 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 元素置顶
 */
const popItemFromArray = (arr, key) =&amp;gt;{
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Heap实现</title>
    <link href="http://hi2048.github.io/2019/01/19/Heap%E5%AE%9E%E7%8E%B0/"/>
    <id>http://hi2048.github.io/2019/01/19/Heap实现/</id>
    <published>2019-01-18T16:00:00.000Z</published>
    <updated>2019-09-19T11:46:09.241Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 小根堆实现，大根堆类似 </strong></p><pre><code>// 通过 up down方法实现 堆的有效性class Heap {  constructor(){    this.heap = new Array();  }  swap(id1, id2) {    let temp = this.heap[id1];    this.heap[id1] = this.heap[id2];    this.heap[id2] = temp;  }  up(id) {    let pid = Math.floor((id - 1) / 2);    if(id !== 0 &amp;&amp; this.heap[pid] &gt; this.heap[id]){      this.swap(pid, id);      this.up(pid);    }  }  down(id) {    let leftChildId = id * 2 + 1;    let rightChildId = id * 2 + 2;    let len = this.heap.length;    if(leftChildId &lt; len &amp;&amp; this.heap[leftChildId] &lt; this.heap[id]){      this.swap(leftChildId, id);      this.down(leftChildId);    }    if(rightChildId &lt; len &amp;&amp; this.heap[rightChildId] &lt; this.heap[id]){      this.swap(rightChildId, id);      this.down(rightChildId);    }  }  insert(x) {    this.heap.push(x);    this.up(this.heap.length - 1);  }  remove(){    this.swap(0, this.heap.length - 1);    const ret = this.heap.pop();    this.down(0);    return ret;  }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 小根堆实现，大根堆类似 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 通过 up down方法实现 堆的有效性
class Heap {
  constructor(){
    this.heap = new Array();
  }

  s
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>React16为什么更新</title>
    <link href="http://hi2048.github.io/2018/12/11/React16%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9B%B4%E6%96%B0/"/>
    <id>http://hi2048.github.io/2018/12/11/React16为什么更新/</id>
    <published>2018-12-10T16:00:00.000Z</published>
    <updated>2019-09-11T09:35:37.523Z</updated>
    
    <content type="html"><![CDATA[<p><strong> React16更新的根本原因是提升用户体验，解决同步更新带来的界面卡顿问题。 </strong></p><ol><li><p>React16之前的版本中，更新过程是同步的，为什么会导致界面卡顿？<br><strong> 大量的同步计算任务阻塞了浏览器的UI渲染 </strong></p><ul><li>JavaScript是单线程的。</li><li>JavaScript运算、页面布局和页面绘制都是运行在浏览器的主线程当中，他们之间是互斥的关系。</li><li>React加载或者更新时，会调用生命周期函数，计算和对比Virtual DOM，更新UI，整个过程是同步的，如果需要更新的组件数量过大或者计算过于复杂，就会出现用户卡顿的体验。</li></ul></li><li><p>React是如何解决上述问题的？</p><p><strong> 引入了异步渲染(Async Rendering)机制 </strong></p><p>采用分片的思路，提出了Fiber的解决方案。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; React16更新的根本原因是提升用户体验，解决同步更新带来的界面卡顿问题。 &lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;React16之前的版本中，更新过程是同步的，为什么会导致界面卡顿？&lt;br&gt;&lt;strong&gt; 大量的同步计算任务阻塞了浏览器的
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="React" scheme="http://hi2048.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>快乐数</title>
    <link href="http://hi2048.github.io/2018/12/08/%E5%BF%AB%E4%B9%90%E6%95%B0/"/>
    <id>http://hi2048.github.io/2018/12/08/快乐数/</id>
    <published>2018-12-07T16:00:00.000Z</published>
    <updated>2019-09-08T13:53:44.932Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>快乐数：<br>正整数，求出每个位置的数字平方和，重复此过程，可以得到数字1，则为快乐数。<br>求取平方和过程中如果重复之前的平方和，则非快乐数。</p><pre><code>var getSquaresSum = function(n){    var ss = n.toString().split(&apos;&apos;);    return ss.reduce(function(count, s){        return count + Math.pow(parseInt(s), 2);    }, 0)}var isHappy = function(n) {    var rets = [n];    var count = n;    while(true){        count = getSquaresSum(count);        if(count === 1){            return true;        }        var index = rets.indexOf(count);        if(index !== -1){            return false;        }        rets.push(count);    }};</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;快乐数：&lt;br&gt;正整数，求出每个位置的数字平方和，重复此过程，可以得到数字1，则为快乐数。&lt;br&gt;求取平方和过程中如果重复之前的平方和，则非快乐数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var getSquaresSum = function(n){
    v
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>React生命周期</title>
    <link href="http://hi2048.github.io/2018/12/02/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://hi2048.github.io/2018/12/02/React生命周期/</id>
    <published>2018-12-01T16:00:00.000Z</published>
    <updated>2019-09-11T08:42:28.187Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>React生命周期 - React16前</p><p><strong> React生命周期总体上分为4个阶段：初始化阶段（initialization），挂载阶段（Mounting），更新阶段（update），卸载阶段（Unmount） </strong></p><ul><li><p>initialization：初始化props和state。<br>constructor</p></li><li><p>mounting：执行一次。<br>componentWillMount, render, componentDidMount</p></li><li><p>update：setState引起的state更新或者父组件重新render引起的props更新。<br>componentWillReceiveProps, shouldComponentUpdate, componentWillUpdate, render, componentDidUpdate</p></li><li><p>unmount: 执行一次<br>componentWillUnmount</p></li></ul><p><a href="/assets/React-lifecycle-before.png"><img src="/assets/React-lifecycle-before.png" alt="React生命周期"></a></p></li></ol><ol start="2"><li><p>React生命周期</p><ul><li>引入了两个新的生命周期函数<br>getDerivedStateFromProps，getSnapshotBeforeUpdate</li></ul><p><a href="/assets/React-lifecycle.png"><img src="/assets/React-lifecycle.png" alt="React16生命周期"></a></p></li><li><p>为什么会变化</p><p><strong> React16推出Fiber，如果开启async rendering，会导致render函数之前的所有函数，有可能被执行多次。 </strong></p><ul><li>componentWillMount</li><li>componentWillReceiveProps</li><li>componentWillUpdate</li><li>shouldComponentUpdate</li></ul><p>其中shouldComponentUpdate为纯函数，返回Boolean，没有副作用，而其他三个函数，开发者如果在里面执行有副作用的操作，如Ajax等，会产生不可预期的结果。所以其余三个统一被getDerivedStateFromProps替代，并且<strong> 采用静态函数，用禁止来替代以前的建议 </strong>。</p><p>react的component中static属性，里面放函数，官方解释：<br><strong> you can run them before any component instances are created, and the methods do not have access to the props or state of your components. </strong></p><p><strong> 静态函数getDerivedStateFromProps来取代被deprecate的几个生命周期函数，就是强制开发者在render之前只做无副作用的操作，而且能做的操作局限在根据props和state决定新的state。 </strong></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;React生命周期 - React16前&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; React生命周期总体上分为4个阶段：初始化阶段（initialization），挂载阶段（Mounting），更新阶段（update），卸载阶段（Unmount） &lt;/strong
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="React" scheme="http://hi2048.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>适配器模式</title>
    <link href="http://hi2048.github.io/2018/11/06/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://hi2048.github.io/2018/11/06/适配器模式/</id>
    <published>2018-11-05T16:00:00.000Z</published>
    <updated>2019-10-20T10:18:33.441Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>适配器模式（Adapter）<br> <a href="/assets/适配器模式.png"><img src="/assets/适配器模式.png" alt="适配器模式"></a></p></li><li><p>代码实例 <a href="https://github.com/hi2048/Design-And-Code/tree/master/Design-Patterns/Adapter" title="适配器模式" target="_blank" rel="noopener">github</a></p><pre><code>-- target.jsclass Target {    constructor() {        if(new.target === Target)            throw new Error(`${Target} cannot be initialized.`);        console.log(&apos;Target constructor.&apos;);    }    request() {        throw new Error(`${this.request} should be overwrite.`);    }}module.exports = Target;-- adapter.jsconst Target = require(&apos;./target&apos;);const Adaptee = require(&apos;./adaptee&apos;);class Adapter extends Target {    constructor(adaptee = new Adaptee()) {        super();        this.adaptee = adaptee;        console.log(&apos;Adapter constructor.&apos;);    }    request() {        this.adaptee.specificRequest();    }}module.exports = Adapter;-- adaptee.jsclass Adaptee {    constructor() {        console.log(&apos;Adaptee constructor.&apos;);    }    specificRequest() {        console.log(&apos;Adaptee specificRequest.&apos;);    }}module.exports = Adaptee;-- client.jsconst Adapter = require(&apos;./adapter&apos;);const Adaptee = require(&apos;./adaptee&apos;);const adapter = new Adapter(new Adaptee());adapter.request();console.log(&apos;------&apos;);const adapter2 = new Adapter();adapter2.request();console.log(&apos;------&apos;);</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;适配器模式（Adapter）&lt;br&gt; &lt;a href=&quot;/assets/适配器模式.png&quot;&gt;&lt;img src=&quot;/assets/适配器模式.png&quot; alt=&quot;适配器模式&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;代码实例 &lt;a href=&quot;http
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="设计模式" scheme="http://hi2048.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="大话设计模式" scheme="http://hi2048.github.io/tags/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>状态模式</title>
    <link href="http://hi2048.github.io/2018/10/21/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>http://hi2048.github.io/2018/10/21/状态模式/</id>
    <published>2018-10-20T16:00:00.000Z</published>
    <updated>2019-10-19T12:48:21.274Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>状态模式（State）<br> <a href="/assets/状态模式.png"><img src="/assets/状态模式.png" alt="状态模式"></a></p></li><li><p>代码实例 <a href="https://github.com/hi2048/Design-And-Code/tree/master/Design-Patterns/State" title="状态模式" target="_blank" rel="noopener">github</a></p><pre><code>-- state.jsclass State {    constructor() {        if(new.target === State)            throw new Error(`${State} cannot be initialized.`);        console.log(&apos;State constructor.&apos;);    }    handle() {        throw new Error(`${this.handle} should be overwrite.`);    }}module.exports = State;-- concreteStateA.jsconst State = require(&apos;./state&apos;);class ConcreteStateA extends State {    constructor() {        super();        console.log(&apos;ConcreteStateA constructor.&apos;);    }    handle(context) {        console.log(&apos;Current State: ConcreteStateA. &apos;);        context.setState(&apos;ConcreteStateB&apos;);    }}module.exports = ConcreteStateA;-- concreteStateB.jsconst State = require(&apos;./state&apos;);class ConcreteStateB extends State {    constructor() {        super();        console.log(&apos;ConcreteStateB constructor.&apos;);    };    handle(context) {        console.log(&apos;Current State: ConcreteStateB. &apos;);        context.setState(&apos;ConcreteStateC&apos;);    };}module.exports = ConcreteStateB;-- concreteStateC.jsconst State = require(&apos;./state&apos;);class ConcreteStateC extends State {    constructor() {        super();        console.log(&apos;ConcreteStateC constructor.&apos;);    };    handle(context) {        console.log(&apos;Current State: ConcreteStateC. &apos;);        context.setState(&apos;ConcreteStateA&apos;);    };}module.exports = ConcreteStateC;-- states.jsconst ConcreteStateA = require(&apos;./concreteStateA&apos;);const ConcreteStateB = require(&apos;./concreteStateB&apos;);const ConcreteStateC = require(&apos;./concreteStateC&apos;);module.exports = {    ConcreteStateA,    ConcreteStateB,    ConcreteStateC};-- context.jsconst states = require(&apos;./states&apos;);class Context {    constructor(state = &apos;ConcreteStateA&apos;) {        this.state = state;        console.log(&apos;Context constructor.&apos;);    }    setState(state) {        this.state = state;    };    request() {        new states[this.state]().handle(this);    };}module.exports = Context;-- client.jsconst Context = require(&apos;./context&apos;);const context = new Context();context.request();context.request();context.request();context.request();</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;状态模式（State）&lt;br&gt; &lt;a href=&quot;/assets/状态模式.png&quot;&gt;&lt;img src=&quot;/assets/状态模式.png&quot; alt=&quot;状态模式&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;代码实例 &lt;a href=&quot;https://gi
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="设计模式" scheme="http://hi2048.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="大话设计模式" scheme="http://hi2048.github.io/tags/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>React之setState</title>
    <link href="http://hi2048.github.io/2018/10/11/React%E4%B9%8BsetState/"/>
    <id>http://hi2048.github.io/2018/10/11/React之setState/</id>
    <published>2018-10-10T16:00:00.000Z</published>
    <updated>2019-09-11T12:14:16.446Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>setState是异步还是同步</p><ul><li>合成事件（react自定义的事件，如在组件中的onClick等）和生命周期函数中是“异步”的。这里的异步并非是真正的异步实现，其本身还是属于同步操作，只是采用了批处理机制。</li><li><p>原生事件（DOM中的原生事件，如通过addEventListener添加的等）和 setTimeout 中都是同步的</p><p>   setState(updater[, callback])</p><p>   updater可以是一个函数或者一个对象。<br>   如果是对象，则执行对象跟state的浅合并。<br>   如果传入一个函数，则会把函数的返回对象跟state进行浅合并。这个函数会传入两个参数state和props，返回一个对象<br>   (state, props) =&gt; stateChange</p><p>   第二个参数，state更新完毕之后调用的回调函数。如果有需要在state更新之后的操作，可以放在这里。不过官方更建议在componentDidUpdate里面处理更新之后的操作。</p></li></ul></li><li><p>使用注意事项</p><ul><li>不要直接修改state</li><li>setState不能保证是同步的</li><li>setState造成不必要的渲染</li></ul></li><li><p>setState的优化</p><ul><li>声名变量能用const就不要用let</li><li>减少setState的调用次数，如可以一次set多个值，不要一个一个set。</li><li>多利用shouldComponentUpdate</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;setState是异步还是同步&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;合成事件（react自定义的事件，如在组件中的onClick等）和生命周期函数中是“异步”的。这里的异步并非是真正的异步实现，其本身还是属于同步操作，只是采用了批处理机制。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="React" scheme="http://hi2048.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>秋</title>
    <link href="http://hi2048.github.io/2018/10/05/%E7%A7%8B/"/>
    <id>http://hi2048.github.io/2018/10/05/秋/</id>
    <published>2018-10-04T16:00:00.000Z</published>
    <updated>2019-09-05T14:51:31.779Z</updated>
    
    <content type="html"><![CDATA[<p>秋风送爽，炎暑渐消，此时宜甘味以益气，进补应坚持“燥者濡之”，“上燥清气，中燥增液，下燥养血。”同时应早睡早起，早餐宜营养丰富，以预防抑郁症，保持乐观轻松心情。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;秋风送爽，炎暑渐消，此时宜甘味以益气，进补应坚持“燥者濡之”，“上燥清气，中燥增液，下燥养血。”同时应早睡早起，早餐宜营养丰富，以预防抑郁症，保持乐观轻松心情。&lt;/p&gt;

      
    
    </summary>
    
      <category term="未分类" scheme="http://hi2048.github.io/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
</feed>
