<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>苏小蜂的个人博客</title>
  
  <subtitle>放慢脚步，享受生活！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hi2048.github.io/"/>
  <updated>2019-09-29T10:11:35.778Z</updated>
  <id>http://hi2048.github.io/</id>
  
  <author>
    <name>Jsu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UML实践</title>
    <link href="http://hi2048.github.io/2019/09/29/UML%E5%AE%9E%E8%B7%B5/"/>
    <id>http://hi2048.github.io/2019/09/29/UML实践/</id>
    <published>2019-09-28T16:00:00.000Z</published>
    <updated>2019-09-29T10:11:35.778Z</updated>
    
    <content type="html"><![CDATA[<ol><li>UML<br> <a href="/assets/UML类图.png"><img src="/assets/UML类图.png" alt="UML类图"></a></li><li><p>代码实例 <a href="https://github.com/hi2048/Design-And-Code/tree/master/Design-Patterns/UML" title="UML实践" target="_blank" rel="noopener">github</a></p><pre><code>-- water.jsclass Water {    constructor(){        console.log(&apos;Water constructor.&apos;);    }}module.exports = Water;-- o2.jsclass O2 {    constructor(){        console.log(&apos;O2 constructor.&apos;);    }}module.exports = O2;-- animal.js/*** 依赖关系：O2，Water----&gt;*/const O2 = require(&apos;./o2.js&apos;);const Water = require(&apos;./water.js&apos;);class Animal {    constructor(){        if(new.target === Animal)            throw new Error(`${Animal} cannot be initialized.`);        console.log(&apos;Animal constructor.&apos;);        this.life = true;    }    metaboly(o2 = new O2(), water = new Water()){        return;    }    breed(){}}module.exports = Animal;-- bird.js/*** 继承animal* 实线空心三角*/const Animal = require(&apos;./animal.js&apos;);const Wing = require(&apos;./wing.js&apos;);class Bird extends Animal {    constructor(feather) {        super();        console.log(&apos;Bird constructor.&apos;);        this.feather = feather;        this.wings = new Wing();    }    deposit() {}}module.exports = Bird;-- wing.js/*** 与鸟是组合关系* 鸟 实心菱形* 翅膀 实心箭头* 左右数字： 1   2， 1对2*/class Wing {    constructor(){        console.log(&apos;Wing constructor.&apos;)    }}module.exports = Wing;-- wildGoose.js/*** 继承鸟* 实线空心三角*/const Bird = require(&apos;./bird.js&apos;);class WildGoose extends Bird {    constructor() {        super();        console.log(&apos;WildGoose Construdtor.&apos;);    }    deposit() {        console.log(&apos;WildGoose Deposit.&apos;);    }    fly() {        console.log(&apos;WildGoose Fly.&apos;);    }}module.exports = WildGoose;-- gooseGroup.js/*** 与大雁： 聚合关系* 雁群： 空心菱形* 大雁： 实线箭头*/const WildGoose = require(&apos;./wildGoose.js&apos;);class GooseGroup {    constructor(){        this.wildGooses = new WildGoose();        console.log(&apos;GooseGroup Constructor.&apos;);    }}module.exports = GooseGroup;-- flyInterface.js/*** 接口*/class FlyInterface {    constructor() {        if(new.target === FlyInterface){            throw(&apos;Fly Interface cannot be initialized.&apos;);        }    }    fly() {        console.log(&apos;fly interface fly.&apos;);    }}module.exports = FlyInterface;-- duck.js/*** 继承自鸟* 实线空心三角*/class Duck extends Bird {    constructor() {        super();        console.log(&apos;Duck constructor.&apos;);    }}module.exports = Duck;-- donaldDuck.js/*** 实现接口： talkInterface* 虚线空心三角 或者 实线空心小圆*/const TalkInterface = require(&apos;./talkInterface.js&apos;);class DonaldDuck extends TalkInterface {    constructor(){        super();        console.log(&apos;Donald Duck Constructor.&apos;);    }    talk() {        super.talk();        console.log(&apos;Donald Duck talk.&apos;);    }}module.exports = DonaldDuck;-- talkInterface.jsclass TalkInterface {    constructor(){        if(new.target === TalkInterface){            throw new Error(&apos;Talk Interface cannot be initialized.&apos;);        }        console.log(&apos;Talk Interface Constructor.&apos;);    }    talk() {        console.log(&apos;talk interface talk.&apos;);    }}module.exports = TalkInterface;-- penguin.js/*** 继承自鸟* 实线空心三角*/const Bird = require(&apos;./bird.js&apos;);const Climate = require(&apos;./climate.js&apos;);class Penguin extends Bird {    constructor() {        super();        console.log(&apos;Penguin Constructor.&apos;);        this.climate = new Climate();    }}module.exports = Penguin;-- climate.js/*** 企鹅 关联关系-〉气候* 实线箭头*/class Climate {    constructor(){        console.log(&apos;Climate Constructor.&apos;);    }}module.exports = Climate;-- test.jsconst Animal = require(&apos;./animal.js&apos;);// const animal = new Animal();// animal.metaboly();const Bird = require(&apos;./bird.js&apos;);const bird = new Bird();bird.metaboly();const WildGoose = require(&apos;./wildGoose.js&apos;);// const wildGoose = new WildGoose();const GooseGroup = require(&apos;./gooseGroup.js&apos;);// const gooseGroup = new GooseGroup();const Penguin = require(&apos;./penguin.js&apos;);// const penguin = new Penguin();const DonaldDuck = require(&apos;./donaldDuck.js&apos;);// const donaldDuck = new DonaldDuck();// donaldDuck.talk();const TalkInterface = require(&apos;./talkInterface.js&apos;);// const talkInterface = new TalkInterface();</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;UML&lt;br&gt; &lt;a href=&quot;/assets/UML类图.png&quot;&gt;&lt;img src=&quot;/assets/UML类图.png&quot; alt=&quot;UML类图&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;代码实例 &lt;a href=&quot;https://github.com/hi20
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="设计模式" scheme="http://hi2048.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="大话设计模式" scheme="http://hi2048.github.io/tags/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>有向图的强连通分量算法</title>
    <link href="http://hi2048.github.io/2019/09/21/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://hi2048.github.io/2019/09/21/有向图的强连通分量算法/</id>
    <published>2019-09-20T16:00:00.000Z</published>
    <updated>2019-09-22T12:23:50.800Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 有向图的强连通分量： Tarjan算法 </strong></p><pre><code>const Stack = require(&apos;./Stack.js&apos;);// 有向图的强连通分量算法// dfs搜索class Tarjan {    constructor(n, connections, iDirected = true){        // 时间戳dfn: dfn[i] dfs搜索编号        this.dfn = [];        // 追溯值low: low[i] 初始值为 dfn[i]，后续可能会产生更新， low[i] = Math.min(low[i], [low|dfn][c]) i为父节点        this.low = [];        this.n = n;        this.connections = connections;        // dfs编号： 时间戳        this.index = 0;        this.stack = new Stack();        // 有向图的强连通分量        this.sccs = new Stack();        // 桥        this.bridges = [];        // true有向图， false单边无向图        this.iDirected = iDirected;    }    t(x, lastEdge) {        this.dfn[x] = this.low[x] = ++this.index;        this.stack.push(x);        for(let c of this.connections) {            // c = [x, y]            // 无向图重边处理            if(!this.iDirected &amp;&amp; c === lastEdge) continue;            // 默认为有向图            let directedX = c[0];            let directedY = c[1];            // 无向图            if(!this.iDirected){                if(x === c[1]){                    directedX = c[1];                    directedY = c[0];                }            }            if(directedX === x){                const y = directedY;                if(!this.dfn[y]){                    this.t(y, c);                    // 若𝑦没被访问过，则说明(𝑥,𝑦)是树枝边，递归访问𝑦,从𝑦回溯后，令𝑙𝑜𝑤[𝑥]=𝑚𝑖𝑛(𝑙𝑜𝑤[𝑥],𝑙𝑜𝑤[𝑦])                    this.low[x] = Math.min(this.low[x], this.low[y]);                    // 关键连接 - 桥                    if(this.low[y] &gt; this.dfn[x]){                        this.bridges.push(c);                    }                } else if(this.stack.has(y)){                    // 若𝑦被访问过且𝑦在栈中，令𝑙𝑜𝑤[𝑥]=𝑚𝑖𝑛(𝑙𝑜𝑤[𝑥],𝑑𝑓𝑛[𝑦])                    this.low[x] = Math.min(this.low[x], this.dfn[y]);                }            }        }        // 𝑙𝑜𝑤[𝑥]=𝑑𝑓𝑛[𝑥]成立，则栈中从𝑥到栈顶的所有节点构成一个强连通分量        if(this.dfn[x] === this.low[x]){            const scc = new Stack();            let y;            do{                y = this.stack.pop();                scc.push(y);            } while(x !== y);            this.sccs.push(scc);        }    }    execute() {        for(let i = 0; i &lt; this.n; i++) {            if(!this.dfn[i])                this.t(i);        }        return this.sccs;    }    getSccs() {        return this.sccs;    }    getBridges() {        return this.bridges;    }    contains(connection) {        const x = connection[0];        const y = connection[1];        for(let scc of this.sccs.getArray()){            if(scc.has(x) &amp;&amp; scc.has(y)){                return true;            }        }        return false;    }    print() {        this.sccs.print();    }}module.exports = Tarjan;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 有向图的强连通分量： Tarjan算法 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const Stack = require(&amp;apos;./Stack.js&amp;apos;);

// 有向图的强连通分量算法
// dfs搜索
class Tarja
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>求数据流的中位数</title>
    <link href="http://hi2048.github.io/2019/09/20/%E6%B1%82%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://hi2048.github.io/2019/09/20/求数据流的中位数/</id>
    <published>2019-09-19T16:00:00.000Z</published>
    <updated>2019-09-20T12:05:00.827Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 思路：将有序列表分为大小根堆，左侧为大根堆，右侧为小根堆，从而将中位数变成求取大小根堆的根值。 </strong></p><pre><code>class Heap {  constructor(iLarge = true){    this.heap = new Array();    this.isLarge = iLarge;  }  swap(id1, id2) {    let temp = this.heap[id1];    this.heap[id1] = this.heap[id2];    this.heap[id2] = temp;  }  up(id) {    let pid = Math.floor((id - 1) / 2);    if(this.isLarge){      if(id !== 0 &amp;&amp; this.heap[pid] &lt; this.heap[id]){        this.swap(pid, id);        this.up(pid);      }    } else {      if(id !== 0 &amp;&amp; this.heap[pid] &gt; this.heap[id]){        this.swap(pid, id);        this.up(pid);      }    }  }  down(id) {    let leftChildId = id * 2 + 1;    let rightChildId = id * 2 + 2;    let len = this.heap.length;    if(this.isLarge){      if(leftChildId &lt; len &amp;&amp; this.heap[leftChildId] &gt; this.heap[id]){        this.swap(leftChildId, id);        this.down(leftChildId);      }      if(rightChildId &lt; len &amp;&amp; this.heap[rightChildId] &gt; this.heap[id]){        this.swap(rightChildId, id);        this.down(rightChildId);      }    } else {      if(leftChildId &lt; len &amp;&amp; this.heap[leftChildId] &lt; this.heap[id]){        this.swap(leftChildId, id);        this.down(leftChildId);      }      if(rightChildId &lt; len &amp;&amp; this.heap[rightChildId] &lt; this.heap[id]){        this.swap(rightChildId, id);        this.down(rightChildId);      }    }  }  insert(x) {    this.heap.push(x);    this.up(this.heap.length - 1);  }  remove(){    this.swap(0, this.heap.length - 1);    const ret = this.heap.pop();    this.down(0);    return ret;  }  pop(){    return this.heap.pop();  }  getRoot(){    return this.heap[0]  }  getLength(){    return this.heap.length;  }}/** * initialize your data structure here. */var MedianFinder = function() {  // 思路：大小根堆 ， 左边为大根堆， 右边为小根堆  this.left = new Heap(true);  this.right = new Heap(false);};/** * @param {number} num * @return {void} */MedianFinder.prototype.addNum = function(num) {    // 具体算法： 如果num 大于 left 的最大值，则添加到右侧，添加完成后需要做大小根的平衡操作。    if(num &gt; this.left.getRoot()){      this.right.insert(num);      // 大小根平衡操作      if(this.right.getLength() &gt; this.left.getLength()){        this.left.insert(this.right.remove());      }    } else{      this.left.insert(num);      if(this.left.getLength() &gt; (this.right.getLength() + 1)){        this.right.insert(this.left.remove());      }    }};/** * @return {number} */MedianFinder.prototype.findMedian = function() {  let len = this.left.getLength() + this.right.getLength();  if(len % 2 === 0){    return (this.left.getRoot() + this.right.getRoot()) / 2;  } else{    return this.left.getRoot();  }};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 思路：将有序列表分为大小根堆，左侧为大根堆，右侧为小根堆，从而将中位数变成求取大小根堆的根值。 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Heap {
  constructor(iLarge = true){
    this.hea
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://hi2048.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript哈希</title>
    <link href="http://hi2048.github.io/2019/09/16/JavaScript%E5%93%88%E5%B8%8C/"/>
    <id>http://hi2048.github.io/2019/09/16/JavaScript哈希/</id>
    <published>2019-09-15T16:00:00.000Z</published>
    <updated>2019-09-16T04:33:10.127Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 表结构与JS对象结构转换，将数据结构A转换为数据结构B。 </strong></p><pre><code>// 定义数据结构const nodeAStruct = function(id, pid, data) {  this.id = id;  this.pid = pid;  this.data = data;}const nodeBStruct = function(id, children, data) {  this.id = id;  this.children = children;  this.data = data;}// 打印：深度遍历const print = (tree) =&gt; {  console.log(tree.data);  if(tree.children &amp;&amp; tree.children.length &gt; 0){    const children = tree.children;    children.forEach(child =&gt; {      print(child);    });  }}// 方法一：递归遍历const convert2Tree = (nodes = [], pid) =&gt; {  const result = [];  let temp = [];  nodes.forEach((node) =&gt; {    if(node.pid === pid){      const nodeB = new nodeBStruct(node.id, [], node.data);      temp = convert2Tree(nodes, node.id);      if(temp.length &gt; 0){        nodeB.children = temp;      }      result.push(nodeB);    }  });  return result;}// 方法二：hash处理const convertNodes2Hash = (nodes = []) =&gt; {  const hash = {};  nodes.forEach((node) =&gt; {    const nodeB = new nodeBStruct(node.id, [], node.data);    if(hash[node.pid]){      hash[node.pid].push(nodeB);    } else{      hash[node.pid] = [nodeB];    }  });  return hash;}const convertR = (hash, pid) =&gt; {  hash[pid].forEach(hp =&gt; {    const hc = hash[hp.id];    hp.children = hc?hc : [];    if(hc){      convertR(hash, hp.id);    }  });  return hash;}const convert2TreeByHash = (nodes = []) =&gt; {  const hash = convertNodes2Hash(nodes);  convertR(hash, -1);  return hash[-1];}const nodes = [];nodes.push(new nodeAStruct(0, -1, &apos;data0&apos;))nodes.push(new nodeAStruct(1, 0, &apos;data1&apos;))nodes.push(new nodeAStruct(2, 0, &apos;data2&apos;))nodes.push(new nodeAStruct(3, 1, &apos;data3&apos;))nodes.push(new nodeAStruct(4, 1, &apos;data4&apos;))nodes.push(new nodeAStruct(5, 2, &apos;data5&apos;))nodes.push(new nodeAStruct(6, 2, &apos;data6&apos;))let tree = convert2TreeByHash(nodes);print(tree[0]);console.log(tree[0])console.log(&apos;-----------------------&apos;);tree = convert2Tree(nodes, -1);print(tree[0]);console.log(tree[0])</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 表结构与JS对象结构转换，将数据结构A转换为数据结构B。 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 定义数据结构
const nodeAStruct = function(id, pid, data) {
  this.id = id;
  
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最大气球</title>
    <link href="http://hi2048.github.io/2019/09/15/%E6%9C%80%E5%A4%A7%E6%B0%94%E7%90%83/"/>
    <id>http://hi2048.github.io/2019/09/15/最大气球/</id>
    <published>2019-09-14T16:00:00.000Z</published>
    <updated>2019-09-16T03:29:09.212Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>LeetCode - “气球” 的最大数量<br><strong> 给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 “balloon”（气球）。 </strong><br><strong> 字符串 text 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 “balloon”。 </strong></p><pre><code>/** * @param {string} text * @return {number} 输入：text = &quot;nlaebolko&quot; 输出：1 输入：text = &quot;loonbalxballpoon&quot; 输出：2 输入：text = &quot;leetcode&quot; 输出：0 提示：  - 1 &lt;= text.length &lt;= 10^4  - text 全部由小写英文字母组成 */var getAlphaFromText = (text, alpha) =&gt; {  const reg = new RegExp(`${alpha}`, &apos;g&apos;);  if(reg.test(text)){    return text.match(reg).length;  }  return 0;}//balloonvar maxNumberOfBalloons = function(text) {    if(!text || (text &amp;&amp; text.length === 0)) return 0;    const balloonByteChars = [&apos;b&apos;, &apos;a&apos;, &apos;l&apos;, &apos;o&apos;, &apos;n&apos;];    const ret = balloonByteChars.reduce((count, b) =&gt; {      let len = getAlphaFromText(text, b);      if(b === &apos;l&apos; || b === &apos;o&apos;){        len = Math.floor(len / 2);      }      if(count &gt; len){        count = len;      }      return count;    }, text.length);    return ret;};</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;LeetCode - “气球” 的最大数量&lt;br&gt;&lt;strong&gt; 给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 “balloon”（气球）。 &lt;/strong&gt;&lt;br&gt;&lt;strong&gt; 字符串 text 中的每个字母最多只
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>状态管理</title>
    <link href="http://hi2048.github.io/2019/09/02/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    <id>http://hi2048.github.io/2019/09/02/状态管理/</id>
    <published>2019-09-01T16:00:00.000Z</published>
    <updated>2019-09-05T14:59:46.811Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>vuex</p><ul><li>vuex 是一个专门为vue.js应用程序开发的状态管理模式。</li></ul></li><li><p>状态自管理应用</p><ul><li>state, view, actions<br><a href="/assets/vue-flow.png"><img src="/assets/vue-flow.png" alt="vue-flow"></a></li></ul></li><li><p>vuex应用</p><p><a href="/assets/vuex.png"><img src="/assets/vuex.png" alt="vuex"></a></p></li><li><p>为什么引入状态管理模式</p><ul><li>多个视图依赖于同一状态。</li><li>来自不同视图的行为需要变更同一状态。</li></ul><p><strong> 传统的vue在解决上述问题时，会导致代码复杂与难于维护，vuex采用全局单例模式管理，可以使得代码更结构化且易维护。 </strong></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;vuex&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vuex 是一个专门为vue.js应用程序开发的状态管理模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;状态自管理应用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;state, view, actions&lt;br&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="React" scheme="http://hi2048.github.io/tags/React/"/>
    
      <category term="vue" scheme="http://hi2048.github.io/tags/vue/"/>
    
      <category term="vuex" scheme="http://hi2048.github.io/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>Vue生命周期</title>
    <link href="http://hi2048.github.io/2019/08/02/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://hi2048.github.io/2019/08/02/Vue生命周期/</id>
    <published>2019-08-01T16:00:00.000Z</published>
    <updated>2019-09-05T14:58:52.372Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>Vue实例有一个完整的生命周期，也就是说从开始创建、初始化数据、编译模板、挂在DOM、渲染-更新-渲染、卸载等一系列过程，我们成为Vue 实例的生命周期，钩子就是在某个阶段给你一个做某些处理的机会。</p></li><li><p>Vue生命周期钩子</p><ul><li>beforeCreate</li><li>created</li><li>beforeMount</li><li>mounted</li><li>beforeUpdate</li><li>updated</li><li>beforeDestroy</li><li>destroyed</li></ul></li></ol><p><a href="/assets/lifecycle-vue.png"><img src="/assets/lifecycle-vue.png" alt="vue-生命周期"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;Vue实例有一个完整的生命周期，也就是说从开始创建、初始化数据、编译模板、挂在DOM、渲染-更新-渲染、卸载等一系列过程，我们成为Vue 实例的生命周期，钩子就是在某个阶段给你一个做某些处理的机会。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Vue生命周期钩子&lt;/
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="vue" scheme="http://hi2048.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>compose</title>
    <link href="http://hi2048.github.io/2019/06/10/compose/"/>
    <id>http://hi2048.github.io/2019/06/10/compose/</id>
    <published>2019-06-09T16:00:00.000Z</published>
    <updated>2019-09-10T15:47:32.356Z</updated>
    
    <content type="html"><![CDATA[<p><strong> JavaScript函数式编程：compose方法 </strong></p><pre><code>const compose = (arr) =&gt; {    return arr.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))}const composeT = (arr) =&gt; {  return arr.reduce((a, b) =&gt; {    return (...args) =&gt; {      console.log(`${a.name}(${b.name}(${args}))`);      return a(b(...args));    }  }, ()=&gt;{})}const a = (a, b) =&gt; {console.log(&quot;a: &quot;, a); return a;}const b = (a, b) =&gt; {console.log(&quot;b: &quot;, a); return a;}const c = (a, b) =&gt; {console.log(&quot;c: &quot;, a, b); return [a, b];}composeT([a,b,c])(&apos;1&apos;,&apos;2&apos;)(c(1,2))c:  1 2(b(1,2))b:  [ &apos;1&apos;, &apos;2&apos; ](a(1,2))a:  [ &apos;1&apos;, &apos;2&apos; ]</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; JavaScript函数式编程：compose方法 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const compose = (arr) =&amp;gt; {
    return arr.reduce((a, b) =&amp;gt; (...args) =&amp;
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>职责链模式</title>
    <link href="http://hi2048.github.io/2019/05/02/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://hi2048.github.io/2019/05/02/职责链模式/</id>
    <published>2019-05-01T16:00:00.000Z</published>
    <updated>2019-10-29T12:19:18.862Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>职责链模式（ChainOfResponsibility）<br> <a href="/assets/职责链模式.png"><img src="/assets/职责链模式.png" alt="职责链模式"></a></p></li><li><p>代码实例 <a href="https://github.com/hi2048/Design-And-Code/tree/master/Design-Patterns/ChainOfResponsibility" title="职责链模式" target="_blank" rel="noopener">github</a></p><pre><code>-- handler.jsclass Handler {    constructor(successor) {        if(new.target === Handler) {            throw new Error(`${Handler} cannot be initialized.`);        }        this.successor = successor;    }    setSuccessor(successor) {        successor &amp;&amp; (this.successor = successor);        return this;    }    handleRequest() {        throw new Error(`${this.handleRequest} should be overwrite.`);    }}module.exports = Handler;-- concreteHandler1.jsconst Handler = require(&apos;./handler&apos;);class ConcreteHandler1 extends Handler {    constructor(successor) {        super(successor);    }    handleRequest(request) {        if(request &lt; 10) {            console.log(&apos;Concretehandler1 handleRequest.&apos;);        } else {            this.successor &amp;&amp; this.successor.handleRequest(request);        }    }}module.exports = ConcreteHandler1;-- concreteHandler2.jsconst Handler = require(&apos;./handler&apos;);class ConcreteHandler2 extends Handler {    constructor(successor) {        super(successor);    }    handleRequest(request) {        if(request &lt; 20){            console.log(&apos;ConcreteHandler2 handleRequest.&apos;);        } else {            this.successor &amp;&amp; this.successor.handleRequest(request);        }    }}module.exports = ConcreteHandler2;-- concreteHandler3.jsconst Handler = require(&apos;./handler&apos;);class ConcreteHandler3 extends Handler {    constructor(successor) {        super(successor);    }    handleRequest(request) {        console.log(&apos;ConcreteHandler3 handleRequest.&apos;);    }}module.exports = ConcreteHandler3;-- client.jsconst ConcreteHandler1 = require(&apos;./concreteHandler1&apos;);const ConcreteHandler2 = require(&apos;./concreteHandler2&apos;);const ConcreteHandler3 = require(&apos;./concreteHandler3&apos;);const concreteHandler3 = new ConcreteHandler3();const concreteHandler2 = new ConcreteHandler2();const concreteHandler1 = new ConcreteHandler1(concreteHandler2);concreteHandler2.setSuccessor(concreteHandler3);const request = [9, 10, 19, 20, 30, 999];request.forEach(req =&gt; (concreteHandler1.handleRequest(req)));</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;职责链模式（ChainOfResponsibility）&lt;br&gt; &lt;a href=&quot;/assets/职责链模式.png&quot;&gt;&lt;img src=&quot;/assets/职责链模式.png&quot; alt=&quot;职责链模式&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;代码实例
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="设计模式" scheme="http://hi2048.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="大话设计模式" scheme="http://hi2048.github.io/tags/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>命令模式</title>
    <link href="http://hi2048.github.io/2019/04/18/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>http://hi2048.github.io/2019/04/18/命令模式/</id>
    <published>2019-04-17T16:00:00.000Z</published>
    <updated>2019-10-27T12:52:15.129Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>命令模式（Command）<br> <a href="/assets/命令模式.png"><img src="/assets/命令模式.png" alt="命令模式"></a></p></li><li><p>代码实例 <a href="https://github.com/hi2048/Design-And-Code/tree/master/Design-Patterns/Command" title="命令模式" target="_blank" rel="noopener">github</a></p><pre><code>-- command.jsclass Command {    constructor(receiver) {        if(new.target === Command)            throw new Error(`${Command} cannot be initialized.`);        this.receiver = receiver;    }    setReceiver(receiver) {        return receiver &amp;&amp; (this.receiver = receiver);    }    execute() {        throw new Error(`{this.execute} should be overwrite.`);    }}module.exports = Command;-- concreteCommand.jsconst Command = require(&apos;./command&apos;);class ConcreteCommand extends Command {    constructor(receiver = {}) {        super(receiver);    }    execute() {        this.receiver.action();    }}module.exports = ConcreteCommand;-- invoker.jsclass Invoker {    constructor() {        this.orders = new Set();    }    addCommand(command) {        return command &amp;&amp; this.orders.add(command);    }    removeCommand(command) {        return command &amp;&amp; this.orders.delete(command);    }    notify() {        this.orders.forEach(order =&gt; (order.execute()));    }}module.exports = Invoker;-- receiver.jsclass Receiver {    action() {        console.log(&apos;Receiver action.&apos;);    }}module.exports = Receiver;-- client.jsconst Invoker = require(&apos;./invoker&apos;);const Receiver = require(&apos;./receiver&apos;);const ConcreteCommand = require(&apos;./concreteCommand&apos;);const invoker = new Invoker();const receiver = new Receiver();const concreteCommand1 = new ConcreteCommand();concreteCommand1.setReceiver(receiver);const concreteCommand2 = new ConcreteCommand(receiver);const concreteCommand3 = new ConcreteCommand(receiver);invoker.addCommand(concreteCommand1);invoker.addCommand();invoker.addCommand(concreteCommand1);invoker.addCommand(concreteCommand2);invoker.addCommand(concreteCommand3);invoker.removeCommand();invoker.removeCommand(concreteCommand1);invoker.removeCommand();invoker.removeCommand(concreteCommand1);invoker.notify();</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;命令模式（Command）&lt;br&gt; &lt;a href=&quot;/assets/命令模式.png&quot;&gt;&lt;img src=&quot;/assets/命令模式.png&quot; alt=&quot;命令模式&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;代码实例 &lt;a href=&quot;https://
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="设计模式" scheme="http://hi2048.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="大话设计模式" scheme="http://hi2048.github.io/tags/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的内存管理</title>
    <link href="http://hi2048.github.io/2019/03/23/JavaScript%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://hi2048.github.io/2019/03/23/JavaScript中的内存管理/</id>
    <published>2019-03-22T16:00:00.000Z</published>
    <updated>2019-09-23T04:29:27.352Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>内存管理的生命周期<br> <strong> Allocate Memory =&gt; Use Memory =&gt; Release Memory </strong></p></li><li><p>JavaScript中的GC机制</p><ul><li><p>引用机制：主要通过引用计数进行垃圾收集，将“对象是否不再需要”简化定义为“对象是否有引用存在”.<br><strong> 引用机制无法处理对象的循环引用 </strong></p></li><li><p>标记清除（Mark and Sweep）：算法假定设置一个根Root，定期从根开始递归寻找引用，从而获取所有可以获得的对象和不能获得的对象，因此也解决了循环引用的问题。<br><strong> 将“对象是否不再需要”简化定义为“对象是否可以获得”。 </strong></p></li></ul></li><li><p>内存泄露<br> <strong> 不再需要的内存, 无法被释放。 </strong></p></li><li><p>常见内存泄露案例</p><ul><li>全局变量</li><li>定时器和回调函数</li><li>闭包</li><li>Dom引用</li><li>Dom事件</li><li>console.log</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;内存管理的生命周期&lt;br&gt; &lt;strong&gt; Allocate Memory =&amp;gt; Use Memory =&amp;gt; Release Memory &lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;JavaScript中的GC机制&lt;/p&gt;
&lt;ul
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>桥接模式</title>
    <link href="http://hi2048.github.io/2019/03/05/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://hi2048.github.io/2019/03/05/桥接模式/</id>
    <published>2019-03-04T16:00:00.000Z</published>
    <updated>2019-10-26T14:00:12.036Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>桥接模式（Bridge）<br> <a href="/assets/桥接模式.png"><img src="/assets/桥接模式.png" alt="桥接模式"></a></p></li><li><p>代码实例 <a href="https://github.com/hi2048/Design-And-Code/tree/master/Design-Patterns/Bridge" title="桥接模式" target="_blank" rel="noopener">github</a></p><pre><code>-- abstraction.jsclass Abstraction {    constructor(implementor) {        if(new.target === Abstraction)            throw new Error(`${Abstraction} cannot be initialized.`);        this.implementor = implementor;    }    setImplementor(implementor) {        implementor &amp;&amp; (this.implementor = implementor);        return this;    }    operation() {        throw new Error(`${this.operation} should be overwrite.`);    }}module.exports = Abstraction;-- implementor.jsclass Implementor {    constructor() {        if(new.target === Implementor) {            throw new Error(`${Implementor} cannot be initialized.`);        }    }    operation() {        throw new Error(`${this.operation} should be overwrite.`);    }}module.exports = Implementor;-- refinedAbstraction.jsconst Abstraction = require(&apos;./abstraction&apos;);class RefinedAbstraction extends Abstraction {    constructor(implementor = {}) {        super(implementor);    }    operation() {        console.log(&apos;RefinedAbstraction operation.&apos;);        this.implementor.operation &amp;&amp; this.implementor.operation();        return this;    }}module.exports = RefinedAbstraction;-- concreteImplementorA.jsconst Implementor = require(&apos;./implementor&apos;);class ConcreteImplementorA extends Implementor {    constructor() {        super();    }    operation() {        console.log(&apos;ConcreteImplementorA operation.&apos;);    }}module.exports = ConcreteImplementorA;-- concreteImplementorB.jsconst Implementor = require(&apos;./implementor&apos;);class ConcreteImplementorB extends Implementor {    constructor() {        super();    }    operation() {        console.log(&apos;ConcreteImplementorB operation.&apos;);    }}module.exports = ConcreteImplementorB;-- client.jsconst RefinedAbstraction = require(&apos;./refinedAbstraction&apos;);const ConcreteImplementorA = require(&apos;./concreteImplementorA&apos;);const ConcreteImplementorB = require(&apos;./concreteImplementorB&apos;);const refinedAbstraction = new RefinedAbstraction();const concreteImplementorA = new ConcreteImplementorA();const concreteImplementorB = new ConcreteImplementorB();refinedAbstraction.operation();console.log(&apos;------&apos;);refinedAbstraction.setImplementor().operation();console.log(&apos;------&apos;);refinedAbstraction.setImplementor(concreteImplementorA).operation();console.log(&apos;------&apos;);refinedAbstraction.setImplementor().operation();console.log(&apos;------&apos;);refinedAbstraction.setImplementor(concreteImplementorB).operation();console.log(&apos;------&apos;);new RefinedAbstraction(new ConcreteImplementorB()).operation().setImplementor().operation().setImplementor(new ConcreteImplementorA()).operation();console.log(&apos;------&apos;);</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;桥接模式（Bridge）&lt;br&gt; &lt;a href=&quot;/assets/桥接模式.png&quot;&gt;&lt;img src=&quot;/assets/桥接模式.png&quot; alt=&quot;桥接模式&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;代码实例 &lt;a href=&quot;https://g
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="设计模式" scheme="http://hi2048.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="大话设计模式" scheme="http://hi2048.github.io/tags/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Stack实现</title>
    <link href="http://hi2048.github.io/2019/03/01/Stack%E5%AE%9E%E7%8E%B0/"/>
    <id>http://hi2048.github.io/2019/03/01/Stack实现/</id>
    <published>2019-02-28T16:00:00.000Z</published>
    <updated>2019-09-22T12:14:50.569Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 栈FILO：先进后出 </strong></p><pre><code>// 先进后出 FILO: first in last outclass Stack {    constructor(){        this.stack = new Array();    }    pop() {        return this.stack.pop();    }    push(x) {        this.stack.push(x);        return this;    }    empty() {        return this.size() === 0;    }    size() {        return this.stack.length;    }    top() {        return this.stack[this.stack.length - 1];    }    has(x) {        return this.stack.indexOf(x) !== -1;    }    getArray() {        return this.stack;    }    getRoot() {        return this.stack[0];    }    print() {        for(let s of [...this.stack]){        if(s.print){            console.log(`${s}：`);            s.print();        } else{            console.log(s);        }        }        return this;    }}module.exports = Stack;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 栈FILO：先进后出 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 先进后出 FILO: first in last out
class Stack {
    constructor(){
        this.stack = new Ar
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://hi2048.github.io/2019/02/18/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://hi2048.github.io/2019/02/18/单例模式/</id>
    <published>2019-02-17T16:00:00.000Z</published>
    <updated>2019-10-24T11:52:46.047Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>单例模式（Singleton）<br> <a href="/assets/单例模式.png"><img src="/assets/单例模式.png" alt="单例模式"></a></p></li><li><p>代码实例 <a href="https://github.com/hi2048/Design-And-Code/tree/master/Design-Patterns/Singleton" title="单例模式" target="_blank" rel="noopener">github</a></p><pre><code>-- singleton.jsclass Singleton {    constructor(name = &apos;Singleton&apos;) {        if(!Singleton.instance) {            this.name = name;            Singleton.instance = this;        }        return Singleton.instance    }    static getInstance(name) {        return new Singleton(name);    }}module.exports = Singleton;-- client.jsconst Singleton = require(&apos;./singleton&apos;);const singleton = Singleton.getInstance();const singleton2 = Singleton.getInstance(&apos;singleton2&apos;);const singleton3 = new Singleton(&apos;singleton3&apos;);const singleton4 = new Singleton(&apos;singleton4&apos;);console.log(singleton === singleton2);console.log(singleton === singleton3);console.log(singleton === singleton4);</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;单例模式（Singleton）&lt;br&gt; &lt;a href=&quot;/assets/单例模式.png&quot;&gt;&lt;img src=&quot;/assets/单例模式.png&quot; alt=&quot;单例模式&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;代码实例 &lt;a href=&quot;https:
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="设计模式" scheme="http://hi2048.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="大话设计模式" scheme="http://hi2048.github.io/tags/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>数组去重</title>
    <link href="http://hi2048.github.io/2019/02/18/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
    <id>http://hi2048.github.io/2019/02/18/数组去重/</id>
    <published>2019-02-17T16:00:00.000Z</published>
    <updated>2019-09-18T14:31:10.318Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>使用Array的filter方法</p><pre><code>const distinctFilter = (arr) =&gt; (arr.filter((item, index) =&gt; (arr.indexOf(item) === index)))</code></pre></li><li><p>使用ES6的Set</p><pre><code>const distinctSet = (arr) =&gt; (Array.from(new Set(arr)));</code></pre></li><li><p>使用Hash方法</p><pre><code>const distinctHash = (arr) =&gt; {  const hash = {};  let disArr = [];  for(let i of arr){    if(!hash[i]){      disArr.push(i);      hash[i] = [i];    }  }  return disArr;}</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用Array的filter方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const distinctFilter = (arr) =&amp;gt; (arr.filter((item, index) =&amp;gt; (arr.indexOf(item) === index)
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LRU算法</title>
    <link href="http://hi2048.github.io/2019/02/10/LRU%E7%AE%97%E6%B3%95/"/>
    <id>http://hi2048.github.io/2019/02/10/LRU算法/</id>
    <published>2019-02-09T16:00:00.000Z</published>
    <updated>2019-09-18T13:24:33.512Z</updated>
    
    <content type="html"><![CDATA[<p><strong> LRU (least recently used) 缓存机制：实现get, put方法。 </strong></p><pre><code>/** * 元素置顶 */const popItemFromArray = (arr, key) =&gt;{  arr.splice(arr.indexOf(key), 1);  arr.push(key);  return arr;}/** * 实现思路：ES6 Map [+ 有序数组（或者双向链表）] **/var LRUCache = function(capacity) {    this.cache = new Map();    this.lruArr = new Array();    this.curLen = 0;    this.capacity = capacity;};LRUCache.prototype.get = function(key) {    if(this.cache.has(key)){      const value = this.cache.get(key);      popItemFromArray(this.lruArr, key);      return value;    }    return -1;};LRUCache.prototype.lruDel = function(){  const minKey = this.lruArr.shift();  const isucc = this.cache.delete(minKey);  if(isucc){    this.curLen--;  }  return isucc;}// iorder : false descend true ascendLRUCache.prototype.sort = function(iorder) {  return this.lruArr.sort((c1, c2) =&gt; {    return c1 - c2;  });}LRUCache.prototype.put = function(key, value) {    if(this.cache.has(key)){      // pop key from lru array      popItemFromArray(this.lruArr, key);      return this.cache.set(key, value);    }    if(this.curLen === this.capacity){      this.lruDel();    }    this.curLen++;    this.lruArr.push(key);    return this.cache.set(key, value);};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; LRU (least recently used) 缓存机制：实现get, put方法。 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 元素置顶
 */
const popItemFromArray = (arr, key) =&amp;gt;{
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>迭代器模式</title>
    <link href="http://hi2048.github.io/2019/02/08/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://hi2048.github.io/2019/02/08/迭代器模式/</id>
    <published>2019-02-07T16:00:00.000Z</published>
    <updated>2019-10-23T13:01:53.620Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>迭代器模式（Iterator）<br> <a href="/assets/迭代器模式.png"><img src="/assets/迭代器模式.png" alt="迭代器模式"></a></p></li><li><p>代码实例 <a href="https://github.com/hi2048/Design-And-Code/tree/master/Design-Patterns/Iterator" title="迭代器模式" target="_blank" rel="noopener">github</a></p><pre><code>-- aggregate.jsclass Aggregate {    constructor() {        if(new.target === Aggregate)            throw new Error(`${Aggregate} cannot be initialized.`);    }    createIterator() {        throw new Error(`${this.createIterator} should be overwrite.`);    }}module.exports = Aggregate;-- iterator.jsclass Iterator {    constructor() {        if(new.target === Iterator)            throw new Error(`${Iterator} cannot be initialized.`);    }    first() {        throw new Error(`${this.first} should be overwrite.`);    }    next() {        throw new Error(`${this.next} should be overwrite.`);    }    isDone() {        throw new Error(`${this.isDone} should be overwrite.`);    }    currentItem() {        throw new Error(`${this.currentItem} should be overwrite.`);    }}module.exports = Iterator;-- concreteAggregate1.jsconst Aggregate = require(&apos;./aggregate&apos;);const ConcreteIterator = require(&apos;./concreteIterator1&apos;);class ConcreteAggregate extends Aggregate {    constructor() {        super();        this.aggregate = new Array();    }    add(item) {        this.aggregate.push(item);    }    get(index) {        return this.aggregate[index];    }    count() {        return this.aggregate.length;    }    createIterator() {        return new ConcreteIterator(this);    }}module.exports = ConcreteAggregate;-- concreteIterator1.jsconst Iterator = require(&apos;./iterator&apos;);class ConcreteIterator extends Iterator {    constructor(aggregate = {}) {        super();        this.aggregate = aggregate;        this.cur = 0;    }    first() {        return this.aggregate.get(0);    }    next() {        this.cur++;        if(this.cur &lt; this.aggregate.count()) {            return this.currentItem();        }        return undefined;    }    isDone() {        return this.cur &lt; this.aggregate.count()? false : true;    }    currentItem() {        return this.aggregate.get(this.cur);    }}module.exports = ConcreteIterator;-- concreteAggregate2.jsconst Aggregate = require(&apos;./aggregate&apos;);const ConcreteIterator2 = require(&apos;./concreteIterator2&apos;);class ConcreteAggregate2 extends Aggregate {    constructor() {        super();    }    createIterator() {        return new ConcreteIterator2(this);    }}module.exports = ConcreteAggregate2;-- concreteIterator2.jsconst Iterator = require(&apos;./iterator&apos;);class ConcreteIterator2 extends Iterator {    constructor(aggregate = {}) {        super();        this.aggregate = aggregate;        this.initAggregateIterator();        // init iterator        this.iterator = this.aggregate[Symbol.iterator]();    }    initAggregateIterator() {        this.aggregate[Symbol.iterator] = function() {            const aggregate = this;            const keys = Object.keys(aggregate);            let curIndex = 0;            return {                first: function() {                    return aggregate[keys[curIndex]];                },                next: function () {                    curIndex++;                    if(curIndex &lt; keys.length) {                        return this.currentItem();                    }                    return undefined;                },                isDone: function() {                    return curIndex &lt; keys.length? false : true;                },                currentItem: function() {                    return aggregate[keys[curIndex]];                }            }        }    }    first() {        return this.iterator.first();    }    next() {        return this.iterator.next();    }    isDone() {        return this.iterator.isDone();    }    currentItem() {        return this.iterator.currentItem();    }}module.exports = ConcreteIterator2;-- concreteAggregate3.jsconst Aggregate = require(&apos;./aggregate&apos;);const ConcreteIterator3 = require(&apos;./concreteIterator3&apos;);class ConcreteAggregate3 extends Aggregate {    constructor() {        super();    }    createIterator() {        return new ConcreteIterator3(this);    }}module.exports = ConcreteAggregate3;-- concreteIterator3.jsconst Iterator = require(&apos;./iterator&apos;);class ConcreteIterator3 extends Iterator {    constructor(aggregate = {}) {        super();        this.aggregate = aggregate;        this.initAggregateIterator();        // init iterator        this.iterator = this.aggregate[Symbol.iterator]();    }    initAggregateIterator() {        this.aggregate[Symbol.iterator] = function *() {            const aggregateValues = Object.values(this);            for(let value of aggregateValues) {                yield value;            }        }    }    next() {        return this.iterator.next();    }}module.exports = ConcreteIterator3;-- client.jsconst ConcreteAggregate1 = require(&apos;./concreteAggregate1&apos;);const ConcreteAggregate2  = require(&apos;./concreteAggregate2&apos;);const ConcreteAggregate3 = require(&apos;./concreteAggregate3&apos;);const concreteAggregate1 = new ConcreteAggregate1();concreteAggregate1.add(&apos;a&apos;);concreteAggregate1.add(&apos;b&apos;);concreteAggregate1.add(&apos;c&apos;);console.log(&apos;Iterator dp1: &apos;);const iterator1 = concreteAggregate1.createIterator();let iteratorValueDP1 = iterator1.first();while(!iterator1.isDone()) {    console.log(`${iteratorValueDP1} `);    iteratorValueDP1 = iterator1.next();}console.log(&apos;------&apos;);console.log(&apos;Iterator dp2: &apos;);const concreteAggregate2 = new ConcreteAggregate2();concreteAggregate2[&apos;0&apos;] = &apos;a&apos;;concreteAggregate2[&apos;1&apos;] = &apos;b&apos;;concreteAggregate2[&apos;2&apos;] = &apos;c&apos;;const iterator2 = concreteAggregate2.createIterator();let iteratorValueDP2 = iterator2.first();while(!iterator2.isDone()) {    console.log(`${iteratorValueDP2} `);    iteratorValueDP2 = iterator2.next();}console.log(&apos;------&apos;);console.log(&apos;Iterator dp3: &apos;);const concreteAggregate3 = new ConcreteAggregate3();concreteAggregate3[1] = &apos;a&apos;;concreteAggregate3[2] = &apos;b&apos;;concreteAggregate3[3] = &apos;c&apos;;const iterator3 = concreteAggregate3.createIterator();let iteratorValueDP3 = iterator3.next();while(!iteratorValueDP3.done) {    console.log(`${iteratorValueDP3.value} `);    iteratorValueDP3 = iterator3.next();}console.log(&apos;------&apos;);-- concreteAggregate4.jsconst Aggregate = require(&apos;./aggregate&apos;);const ConcreteIterator4 = require(&apos;./concreteIterator4&apos;);class ConcreteAggregate4 extends Aggregate {    constructor() {        super();        this.item = new Array();        // super array simulate indexer        this.extend(this.item, this, Reflect.getPrototypeOf(this));        return this.item;    }    extend(target, ...origins) {        for(let origin of origins) {            const keys = Reflect.ownKeys(origin);            for(let key of keys) {                target[key] = origin[key];            }        }    }    createIterator() {        return new ConcreteIterator4(this.item);    }}module.exports = ConcreteAggregate4;-- concreteIterator4.jsconst Iterator = require(&apos;./iterator&apos;);class ConcreteIterator4 extends Iterator {    constructor(aggregate = []) {        super();        this.aggregate = aggregate;        this.curIndex = 0;    }    first() {        return this.aggregate[this.curIndex];    }    next() {        let ret = null;        this.curIndex ++;        if(this.curIndex &lt; this.aggregate.length) {            ret = this.currentItem();        }        return ret;    }    isDone() {        return this.curIndex &lt; this.aggregate.length?false : true;    }    currentItem() {        return this.aggregate[this.curIndex];    }}module.exports = ConcreteIterator4;-- client2.jsconst ConcreteAggregate4 = require(&apos;./concreteAggregate4&apos;);const concreteAggregate4 = new ConcreteAggregate4();concreteAggregate4[0] = &apos;a&apos;;concreteAggregate4[1] = &apos;b&apos;;concreteAggregate4[2] = &apos;c&apos;;const iterator = concreteAggregate4.createIterator();let iteratorValue = iterator.first();while(!iterator.isDone()) {    console.log(`${iteratorValue} `);    iteratorValue = iterator.next();}console.log(&apos;------&apos;);</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;迭代器模式（Iterator）&lt;br&gt; &lt;a href=&quot;/assets/迭代器模式.png&quot;&gt;&lt;img src=&quot;/assets/迭代器模式.png&quot; alt=&quot;迭代器模式&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;代码实例 &lt;a href=&quot;htt
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="设计模式" scheme="http://hi2048.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="大话设计模式" scheme="http://hi2048.github.io/tags/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Heap实现</title>
    <link href="http://hi2048.github.io/2019/01/19/Heap%E5%AE%9E%E7%8E%B0/"/>
    <id>http://hi2048.github.io/2019/01/19/Heap实现/</id>
    <published>2019-01-18T16:00:00.000Z</published>
    <updated>2019-09-19T11:46:09.241Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 小根堆实现，大根堆类似 </strong></p><pre><code>// 通过 up down方法实现 堆的有效性class Heap {  constructor(){    this.heap = new Array();  }  swap(id1, id2) {    let temp = this.heap[id1];    this.heap[id1] = this.heap[id2];    this.heap[id2] = temp;  }  up(id) {    let pid = Math.floor((id - 1) / 2);    if(id !== 0 &amp;&amp; this.heap[pid] &gt; this.heap[id]){      this.swap(pid, id);      this.up(pid);    }  }  down(id) {    let leftChildId = id * 2 + 1;    let rightChildId = id * 2 + 2;    let len = this.heap.length;    if(leftChildId &lt; len &amp;&amp; this.heap[leftChildId] &lt; this.heap[id]){      this.swap(leftChildId, id);      this.down(leftChildId);    }    if(rightChildId &lt; len &amp;&amp; this.heap[rightChildId] &lt; this.heap[id]){      this.swap(rightChildId, id);      this.down(rightChildId);    }  }  insert(x) {    this.heap.push(x);    this.up(this.heap.length - 1);  }  remove(){    this.swap(0, this.heap.length - 1);    const ret = this.heap.pop();    this.down(0);    return ret;  }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 小根堆实现，大根堆类似 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 通过 up down方法实现 堆的有效性
class Heap {
  constructor(){
    this.heap = new Array();
  }

  s
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>组合模式</title>
    <link href="http://hi2048.github.io/2019/01/05/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>http://hi2048.github.io/2019/01/05/组合模式/</id>
    <published>2019-01-04T16:00:00.000Z</published>
    <updated>2019-10-21T13:34:04.669Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>组合模式（Composite）<br> <a href="/assets/组合模式.png"><img src="/assets/组合模式.png" alt="组合模式"></a></p></li><li><p>代码实例 <a href="https://github.com/hi2048/Design-And-Code/tree/master/Design-Patterns/Composite" title="组合模式" target="_blank" rel="noopener">github</a></p><pre><code>-- component.jsclass Component {    constructor(name = &apos;Component&apos;) {        if(new.target === Component)            throw new Error(`${Component} cannot be initialized.`);        this.name = name;    }    add(c) {        throw new Error(`${this.add} should be overwrite.`);    }    remove(c) {        throw new Error(`${this.remove} should be overwrite.`);    }    display() {        throw new Error(`${this.display} should be overwrite.`);    }}module.exports = Component;-- composite.jsconst Component = require(&apos;./component&apos;);class Composite extends Component {    constructor(name) {        super(name);        this.components = new Set();    }    add(c) {        this.components.add(c);    }    remove(c) {        this.components.delete(c);    }    display(depth = 1) {        console.log(`${&apos;-&apos;.repeat(depth)} ${this.name}`);        this.components.forEach((component) =&gt; (component.display(depth + 2)));    }}module.exports = Composite;-- leaf.jsconst Component = require(&apos;./component&apos;);class Leaf extends Component {    constructor(name) {        super(name);    }    display(depth = 1) {        console.log(`${&apos;-&apos;.repeat(depth)} ${this.name}`);    }}module.exports = Leaf;-- client.jsconst Composite = require(&apos;./composite&apos;);const Leaf = require(&apos;./leaf&apos;);const root = new Composite(&apos;Root&apos;);root.add(new Leaf(&apos;Leaf11&apos;));root.add(new Leaf(&apos;Leaf12&apos;));const composite1 = new Composite(&apos;Composite11&apos;);root.add(composite1);const leaf21 = new Leaf(&apos;Leaf21&apos;);composite1.add(leaf21);const composite2 = new Composite(&apos;Composite21&apos;);composite1.add(composite2);composite1.add(new Leaf(&apos;Leaf22&apos;));composite2.add(new Leaf(&apos;Leaf31&apos;));root.add(new Leaf(&apos;Leaf13&apos;));const leaf14 = new Leaf(&apos;Leaf14&apos;);root.add(leaf14);composite1.remove(leaf21);root.display(2);</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;组合模式（Composite）&lt;br&gt; &lt;a href=&quot;/assets/组合模式.png&quot;&gt;&lt;img src=&quot;/assets/组合模式.png&quot; alt=&quot;组合模式&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;代码实例 &lt;a href=&quot;https:
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="设计模式" scheme="http://hi2048.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="大话设计模式" scheme="http://hi2048.github.io/tags/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>React16为什么更新</title>
    <link href="http://hi2048.github.io/2018/12/11/React16%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9B%B4%E6%96%B0/"/>
    <id>http://hi2048.github.io/2018/12/11/React16为什么更新/</id>
    <published>2018-12-10T16:00:00.000Z</published>
    <updated>2019-09-11T09:35:37.523Z</updated>
    
    <content type="html"><![CDATA[<p><strong> React16更新的根本原因是提升用户体验，解决同步更新带来的界面卡顿问题。 </strong></p><ol><li><p>React16之前的版本中，更新过程是同步的，为什么会导致界面卡顿？<br><strong> 大量的同步计算任务阻塞了浏览器的UI渲染 </strong></p><ul><li>JavaScript是单线程的。</li><li>JavaScript运算、页面布局和页面绘制都是运行在浏览器的主线程当中，他们之间是互斥的关系。</li><li>React加载或者更新时，会调用生命周期函数，计算和对比Virtual DOM，更新UI，整个过程是同步的，如果需要更新的组件数量过大或者计算过于复杂，就会出现用户卡顿的体验。</li></ul></li><li><p>React是如何解决上述问题的？</p><p><strong> 引入了异步渲染(Async Rendering)机制 </strong></p><p>采用分片的思路，提出了Fiber的解决方案。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; React16更新的根本原因是提升用户体验，解决同步更新带来的界面卡顿问题。 &lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;React16之前的版本中，更新过程是同步的，为什么会导致界面卡顿？&lt;br&gt;&lt;strong&gt; 大量的同步计算任务阻塞了浏览器的
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="React" scheme="http://hi2048.github.io/tags/React/"/>
    
  </entry>
  
</feed>
