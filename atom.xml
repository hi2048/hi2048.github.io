<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>苏小蜂的个人博客</title>
  
  <subtitle>放慢脚步，享受生活！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hi2048.github.io/"/>
  <updated>2019-09-05T14:59:46.811Z</updated>
  <id>http://hi2048.github.io/</id>
  
  <author>
    <name>Jsu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>状态管理</title>
    <link href="http://hi2048.github.io/2019/09/02/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    <id>http://hi2048.github.io/2019/09/02/状态管理/</id>
    <published>2019-09-01T16:00:00.000Z</published>
    <updated>2019-09-05T14:59:46.811Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>vuex</p><ul><li>vuex 是一个专门为vue.js应用程序开发的状态管理模式。</li></ul></li><li><p>状态自管理应用</p><ul><li>state, view, actions<br><a href="/assets/vue-flow.png"><img src="/assets/vue-flow.png" alt="vue-flow"></a></li></ul></li><li><p>vuex应用</p><p><a href="/assets/vuex.png"><img src="/assets/vuex.png" alt="vuex"></a></p></li><li><p>为什么引入状态管理模式</p><ul><li>多个视图依赖于同一状态。</li><li>来自不同视图的行为需要变更同一状态。</li></ul><p><strong> 传统的vue在解决上述问题时，会导致代码复杂与难于维护，vuex采用全局单例模式管理，可以使得代码更结构化且易维护。 </strong></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;vuex&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vuex 是一个专门为vue.js应用程序开发的状态管理模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;状态自管理应用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;state, view, actions&lt;br&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="React" scheme="http://hi2048.github.io/tags/React/"/>
    
      <category term="vue" scheme="http://hi2048.github.io/tags/vue/"/>
    
      <category term="vuex" scheme="http://hi2048.github.io/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>Vue生命周期</title>
    <link href="http://hi2048.github.io/2019/08/02/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://hi2048.github.io/2019/08/02/Vue生命周期/</id>
    <published>2019-08-01T16:00:00.000Z</published>
    <updated>2019-09-05T14:58:52.372Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>Vue实例有一个完整的生命周期，也就是说从开始创建、初始化数据、编译模板、挂在DOM、渲染-更新-渲染、卸载等一系列过程，我们成为Vue 实例的生命周期，钩子就是在某个阶段给你一个做某些处理的机会。</p></li><li><p>Vue生命周期钩子</p><ul><li>beforeCreate</li><li>created</li><li>beforeMount</li><li>mounted</li><li>beforeUpdate</li><li>updated</li><li>beforeDestroy</li><li>destroyed</li></ul></li></ol><p><a href="/assets/lifecycle-vue.png"><img src="/assets/lifecycle-vue.png" alt="vue-生命周期"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;Vue实例有一个完整的生命周期，也就是说从开始创建、初始化数据、编译模板、挂在DOM、渲染-更新-渲染、卸载等一系列过程，我们成为Vue 实例的生命周期，钩子就是在某个阶段给你一个做某些处理的机会。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Vue生命周期钩子&lt;/
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="vue" scheme="http://hi2048.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>compose</title>
    <link href="http://hi2048.github.io/2019/06/10/compose/"/>
    <id>http://hi2048.github.io/2019/06/10/compose/</id>
    <published>2019-06-09T16:00:00.000Z</published>
    <updated>2019-09-10T15:47:32.356Z</updated>
    
    <content type="html"><![CDATA[<p><strong> JavaScript函数式编程：compose方法 </strong></p><pre><code>const compose = (arr) =&gt; {    return arr.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))}const composeT = (arr) =&gt; {  return arr.reduce((a, b) =&gt; {    return (...args) =&gt; {      console.log(`${a.name}(${b.name}(${args}))`);      return a(b(...args));    }  }, ()=&gt;{})}const a = (a, b) =&gt; {console.log(&quot;a: &quot;, a); return a;}const b = (a, b) =&gt; {console.log(&quot;b: &quot;, a); return a;}const c = (a, b) =&gt; {console.log(&quot;c: &quot;, a, b); return [a, b];}composeT([a,b,c])(&apos;1&apos;,&apos;2&apos;)(c(1,2))c:  1 2(b(1,2))b:  [ &apos;1&apos;, &apos;2&apos; ](a(1,2))a:  [ &apos;1&apos;, &apos;2&apos; ]</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; JavaScript函数式编程：compose方法 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const compose = (arr) =&amp;gt; {
    return arr.reduce((a, b) =&amp;gt; (...args) =&amp;
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>闭包</title>
    <link href="http://hi2048.github.io/2019/06/08/%E9%97%AD%E5%8C%85/"/>
    <id>http://hi2048.github.io/2019/06/08/闭包/</id>
    <published>2019-06-07T16:00:00.000Z</published>
    <updated>2019-09-05T15:00:17.012Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>闭包概念</p><ul><li>能够读取其他函数内部变量的函数。</li><li><p>或简单理解为定义在一个函数内部的函数，内部函数持有外部函数内变量的引用。</p><pre><code>function outFunc(){  var outAttr = &quot;outAttr&quot;;  function innerFunc(){    console.log(outAttr);  }  return innerFunc;}var myFunc = outFunc(); // myFunc为一个引入outAttr的闭包</code></pre></li></ul></li><li><p>为什么有闭包</p><ul><li>避免污染全局变量</li><li>利于代码的封装</li><li>使用时注意内在泄露</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;闭包概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能够读取其他函数内部变量的函数。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;或简单理解为定义在一个函数内部的函数，内部函数持有外部函数内变量的引用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function outFunc(){
  var out
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript类与继承</title>
    <link href="http://hi2048.github.io/2019/05/05/JavaScript%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF/"/>
    <id>http://hi2048.github.io/2019/05/05/JavaScript类与继承/</id>
    <published>2019-05-04T16:00:00.000Z</published>
    <updated>2019-09-05T15:00:02.295Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>定义类</p><pre><code>//定义属性function MyClass(attr1, attr2) {  this.attr1 = attr1;  this.attr2 = attr2;}//定义方法MyClass.prototype = {  constructor : MyClass,  myFunc : function() {      console.log(this.attr1);  }};</code></pre></li><li><p>继承类</p><pre><code>//定义父类function SuperClass(attr) {    this.attr = attr;}SuperClass.prototype = {    superFunc : function() {        console.log(this.attr);    }};//继承父类function SubClass(attr, subAttr) {    //继承属性    SuperClass.call(this, attr);    this.subAttr = subAttr;}//继承方法SubClass.prototype = new SuperClass();</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;定义类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//定义属性
function MyClass(attr1, attr2) {
  this.attr1 = attr1;
  this.attr2 = attr2;
}

//定义方法
MyClass.prototy
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>React16为什么更新</title>
    <link href="http://hi2048.github.io/2018/12/11/React16%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9B%B4%E6%96%B0/"/>
    <id>http://hi2048.github.io/2018/12/11/React16为什么更新/</id>
    <published>2018-12-10T16:00:00.000Z</published>
    <updated>2019-09-11T09:35:37.523Z</updated>
    
    <content type="html"><![CDATA[<p><strong> React16更新的根本原因是提升用户体验，解决同步更新带来的界面卡顿问题。 </strong></p><ol><li><p>React16之前的版本中，更新过程是同步的，为什么会导致界面卡顿？<br><strong> 大量的同步计算任务阻塞了浏览器的UI渲染 </strong></p><ul><li>JavaScript是单线程的。</li><li>JavaScript运算、页面布局和页面绘制都是运行在浏览器的主线程当中，他们之间是互斥的关系。</li><li>React加载或者更新时，会调用生命周期函数，计算和对比Virtual DOM，更新UI，整个过程是同步的，如果需要更新的组件数量过大或者计算过于复杂，就会出现用户卡顿的体验。</li></ul></li><li><p>React是如何解决上述问题的？</p><p><strong> 引入了异步渲染(Async Rendering)机制 </strong></p><p>采用分片的思路，提出了Fiber的解决方案。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; React16更新的根本原因是提升用户体验，解决同步更新带来的界面卡顿问题。 &lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;React16之前的版本中，更新过程是同步的，为什么会导致界面卡顿？&lt;br&gt;&lt;strong&gt; 大量的同步计算任务阻塞了浏览器的
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="React" scheme="http://hi2048.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>快乐数</title>
    <link href="http://hi2048.github.io/2018/12/08/%E5%BF%AB%E4%B9%90%E6%95%B0/"/>
    <id>http://hi2048.github.io/2018/12/08/快乐数/</id>
    <published>2018-12-07T16:00:00.000Z</published>
    <updated>2019-09-08T13:53:44.932Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>快乐数：<br>正整数，求出每个位置的数字平方和，重复此过程，可以得到数字1，则为快乐数。<br>求取平方和过程中如果重复之前的平方和，则非快乐数。</p><pre><code>var getSquaresSum = function(n){    var ss = n.toString().split(&apos;&apos;);    return ss.reduce(function(count, s){        return count + Math.pow(parseInt(s), 2);    }, 0)}var isHappy = function(n) {    var rets = [n];    var count = n;    while(true){        count = getSquaresSum(count);        if(count === 1){            return true;        }        var index = rets.indexOf(count);        if(index !== -1){            return false;        }        rets.push(count);    }};</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;快乐数：&lt;br&gt;正整数，求出每个位置的数字平方和，重复此过程，可以得到数字1，则为快乐数。&lt;br&gt;求取平方和过程中如果重复之前的平方和，则非快乐数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var getSquaresSum = function(n){
    v
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>React生命周期</title>
    <link href="http://hi2048.github.io/2018/12/02/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://hi2048.github.io/2018/12/02/React生命周期/</id>
    <published>2018-12-01T16:00:00.000Z</published>
    <updated>2019-09-11T08:42:28.187Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>React生命周期 - React16前</p><p><strong> React生命周期总体上分为4个阶段：初始化阶段（initialization），挂载阶段（Mounting），更新阶段（update），卸载阶段（Unmount） </strong></p><ul><li><p>initialization：初始化props和state。<br>constructor</p></li><li><p>mounting：执行一次。<br>componentWillMount, render, componentDidMount</p></li><li><p>update：setState引起的state更新或者父组件重新render引起的props更新。<br>componentWillReceiveProps, shouldComponentUpdate, componentWillUpdate, render, componentDidUpdate</p></li><li><p>unmount: 执行一次<br>componentWillUnmount</p></li></ul><p><a href="/assets/React-lifecycle-before.png"><img src="/assets/React-lifecycle-before.png" alt="React生命周期"></a></p></li></ol><ol start="2"><li><p>React生命周期</p><ul><li>引入了两个新的生命周期函数<br>getDerivedStateFromProps，getSnapshotBeforeUpdate</li></ul><p><a href="/assets/React-lifecycle.png"><img src="/assets/React-lifecycle.png" alt="React16生命周期"></a></p></li><li><p>为什么会变化</p><p><strong> React16推出Fiber，如果开启async rendering，会导致render函数之前的所有函数，有可能被执行多次。 </strong></p><ul><li>componentWillMount</li><li>componentWillReceiveProps</li><li>componentWillUpdate</li><li>shouldComponentUpdate</li></ul><p>其中shouldComponentUpdate为纯函数，返回Boolean，没有副作用，而其他三个函数，开发者如果在里面执行有副作用的操作，如Ajax等，会产生不可预期的结果。所以其余三个统一被getDerivedStateFromProps替代，并且<strong> 采用静态函数，用禁止来替代以前的建议 </strong>。</p><p>react的component中static属性，里面放函数，官方解释：<br><strong> you can run them before any component instances are created, and the methods do not have access to the props or state of your components. </strong></p><p><strong> 静态函数getDerivedStateFromProps来取代被deprecate的几个生命周期函数，就是强制开发者在render之前只做无副作用的操作，而且能做的操作局限在根据props和state决定新的state。 </strong></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;React生命周期 - React16前&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; React生命周期总体上分为4个阶段：初始化阶段（initialization），挂载阶段（Mounting），更新阶段（update），卸载阶段（Unmount） &lt;/strong
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="React" scheme="http://hi2048.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>秋</title>
    <link href="http://hi2048.github.io/2018/10/05/%E7%A7%8B/"/>
    <id>http://hi2048.github.io/2018/10/05/秋/</id>
    <published>2018-10-04T16:00:00.000Z</published>
    <updated>2019-09-05T14:51:31.779Z</updated>
    
    <content type="html"><![CDATA[<p>秋风送爽，炎暑渐消，此时宜甘味以益气，进补应坚持“燥者濡之”，“上燥清气，中燥增液，下燥养血。”同时应早睡早起，早餐宜营养丰富，以预防抑郁症，保持乐观轻松心情。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;秋风送爽，炎暑渐消，此时宜甘味以益气，进补应坚持“燥者濡之”，“上燥清气，中燥增液，下燥养血。”同时应早睡早起，早餐宜营养丰富，以预防抑郁症，保持乐观轻松心情。&lt;/p&gt;

      
    
    </summary>
    
      <category term="未分类" scheme="http://hi2048.github.io/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>Swagger</title>
    <link href="http://hi2048.github.io/2018/09/12/Swagger/"/>
    <id>http://hi2048.github.io/2018/09/12/Swagger/</id>
    <published>2018-09-11T16:00:00.000Z</published>
    <updated>2019-09-06T06:24:46.889Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>Swagger解决了什么问题？<br><strong> 接口文档的一致性与可维护性 </strong></p></li><li><p>Swagger是什么？</p><ul><li>通过自己定义的描述文件（yml或json格式），更新接口文档，以及生成各端代码.</li></ul></li><li><p>Swagger可以做什么？</p><ul><li>可以做到生成各种格式的接口文档，生成多种语言的客户端和服务端的代码，以及在线接口调试页面等等。</li></ul></li><li><p>Springfox-swagger</p><ul><li>通过扫描代码去生成这个描述文件</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;Swagger解决了什么问题？&lt;br&gt;&lt;strong&gt; 接口文档的一致性与可维护性 &lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swagger是什么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过自己定义的描述文件（yml或json格式），更新接口文档，以及生
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="Spring" scheme="http://hi2048.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Fiber</title>
    <link href="http://hi2048.github.io/2018/06/11/Fiber/"/>
    <id>http://hi2048.github.io/2018/06/11/Fiber/</id>
    <published>2018-06-10T16:00:00.000Z</published>
    <updated>2019-09-11T10:00:46.794Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>什么是Fiber<br><strong> React Fibler 采用分片的思路实现UI的异步渲染。 </strong><br>React Fiber把更新过程碎片化，分成很多小片，当分配给小片的时间用尽时，则将控制权交出，如果有优先级更高的任务，就开始做新的任务，没有就断续原来的更新。</p></li><li><p>Fiber运行原理<br><strong> React Fiber一个更新过程被分为两个阶段(Phase)：第一个阶段Reconciliation Phase和第二阶段Commit Phase。 </strong></p><ul><li><p>Reconciliation Phase， 可以被打断，计算与对比虚拟DOM，找出需要更新的DOM<br>componentWillMount<br>componentWillReceiveProps<br>shouldComponentUpdate<br>componentWillUpdate</p></li><li><p>Commit Phase， 无法打断，更新DOM<br>componentDidMount<br>componentDidUpdate<br>componentWillUnmount</p></li></ul></li></ol><ol start="3"><li><p>React16前的生命周期函数componentWillUpdate等，为什么会多次执行？</p><ul><li>requestIdleCallback</li><li>cancelIdleCallback</li></ul><p><strong> 异步渲染的时候，会调用requestIdleCallback API，在回调函数中可以获得当前callback参数（也就是fiber的分片任务），包括执行时间，如果时间不够，分片任务会被打断（使用cancelIdleCallback API），再次执行则会在空闲时重新执行。 </strong></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;什么是Fiber&lt;br&gt;&lt;strong&gt; React Fibler 采用分片的思路实现UI的异步渲染。 &lt;/strong&gt;&lt;br&gt;React Fiber把更新过程碎片化，分成很多小片，当分配给小片的时间用尽时，则将控制权交出，如果有优先级更高的任务，就开始
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="React" scheme="http://hi2048.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>同构字符串</title>
    <link href="http://hi2048.github.io/2018/05/09/%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://hi2048.github.io/2018/05/09/同构字符串/</id>
    <published>2018-05-08T16:00:00.000Z</published>
    <updated>2019-09-09T14:36:53.724Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>判断两个长度相同的字符串是否是同构字符串。同构字符串为将一个字符串中的相同字符进行替换可以得到另一个字符串。<br><strong> 同构代表两个字符串中每个位置上字符在自身第一次出现的索引相同 </strong></p><pre><code>var isPositionSame = function(ss, ts, index){    var sIndex = ss.indexOf(ss[index]);    var tIndex = ts.indexOf(ts[index]);    return sIndex === tIndex;}var isIsomorphic = function(s, t) {    var ss = s.split(&apos;&apos;);    var ts = t.split(&apos;&apos;);    for(var i = 0, len = ts.length; i &lt; len; i++){        if(!isPositionSame(ss, ts, i)){            return false;        }    }    return true;};</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;判断两个长度相同的字符串是否是同构字符串。同构字符串为将一个字符串中的相同字符进行替换可以得到另一个字符串。&lt;br&gt;&lt;strong&gt; 同构代表两个字符串中每个位置上字符在自身第一次出现的索引相同 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var i
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>twoSum</title>
    <link href="http://hi2048.github.io/2018/01/11/twoSum/"/>
    <id>http://hi2048.github.io/2018/01/11/twoSum/</id>
    <published>2018-01-10T16:00:00.000Z</published>
    <updated>2019-09-10T16:00:16.268Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 求数组中两个数值之和为指定值的下标，可以采用hash来解决 </strong></p><pre><code>const twoSum = (nums, target) =&gt; {  let hash = {};  for(let i = 0, len = nums.length; i &lt; len; i++){    if(typeof hash[target - nums[i]] !== &apos;undefined&apos;){      return [hash[target - nums[i]], i];    }    hash[nums[i]] = i;  }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 求数组中两个数值之和为指定值的下标，可以采用hash来解决 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const twoSum = (nums, target) =&amp;gt; {
  let hash = {};
  for(let i = 0, l
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>arrayTwoSum</title>
    <link href="http://hi2048.github.io/2018/01/10/arrayTwoSum/"/>
    <id>http://hi2048.github.io/2018/01/10/arrayTwoSum/</id>
    <published>2018-01-09T16:00:00.000Z</published>
    <updated>2019-09-10T15:52:00.476Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 求数组下标，下标区间数值之和为指定值 </strong></p><pre><code>const twoSum = (nums, target) =&gt;{    let count = 0;    for(let i = 0, len = nums.length; i &lt; len;){        count = nums[i];        if(count &gt; target){            i++        } else if(count === target){            return [i, i];        } else{          for(let j = i + 1; j &lt; len; j++){              count += nums[j];              if(count &gt; target){                  i++;                  break;              } else if(count === target){                  return [i, j];              }          }        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 求数组下标，下标区间数值之和为指定值 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const twoSum = (nums, target) =&amp;gt;{
    let count = 0;

    for(let i = 0, len = nu
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>移除链表元素</title>
    <link href="http://hi2048.github.io/2017/12/10/%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
    <id>http://hi2048.github.io/2017/12/10/移除链表元素/</id>
    <published>2017-12-09T16:00:00.000Z</published>
    <updated>2019-09-09T03:41:44.275Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>删除单向链表中值为 val 的所有节点。</p><p><strong>思路：可以添加指向头结节的Head*节点，然后进行删除操作。</strong></p><pre><code>function removeLinkNodes(head, val) {  if(!head) return null;  var prevElement = {    this.next = head;  }  var sPointer = prevElement;  while(sPointer.next){    if(sPointer.next.val === val){      sPointer.next = sPointer.next.next;    } else{      sPointer = sPointer.next;    }  }  return prevElement.next;};</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;删除单向链表中值为 val 的所有节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路：可以添加指向头结节的Head*节点，然后进行删除操作。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function removeLinkNodes(head, val) {
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的循环中断</title>
    <link href="http://hi2048.github.io/2017/11/10/JavaScript%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%B8%AD%E6%96%AD/"/>
    <id>http://hi2048.github.io/2017/11/10/JavaScript中的循环中断/</id>
    <published>2017-11-09T16:00:00.000Z</published>
    <updated>2019-09-10T15:25:41.717Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 循环中断break, continue, return 比较 </strong></p><pre><code>// break continue return// break跳出当前循环 continue结束当前条件 return 返回函数值console.log(&quot;normal: &quot;)for(var i = 0; i &lt; 2; i++){  console.log(`${i} `);  for(var j = 3; j &lt; 6; j++){    console.log(`${j} `);  }}console.log(&quot;break: &quot;)for(var i = 0; i &lt; 2; i++){  console.log(`${i} `);  for(var j = 3; j &lt; 6; j++){    if(j === 4) break;    console.log(`${j} `);  }}console.log(&quot;continue: &quot;)for(var i = 0; i &lt; 2; i++){  console.log(`${i} `);  for(var j = 3; j &lt; 6; j++){    if(j === 4) continue;    console.log(`${j} `);  }}console.log(&quot;return: &quot;)for(var i = 0; i &lt; 2; i++){  console.log(`${i} `);  for(var j = 3; j &lt; 6; j++){    if(j === 4){      return;    }    console.log(`${j} `);  }}normal:03451345 break:0313continue:035135return:03</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 循环中断break, continue, return 比较 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// break continue return
// break跳出当前循环 continue结束当前条件 return 返回函数值
cons
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>js笔记</title>
    <link href="http://hi2048.github.io/2017/09/01/js%E7%AC%94%E8%AE%B0/"/>
    <id>http://hi2048.github.io/2017/09/01/js笔记/</id>
    <published>2017-09-01T00:00:00.000Z</published>
    <updated>2019-09-05T15:00:49.612Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>JS基本数据类型：Number、String 、Boolean 、Null、Undefined</p></li><li><p>null，undefined的区别？</p><ul><li><p>null表示一个对象被定义了，但存放了空指针，转换为数值时为0。</p></li><li><p>undefined表示声明的变量未初始化，转换为数值时为NAN。</p><p>typeof(null) – object;<br>typeof(undefined) – undefined</p></li></ul></li><li><p>同源<br> 要同时满足以下3个条件，才能叫同源：</p><p> 协议相同<br> 端口相同<br> 主机相同</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;JS基本数据类型：Number、String 、Boolean 、Null、Undefined&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;null，undefined的区别？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;null表示一个对象被定义了，但存放了空指针，转换为数值
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CD数量</title>
    <link href="http://hi2048.github.io/2017/05/10/CD%E6%95%B0%E9%87%8F/"/>
    <id>http://hi2048.github.io/2017/05/10/CD数量/</id>
    <published>2017-05-09T16:00:00.000Z</published>
    <updated>2019-09-10T15:35:24.506Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 你作为一名出道的歌手终于要出自己的第一份专辑了，你计划收录 n 首歌而且每首歌的长度都是 s 秒，每首歌必须完整地收录于一张 CD 当中。每张 CD 的容量长度都是 L 秒，而且你至少得保证同一张 CD 内相邻两首歌中间至少要隔 1 秒。为了辟邪，你决定任意一张 CD 内的歌数不能被 13 这个数字整除，那么请问你出这张专辑至少需要多少张 CD ？</strong></p><p><strong> 需要考虑剩余为13倍数的情况，每张歌曲数量可以通过计算得来。 </strong></p><pre><code>function getCDCount(n, s, l){  //计算每张CD歌曲数量  var countPerCD = Math.floor((l + 1) / (s + 1));  countPerCD = countPerCD &gt; n?n : countPerCD;  if(countPerCD % 13 === 0){      countPerCD --;  }  var count = n / countPerCD;  count = Math.ceil(count);  //最后剩余数量为13的倍数且比每张少1，则总CD需要+1  var leftCount = n % countPerCD;  if(leftCount !== 0 &amp;&amp; leftCount % 13 === 0 &amp;&amp; leftCount === countPerCD - 1){      count ++;  }  console.log(count);  return count;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 你作为一名出道的歌手终于要出自己的第一份专辑了，你计划收录 n 首歌而且每首歌的长度都是 s 秒，每首歌必须完整地收录于一张 CD 当中。每张 CD 的容量长度都是 L 秒，而且你至少得保证同一张 CD 内相邻两首歌中间至少要隔 1 秒。为了辟邪，你决定任
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>self-introduction</title>
    <link href="http://hi2048.github.io/2017/01/21/self-introduction/"/>
    <id>http://hi2048.github.io/2017/01/21/self-introduction/</id>
    <published>2017-01-20T16:00:00.000Z</published>
    <updated>2019-09-11T04:12:27.956Z</updated>
    
    <content type="html"><![CDATA[<p>Hi, I am Su Jiefeng. I obtained my master degree in computer science in Northwest Univercity.</p><p>During my performance period at HW company, I utilized my skills to complete web projects and increase the working efficiency of our team with user interface greatly as a front-end engineer.</p><p>The reason why I choosed this position is that I’m really impressed by the things you do and also I want to challenge and improve myself.</p><p>As a self-motivated persion, I’m sure I can be a great asset to your group.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Hi, I am Su Jiefeng. I obtained my master degree in computer science in Northwest Univercity.&lt;/p&gt;
&lt;p&gt;During my performance period at HW c
      
    
    </summary>
    
      <category term="未分类" scheme="http://hi2048.github.io/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>reduce方法</title>
    <link href="http://hi2048.github.io/2017/01/10/reduce%E6%96%B9%E6%B3%95/"/>
    <id>http://hi2048.github.io/2017/01/10/reduce方法/</id>
    <published>2017-01-09T16:00:00.000Z</published>
    <updated>2019-09-10T15:41:06.816Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 数组reduce方法 </strong></p><pre><code>// reduce a,b传入初始值则 b为数组第1个值，否则a为第1个，b为第2个，第二次运行则a为上一次的数据，b为第3个值//array.reduce(function(total, currentValue, currentIndex, arr), initialValue)[1,2,3,4,5].reduce(function(a,b){  console.log(`${a}:${b}:${a + b}`)  return a+b;}, 0);// 0:1:1// 1:2:3// 3:3:6// 6:4:10// 10:5:15[1,2,3,4,5].reduce(function(a,b){  console.log(`${a}:${b}:${a + b}`)  return a+b;});// 1:2:3// 3:3:6// 6:4:10// 10:5:15</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 数组reduce方法 &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// reduce a,b传入初始值则 b为数组第1个值，否则a为第1个，b为第2个，第二次运行则a为上一次的数据，b为第3个值
//array.reduce(function(tot
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
