<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>苏小蜂的个人博客</title>
  
  <subtitle>放慢脚步，享受生活！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hi2048.github.io/"/>
  <updated>2021-11-10T04:42:03.212Z</updated>
  <id>http://hi2048.github.io/</id>
  
  <author>
    <name>Jsu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>study notes</title>
    <link href="http://hi2048.github.io/2021/11/01/study-notes-english/"/>
    <id>http://hi2048.github.io/2021/11/01/study-notes-english/</id>
    <published>2021-10-31T16:00:00.000Z</published>
    <updated>2021-11-10T04:42:03.212Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>和则两利，斗则俱伤<br>A peachful and harmonious bilateral relationship between these two countries will make both winners. While a confrontational one wil make both losers.</p></li><li><p>行百里者半九十<br>Half of the people who have embarked on a one-hundred-mile journey may fail by the wayside.</p></li><li><p>华山再高，顶有过路<br>No matter how hign the mountain is, one can always ascend to it’s top.</p></li><li><p>我深深爱着我的国家，没有一片土地让我这样深情和激动，没有一条河流让我这样沉思和祈福，余心之所善兮，虽九死而其尤未悔。<br>I have deep love for this country. I love erery inch of its land. I love every river that flows on this piece of earth with deep passion and deep affection. For the ideal that I hold dear to my heart. I will not regret a thousand depth to die.</p></li><li><p>人或加讪，心无疵兮<br>As a Chinese proverb goes, my conscience stays untained in spite of rumors and slanders from the outside.</p></li><li><p>兄弟虽有小忿，不废懿亲<br>Differences between brothers cannot server their blood ties.</p></li><li><p>不畏浮云遮望眼，只缘身在最高层。<br>As a Chinese poem reads, we have no fear of the clouds that may block our sight, as we are already at the top of the height.</p></li><li><p>入则恳恳以尽忠，出则谦谦以自诲<br>When one is in office he should discharge his duty conscientiously. When leaving office he should conduct himself with humanity and exercise self-reflection.</p></li><li><p>苟利国家生死以，岂因祸福避趋之<br>I shall dedicate myself to the interests of the country in life and death inrrespective of personal weal and woe.</p></li><li><p>知我罪我，其惟春秋<br>There are people who will appreciate what I have done but there are also people who will criticize me. Ultimately, history will have the final say.</p></li><li><p>守职而不废，处义而不回<br>In my last year in office, I will not waver and carrying out my duties, and will remain true to my conviction. I will always be with the people.</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;和则两利，斗则俱伤&lt;br&gt;A peachful and harmonious bilateral relationship between these two countries will make both winners. While a confro
      
    
    </summary>
    
    
      <category term="英文" scheme="http://hi2048.github.io/tags/%E8%8B%B1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>排列硬币</title>
    <link href="http://hi2048.github.io/2021/10/10/%E6%8E%92%E5%88%97%E7%A1%AC%E5%B8%81/"/>
    <id>http://hi2048.github.io/2021/10/10/排列硬币/</id>
    <published>2021-10-09T16:00:00.000Z</published>
    <updated>2021-11-20T03:44:42.829Z</updated>
    
    <content type="html"><![CDATA[<pre><code>/*** 排列硬币* 你总共有 n 枚硬币，并计划将它们按阶梯状排列。对于一个由 k 行组成的阶梯，其第 i 行必须正好有 i 枚硬币。阶梯的最后一行 可能 是不完整的* 给你一个数字 n ，计算并返回可形成 完整阶梯行 的总行数。* @param {number} n* @return {number}*/const getTotal = n =&gt; {  return (1 + n) * n / 2;}var arrangeCoins = function(n) {  let maxRow = 0;  for(let i = 0; i &lt;= n; i++) {    if(getTotal(i) &lt;= n) {      maxRow = i;    } else {      return maxRow;    }  }  return maxRow;};/*** @param {number} n* @return {number}*/var arrangeCoins = function(n) {  let left = 1, right = n;  while(left &lt; right) {    const mid = Math.floor((right - left + 1) / 2) + left;    if(n &gt;= mid * (mid + 1) / 2) {      left = mid;    } else {      right = mid - 1;    }  }  return left;};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;/**
* 排列硬币
* 你总共有 n 枚硬币，并计划将它们按阶梯状排列。对于一个由 k 行组成的阶梯，其第 i 行必须正好有 i 枚硬币。阶梯的最后一行 可能 是不完整的
* 给你一个数字 n ，计算并返回可形成 完整阶梯行 的总行数。
* @param 
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="Leetcode" scheme="http://hi2048.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>系统性思维</title>
    <link href="http://hi2048.github.io/2021/09/01/%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%80%9D%E7%BB%B4/"/>
    <id>http://hi2048.github.io/2021/09/01/系统性思维/</id>
    <published>2021-08-31T16:00:00.000Z</published>
    <updated>2021-09-05T02:58:19.188Z</updated>
    
    <content type="html"><![CDATA[<p>系统性思维与局部性思维</p><p>  <strong> 系统性思维做出决策，然后在局部中做出选择 </strong>。<strong> 先有方向再有选择 </strong>，而不是随便做出了选择，然后再从选择中确定方向。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;系统性思维与局部性思维&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt; 系统性思维做出决策，然后在局部中做出选择 &lt;/strong&gt;。&lt;strong&gt; 先有方向再有选择 &lt;/strong&gt;，而不是随便做出了选择，然后再从选择中确定方向。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Scrum笔记</title>
    <link href="http://hi2048.github.io/2021/05/02/Scrum%E7%AC%94%E8%AE%B0/"/>
    <id>http://hi2048.github.io/2021/05/02/Scrum笔记/</id>
    <published>2021-05-02T06:21:41.000Z</published>
    <updated>2021-09-05T02:24:18.442Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Scrum 采用<strong>迭代、增量</strong>的方法来优化可预见性并控制风险。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;Scrum 采用&lt;strong&gt;迭代、增量&lt;/strong&gt;的方法来优化可预见性并控制风险。&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>商品折扣后的最终价格</title>
    <link href="http://hi2048.github.io/2021/04/06/%E5%95%86%E5%93%81%E6%8A%98%E6%89%A3%E5%90%8E%E7%9A%84%E6%9C%80%E7%BB%88%E4%BB%B7%E6%A0%BC/"/>
    <id>http://hi2048.github.io/2021/04/06/商品折扣后的最终价格/</id>
    <published>2021-04-05T16:00:00.000Z</published>
    <updated>2021-11-20T02:05:41.003Z</updated>
    
    <content type="html"><![CDATA[<pre><code>/*** 给你一个数组 prices ，其中 prices[i] 是商店里第 i 件商品的价格。* 商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 prices[j] 相等的折扣，* 其中 j 是满足 j &gt; i 且 prices[j] &lt;= prices[i]的 最小下标 ，如果没有满足条件的 j ，你将没有任何折扣。* 请你返回一个数组，数组中第 i 个元素是折扣后你购买商品 i 最终需要支付的价格。* * Notice: ** Array.sort ** will change the original array, ** Array.map ** will not change the original array, and both will return new created array* * @param {number[]} prices* @return {number[]}*/const getDiscount = (prices, index) =&gt; {  for(let i = index + 1; i &lt; prices.length; i++) {    if(prices[i] &lt;= prices[index]) {      return prices[i]    }  }  return 0;}var finalPrices = function(prices) {  return prices.map((price, index, prices) =&gt; price - getDiscount(prices, index));};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;/**
* 给你一个数组 prices ，其中 prices[i] 是商店里第 i 件商品的价格。
* 商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 prices[j] 相等的折扣，
* 其中 j 是满足 j &amp;gt; i 且 pric
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="Leetcode" scheme="http://hi2048.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>俄罗斯套娃信封问题</title>
    <link href="http://hi2048.github.io/2021/03/15/%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98/"/>
    <id>http://hi2048.github.io/2021/03/15/俄罗斯套娃信封问题/</id>
    <published>2021-03-14T16:00:00.000Z</published>
    <updated>2021-11-19T11:35:33.661Z</updated>
    
    <content type="html"><![CDATA[<pre><code>/*** 俄罗斯套娃信封问题* 给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。* 当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。* 请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。* @param {number[][]} envelopes* @return {number}* envelopes sort by first value, and sort by second value for the same first value envelopes* dp(i) = max(dp(i), dp(j) + 1)*/var maxEnvelopes = function(envelopes) {  const dp = new Array(envelopes.length).fill(1);  envelopes.sort((item1, item2) =&gt; {    return item1[0] - item2[0];  }).sort((item1, item2) =&gt; {    if(item1[0] === item2[0]) {      return item2[1] - item1[1];    }    return 0;  });  for(let i = 0; i &lt; envelopes.length; i++ ) {    for(let j = 0; j &lt; i; j++) {      if(envelopes[i][1] &gt; envelopes[j][1]) {        dp[i] = Math.max(dp[i], dp[j] + 1);      }    }  }  return Math.max(...dp);};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;/**
* 俄罗斯套娃信封问题
* 给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。
* 当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="Leetcode" scheme="http://hi2048.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>最长递增子序列</title>
    <link href="http://hi2048.github.io/2021/02/05/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://hi2048.github.io/2021/02/05/最长递增子序列/</id>
    <published>2021-02-04T16:00:00.000Z</published>
    <updated>2021-11-19T11:32:13.065Z</updated>
    
    <content type="html"><![CDATA[<pre><code>/*** 最长递增子序列* 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。* @param {number[]} nums* @return {number}* dp(i) = max(dp(i), dp(j) + 1)*/var lengthOfLIS = function(nums) {  const dp = new Array(nums.length).fill(1);  for(let i = 0; i &lt; nums.length; i++) {    for(let j = 0; j &lt; i; j++) {      if(nums[j] &lt; nums[i]) {        dp[i] = Math.max(dp[i], dp[j] + 1);      }    }  }  return Math.max(...dp);};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;/**
* 最长递增子序列
* 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
* @param {number[]} nums
* @return {number}
* dp(i) = max(dp(i), dp(j) + 1)
*/
v
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="Leetcode" scheme="http://hi2048.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>理财笔记</title>
    <link href="http://hi2048.github.io/2021/02/01/%E7%90%86%E8%B4%A2%E7%AC%94%E8%AE%B0/"/>
    <id>http://hi2048.github.io/2021/02/01/理财笔记/</id>
    <published>2021-01-31T16:00:00.000Z</published>
    <updated>2021-09-12T16:05:41.164Z</updated>
    
    <content type="html"><![CDATA[<p>市场概率：1. 胜率 2. 赔率： 即盈亏比 3. 破产率：仓位控制或者资金管理 </p><p>赔率才是交易员要考虑的根本问题。<br>你正确或错误并不是最重要的，最重要的是你正确的时候能赚多少钱，错误的时候会亏多少钱。 – 索罗斯</p><p><strong>赚大赔小，生存第一。</strong></p><p>第一保住本金，第二保住本金，第三认真考虑第一第二条。 – 巴菲特</p><p>一律：纪律，用纪律去统领一切概率的可能性。 1. 胜败：<strong>趋势掌控能力</strong>，行情是否按照计划的大概率事件进行 2. 对错：<strong>计划执行能力</strong>，整体策略的执行力结果 3. 盈亏</p><p>信念： 大道至简，坚信自己可以成功，信念的坚定其实是中庸之道。</p><p>左倾冒进主义： 盲目自信，扛单，频繁交易，重仓交易，赌气交易。<br>右倾投降主义： 做单太谨小慎微，明明是很好的机会，不敢下单，<strong>错失机会</strong>。</p><p>知识与智慧： 知识是可以通过学习获得，智慧只能通过体悟和实践获得。</p><p>熟知与真知： 通过学习知道与通过实践知道的区别。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;市场概率：1. 胜率 2. 赔率： 即盈亏比 3. 破产率：仓位控制或者资金管理 &lt;/p&gt;
&lt;p&gt;赔率才是交易员要考虑的根本问题。&lt;br&gt;你正确或错误并不是最重要的，最重要的是你正确的时候能赚多少钱，错误的时候会亏多少钱。 – 索罗斯&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;赚大赔小
      
    
    </summary>
    
      <category term="杂谈" scheme="http://hi2048.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="理财" scheme="http://hi2048.github.io/tags/%E7%90%86%E8%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>谈谈拖延症</title>
    <link href="http://hi2048.github.io/2021/01/09/%E8%B0%88%E8%B0%88%E6%8B%96%E5%BB%B6%E7%97%87/"/>
    <id>http://hi2048.github.io/2021/01/09/谈谈拖延症/</id>
    <published>2021-01-08T16:00:00.000Z</published>
    <updated>2021-09-09T08:24:54.630Z</updated>
    
    <content type="html"><![CDATA[<pre>1月1日新开这本日记，也为了督促自己后面多下些苦功。1. 先要读完手边的 The Moon and Sixpence2. 考取GCP3. 加强自己的英语听力和口语4. 学习管理方面的知识5. 开始理财并制定计划6. 加强锻炼并保持健康1月2日打牌1月3日打牌1月4日打牌1月5日刷微博，水贴1月6日刷微博，水贴1月7日打牌1月8日刷微博，水贴</pre><p><strong>我本可以</strong>， 不要让自己在将来后悔，需要正视并做出改变。</p><ol><li>把自己的目标大声讲出来<ul><li>周围人的压力会让你开始执行计划</li></ul></li><li>利用帕金森定律，设定一个Deadline</li><li>把大的目标<strong>分解</strong>成细小的目标</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;
1月1日
新开这本日记，也为了督促自己后面多下些苦功。
1. 先要读完手边的 The Moon and Sixpence
2. 考取GCP
3. 加强自己的英语听力和口语
4. 学习管理方面的知识
5. 开始理财并制定计划
6. 加强锻炼并保持健康

1月2日
打牌
      
    
    </summary>
    
      <category term="杂谈" scheme="http://hi2048.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="团队" scheme="http://hi2048.github.io/tags/%E5%9B%A2%E9%98%9F/"/>
    
      <category term="Scrum Master" scheme="http://hi2048.github.io/tags/Scrum-Master/"/>
    
  </entry>
  
  <entry>
    <title>理财杂谈</title>
    <link href="http://hi2048.github.io/2020/12/25/%E7%90%86%E8%B4%A2%E6%9D%82%E8%B0%88/"/>
    <id>http://hi2048.github.io/2020/12/25/理财杂谈/</id>
    <published>2020-12-24T16:00:00.000Z</published>
    <updated>2021-09-10T10:27:07.368Z</updated>
    
    <content type="html"><![CDATA[<p>  市场上通常没有好，更多的时候是<strong>更好</strong>，同样的，也很少有坏，更多的时候是<strong>更坏</strong>，所以更多的时候，我们是需要在更好与更坏中做出选择。</p><p>  市场本身并没有太过复杂，我们都可以总结出自己的好的<strong>交易系统</strong>，只是各种<strong>干扰太多并且太强</strong>，会让你迷失，所以第一个要做的就是<strong>坚守本心</strong>。</p><p>  交易系统需要<strong>简单且有效</strong>。总结起来就是<strong>资金，趋势，择时</strong>。</p><ol><li>可持续的热点</li><li>向上的趋势</li><li>龙头</li><li>在回调中入场，在趋势变坏时果断离场</li><li>果断的止损</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  市场上通常没有好，更多的时候是&lt;strong&gt;更好&lt;/strong&gt;，同样的，也很少有坏，更多的时候是&lt;strong&gt;更坏&lt;/strong&gt;，所以更多的时候，我们是需要在更好与更坏中做出选择。&lt;/p&gt;
&lt;p&gt;  市场本身并没有太过复杂，我们都可以总结出自己的好的&lt;str
      
    
    </summary>
    
      <category term="杂谈" scheme="http://hi2048.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="理财" scheme="http://hi2048.github.io/tags/%E7%90%86%E8%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>浅谈生活</title>
    <link href="http://hi2048.github.io/2020/11/05/%E6%B5%85%E8%B0%88%E7%94%9F%E6%B4%BB/"/>
    <id>http://hi2048.github.io/2020/11/05/浅谈生活/</id>
    <published>2020-11-04T16:00:00.000Z</published>
    <updated>2021-09-10T06:45:00.760Z</updated>
    
    <content type="html"><![CDATA[<p>生活就像一面镜子，你投入什么，它就会回应相同的东西。 所以当我在对着生活发怒，抱怨的时候，是不是应该想想，我投入了什么。</p><p>日子过得太快，每天都是机械的，重复的，唯一不同的是，孩子在慢慢长大，每当看着他那无忧无虑的笑声，我都会想为什么我不能也这样呢。如果仔细想想，却也是不大可能，因为我们有太多的东西要承担，这就注定了不能像孩子那样。但是幸运的是，在这里，我有记录，3年，5年，还有更早的自己，心境，以及生活。每每看到这些，我都会笑得像个孩子。这将让我可以更加坚定的站立在当下。</p><p>所以请放慢脚步，张开双臂，闭上眼睛，感受生活的伟大。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;生活就像一面镜子，你投入什么，它就会回应相同的东西。 所以当我在对着生活发怒，抱怨的时候，是不是应该想想，我投入了什么。&lt;/p&gt;
&lt;p&gt;日子过得太快，每天都是机械的，重复的，唯一不同的是，孩子在慢慢长大，每当看着他那无忧无虑的笑声，我都会想为什么我不能也这样呢。如果仔细想想
      
    
    </summary>
    
      <category term="杂谈" scheme="http://hi2048.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>团队的思考</title>
    <link href="http://hi2048.github.io/2020/10/19/%E5%9B%A2%E9%98%9F%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://hi2048.github.io/2020/10/19/团队的思考/</id>
    <published>2020-10-18T16:00:00.000Z</published>
    <updated>2021-09-09T08:10:14.242Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>交付与成长<br><pre>交付是团队存在的基础，成长是团队持续的核心。 团队成员的成长 ==〉高质量的交付</pre></p><ul><li>团队成员的成长</li><li>高质量的交付</li></ul></li><li><p>技术与方法<br>技术是IT行业的根本。技术可以贯穿整个IT团队，也是IT团队的灵魂，凝聚力的关键。方法则为技术铺平道路。</p><ul><li>技术：技术型团队，对技术保持初心，炙热</li><li>方法：敏捷开发，实践</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;交付与成长&lt;br&gt;&lt;pre&gt;交付是团队存在的基础，成长是团队持续的核心。 团队成员的成长 ==〉高质量的交付&lt;/pre&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;团队成员的成长&lt;/li&gt;
&lt;li&gt;高质量的交付&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;技术与方法&lt;
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="团队" scheme="http://hi2048.github.io/tags/%E5%9B%A2%E9%98%9F/"/>
    
      <category term="Scrum Master" scheme="http://hi2048.github.io/tags/Scrum-Master/"/>
    
  </entry>
  
  <entry>
    <title>腐烂的橘子一</title>
    <link href="http://hi2048.github.io/2020/09/09/%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/"/>
    <id>http://hi2048.github.io/2020/09/09/腐烂的橘子/</id>
    <published>2020-09-08T16:00:00.000Z</published>
    <updated>2021-08-09T14:47:31.828Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>腐烂的橘子</p><pre><code>在给定的网格中，每个单元格可以有以下三个值之一：0 空单元格, 1 新鲜橘子, 2 腐烂的橘子。每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。返回网格中没有新鲜橘子必须经过的最小分钟数。如果不可能，返回 -1。const isAllRotting = grid =&gt; {  for(let row of grid) {      for(let col of row) {          if(col === 1)              return false;      }  }  return true;}const isInGrid = (i, j, grid) =&gt; {  if(i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; grid.length &amp;&amp; j &lt; grid[i].length) {      return true;  }  return false;}const rotting = grid =&gt; {  const nextGrid = copyGrid(grid);  for(let i = 0; i &lt; grid.length; i++) {      for(let j = 0; j &lt; grid[i].length; j++) {          if(grid[i][j] === 2) {              if(isInGrid(i - 1, j, grid) &amp;&amp; nextGrid[i - 1][j] === 1) {                  nextGrid[i - 1][j] = 2;              }              if(isInGrid(i + 1, j, grid) &amp;&amp; nextGrid[i + 1][j] === 1) {                  nextGrid[i + 1][j] = 2;              }              if(isInGrid(i, j - 1, grid) &amp;&amp; nextGrid[i][j - 1] === 1) {                  nextGrid[i][j - 1] = 2;              }              if(isInGrid(i, j + 1, grid) &amp;&amp; nextGrid[i][j + 1] === 1) {                  nextGrid[i][j + 1] = 2;              }          }      }  }  return nextGrid;}const sameGrid = (grid, nextGrid) =&gt; {  for(let i = 0; i &lt; grid.length; i++) {      for(let j = 0; j &lt; grid[i].length; j++) {          if(grid[i][j] !== nextGrid[i][j]) {              return false;          }      }  }  return true;}const copyGrid = grid =&gt; {  let nextGrid = [];  for(let row of grid){      nextGrid.push(row.slice());  }  return nextGrid;}const orangesRotting = grid =&gt; {  let count = 0;  let nextGrid = grid;  while(!isAllRotting(nextGrid)){    if(count &gt; 0 &amp;&amp; sameGrid(grid, nextGrid)) {      return -1;    }    count++;    grid = nextGrid;    nextGrid = rotting(grid);  }  return count;};</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;腐烂的橘子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在给定的网格中，每个单元格可以有以下三个值之一：
0 空单元格, 1 新鲜橘子, 2 腐烂的橘子。
每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。
返回网格中没有新鲜橘子必须经过的最小分钟数
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="leetcode" scheme="http://hi2048.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>剑雨有感</title>
    <link href="http://hi2048.github.io/2020/08/06/%E5%89%91%E9%9B%A8%E6%9C%89%E6%84%9F/"/>
    <id>http://hi2048.github.io/2020/08/06/剑雨有感/</id>
    <published>2020-08-05T16:00:00.000Z</published>
    <updated>2021-08-06T11:09:15.321Z</updated>
    
    <content type="html"><![CDATA[<p>佛陀阿难出家前，在道上见一美貌少女，从此爱慕难舍。佛祖问他：你有多喜欢那少女？ 阿难回答： 愿化身为青石桥，受五百年风吹，五百年日晒，五百年雨打， 只求那少女从桥上走过。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;佛陀阿难出家前，在道上见一美貌少女，从此爱慕难舍。佛祖问他：你有多喜欢那少女？ 阿难回答： 愿化身为青石桥，受五百年风吹，五百年日晒，五百年雨打， 只求那少女从桥上走过。&lt;/p&gt;

      
    
    </summary>
    
      <category term="杂谈" scheme="http://hi2048.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>数组中有效三角形的数量</title>
    <link href="http://hi2048.github.io/2020/07/12/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%89%E6%95%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E6%95%B0%E9%87%8F/"/>
    <id>http://hi2048.github.io/2020/07/12/数组中有效三角形的数量/</id>
    <published>2020-07-11T16:00:00.000Z</published>
    <updated>2021-08-04T10:04:22.637Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>数组nums中有效三角形的数量</p><pre><code>  var triangleNumber = function(nums) {    let count = 0;    nums.sort((a, b) =&gt; a - b);    for(let i = nums.length - 1; i &gt;= 2; i--) {        let j = i - 1, k = 0;        while(k &lt; j) {            if(nums[k] + nums[j] &gt; nums[i]) {                count += j - k;                j--;            } else {                k++;            }        }    }    return count;};</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;数组nums中有效三角形的数量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  var triangleNumber = function(nums) {
    let count = 0;

    nums.sort((a, b) =&amp;gt; a - b);

 
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>SMART原则</title>
    <link href="http://hi2048.github.io/2020/06/08/SMART%E5%8E%9F%E5%88%99/"/>
    <id>http://hi2048.github.io/2020/06/08/SMART原则/</id>
    <published>2020-06-07T16:00:00.000Z</published>
    <updated>2021-08-04T04:41:48.617Z</updated>
    
    <content type="html"><![CDATA[<p><strong> SMART原则（S=Specific、M=Measurable、A=Attainable、R=Relevant、T=Time-bound）</strong></p><ol><li>绩效指标必须是具体的（Specific）</li><li>绩效指标必须是可以衡量的（Measurable）</li><li>绩效指标必须是可以达到的（Attainable）</li><li>绩效指标是要与其他目标具有一定的相关性(Relevant)</li><li>绩效指标必须具有明确的截止期限（Time-bound）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; SMART原则（S=Specific、M=Measurable、A=Attainable、R=Relevant、T=Time-bound）&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;绩效指标必须是具体的（Specific）&lt;/li&gt;
&lt;li&gt;绩效指标必须
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="Agile" scheme="http://hi2048.github.io/tags/Agile/"/>
    
  </entry>
  
  <entry>
    <title>GCP</title>
    <link href="http://hi2048.github.io/2020/05/25/GCP/"/>
    <id>http://hi2048.github.io/2020/05/25/GCP/</id>
    <published>2020-05-24T16:00:00.000Z</published>
    <updated>2021-08-04T04:36:32.442Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>Computer Engine, App Engine</p></li><li><p>HTTPS load balance</p></li><li><p>Stackdriver</p></li><li><p>Datastore</p></li><li><p>BigQuery</p></li><li><p>Cloud Pub/Sub</p></li><li><p>Cloud storage</p></li><li><p>Cloud Dataflow</p></li><li><p>Cloud Endpoints</p></li><li><p>Cloud SQL</p></li><li><p>Hadoop/Spark</p></li><li><p>Cloud dataproc</p></li><li><p>Jenkins</p></li><li><p>Cloud BigTable</p></li><li><p>Cloud Memorystore</p></li><li><p>Cloud Datastore</p></li><li><p>k8s(Kubernetes)/Containers</p></li><li><p>Cloud Marketplace</p></li><li><p>CDN</p></li><li><p>Local SSD, SSD persistent disks</p></li><li><p>Cloud VPN</p></li><li><p>Cloud Functions</p></li><li><p>CSEK</p></li><li><p>Firewall rules</p></li><li><p>ETL</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;Computer Engine, App Engine&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;HTTPS load balance&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Stackdriver&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Datastore&lt;/p&gt;
&lt;/li
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="GCP" scheme="http://hi2048.github.io/tags/GCP/"/>
    
  </entry>
  
  <entry>
    <title>logger</title>
    <link href="http://hi2048.github.io/2020/04/12/logger/"/>
    <id>http://hi2048.github.io/2020/04/12/logger/</id>
    <published>2020-04-11T16:00:00.000Z</published>
    <updated>2021-08-04T04:36:35.137Z</updated>
    
    <content type="html"><![CDATA[<p>– logger <a href="https://github.com/hi2048/hi2048-utils/tree/master/site/src/utils/log" title="logger" target="_blank" rel="noopener">github</a>  <a href="https://www.npmjs.com/package/hi2048-utils" title="hi2048-utils" target="_blank" rel="noopener">npm</a>  <a href="http://blog.hi2048.com/hi2048-utils/" title="logger" target="_blank" rel="noopener">demo</a></p><pre><code>-- index.jsimport { isFunction, isString } from &apos;../type&apos;;const log = type =&gt; (target, name, descriptor) =&gt; {  if(isFunction(target[name])) {    const originFunction = descriptor.value;    descriptor.value = function(...args) {      console.log(`${target.constructor.name}: `);      console.log(`${type} start: ${name} (${args}).`);      try {        const ret = originFunction.call(this, ...args);        console.log(`${type} succeed: ${name} (${args} =&gt; ${ret}).`);      } catch(err) {        console.log(`${type} failed: ${name} (${args} =&gt; ${err}).`);      }    }  }  return descriptor;}export const logger = (...args) =&gt; {  if(!isString(args[0])) {    return log(&apos;&apos;)(...args);  }  return log(...args);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;– logger &lt;a href=&quot;https://github.com/hi2048/hi2048-utils/tree/master/site/src/utils/log&quot; title=&quot;logger&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gi
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="hi2048" scheme="http://hi2048.github.io/tags/hi2048/"/>
    
      <category term="hi2048-utils" scheme="http://hi2048.github.io/tags/hi2048-utils/"/>
    
  </entry>
  
  <entry>
    <title>creater</title>
    <link href="http://hi2048.github.io/2020/03/20/creater/"/>
    <id>http://hi2048.github.io/2020/03/20/creater/</id>
    <published>2020-03-19T16:00:00.000Z</published>
    <updated>2021-08-04T04:36:40.407Z</updated>
    
    <content type="html"><![CDATA[<p>– creater <a href="https://github.com/hi2048/hi2048-utils/tree/master/site/src/utils/creater" title="creater" target="_blank" rel="noopener">github</a>  <a href="https://www.npmjs.com/package/hi2048-utils" title="hi2048-utils" target="_blank" rel="noopener">npm</a>  <a href="http://blog.hi2048.com/hi2048-utils/" title="creater" target="_blank" rel="noopener">demo</a></p><pre><code>-- index.jsimport { isFunction } from &apos;../type&apos;;export const creater = Target =&gt; config =&gt; class {  constructor(...args) {    if(isFunction(config)) {      return new Target(config, ...args);    }    return new Target(Object.assign(config, ...args));  }};const builder = creater =&gt; array =&gt; array.map(item =&gt; creater(item));export const factory = Target =&gt; builder(creater(Target));</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;– creater &lt;a href=&quot;https://github.com/hi2048/hi2048-utils/tree/master/site/src/utils/creater&quot; title=&quot;creater&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="hi2048" scheme="http://hi2048.github.io/tags/hi2048/"/>
    
      <category term="hi2048-utils" scheme="http://hi2048.github.io/tags/hi2048-utils/"/>
    
  </entry>
  
  <entry>
    <title>unicode</title>
    <link href="http://hi2048.github.io/2020/03/08/unicode/"/>
    <id>http://hi2048.github.io/2020/03/08/unicode/</id>
    <published>2020-03-07T16:00:00.000Z</published>
    <updated>2020-03-14T19:09:03.238Z</updated>
    
    <content type="html"><![CDATA[<p>– unicode <a href="https://github.com/hi2048/hi2048-utils/tree/master/site/src/utils/unicode" title="unicode" target="_blank" rel="noopener">github</a>  <a href="https://www.npmjs.com/package/hi2048-utils" title="hi2048-utils" target="_blank" rel="noopener">npm</a>  <a href="http://blog.hi2048.com/hi2048-utils/" title="unicode" target="_blank" rel="noopener">demo</a></p><pre><code>-- index.jsimport { isFunction } from &apos;../type&apos;;import { random } from &apos;../random&apos;;import { familyNames, firstNames } from &apos;./index.config&apos;;export const encode = str =&gt; `\\u${Array.from(str).map(char =&gt; `00${char.charCodeAt().toString(16)}`.slice(-4)).join(&apos;\\u&apos;)}`;export const decode = par =&gt; {  let str = par;  if(isFunction(par)) {    str = par();  }  return unescape(str.replace(/\\/g, &apos;%&apos;));};export const create = () =&gt; `\\u${(random(20901) + 19968).toString(16)}`;export const createWord = () =&gt; decode(create);export const createRandomName = () =&gt; {  const count = random(2, 4);  const result = [];  for(let i = 0; i &lt; count; i++) {    result.push(createWord());  }  return result.join(&apos;&apos;);};export const createName = () =&gt; {  return `${familyNames[random(familyNames.length)]}${firstNames[random(firstNames.length)]}`;};export const unicode = {  encode,  decode,  create,  createWord,  createName,  createRandomName};-- index.test.jsimport { encode, decode, create, createWord, createName, createRandomName } from &apos;.&apos;;test(&apos;encode&apos;, () =&gt; expect(encode(&apos;苏小蜂&apos;)).toBe(&quot;\\u82cf\\u5c0f\\u8702&quot;));test(&apos;decode&apos;, () =&gt; expect(decode(&apos;\\u82cf\\u5c0f\\u8702&apos;)).toBe(&apos;苏小蜂&apos;));test(&apos;create&apos;, () =&gt; expect(create()).toBeDefined());test(&apos;create&apos;, () =&gt; expect(createWord()).toBeDefined());test(&apos;create&apos;, () =&gt; expect(createName()).toBeDefined());test(&apos;create&apos;, () =&gt; expect(createRandomName()).toBeDefined());</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;– unicode &lt;a href=&quot;https://github.com/hi2048/hi2048-utils/tree/master/site/src/utils/unicode&quot; title=&quot;unicode&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="hi2048" scheme="http://hi2048.github.io/tags/hi2048/"/>
    
      <category term="hi2048-utils" scheme="http://hi2048.github.io/tags/hi2048-utils/"/>
    
  </entry>
  
</feed>
