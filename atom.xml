<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>苏小蜂的个人博客</title>
  
  <subtitle>放慢脚步，享受生活！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hi2048.github.io/"/>
  <updated>2021-11-22T15:19:48.852Z</updated>
  <id>http://hi2048.github.io/</id>
  
  <author>
    <name>Jsu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学生出勤记录3</title>
    <link href="http://hi2048.github.io/2021/11/22/%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%953/"/>
    <id>http://hi2048.github.io/2021/11/22/学生出勤记录3/</id>
    <published>2021-11-21T16:00:00.000Z</published>
    <updated>2021-11-22T15:19:48.852Z</updated>
    
    <content type="html"><![CDATA[<pre><code>/*** 学生出勤记录 II* 给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：* &apos;A&apos;：Absent，缺勤* &apos;L&apos;：Late，迟到* &apos;P&apos;：Present，到场* 如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：* 按 总出勤 计，学生缺勤（&apos;A&apos;）严格 少于两天。* 学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（&apos;L&apos;）记录。* 给你一个整数 n，表示出勤记录的长度(次数)。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 数量 。答案可能很大，所以返回对 109 + 7 取余 结果。* * method1: dfs* method2: dp* * @param {number} n* @return {number}*/var checkRecord = function(n) {  const Mod = 1000000007;  const dp = new Array(n).fill(0).map(() =&gt; new Array(2).fill(0).map(() =&gt; new Array(3).fill(0)));  //p  dp[0][0][0] = 1;  //A  dp[0][1][0] = 1;  //L  dp[0][0][1] = 1;  for(let i = 1; i &lt; n; i++) {    //p    dp[i][0][0] = (dp[i - 1][0][0] + dp[i - 1][0][1] + dp[i - 1][0][2]) % Mod;    dp[i][1][0] = (dp[i - 1][1][0] + dp[i - 1][1][1] + dp[i - 1][1][2]) % Mod;    //A    dp[i][1][0] = (dp[i][1][0] + dp[i - 1][0][0] + dp[i - 1][0][1] + dp[i - 1][0][2]) % Mod;    //L    dp[i][0][1] = dp[i - 1][0][0];    dp[i][0][2] = dp[i - 1][0][1];    dp[i][1][1] = dp[i - 1][1][0];    dp[i][1][2] = dp[i - 1][1][1];  }  let sum = 0;  for(let i = 0; i &lt; 2; i++) {    for(let j = 0; j &lt; 3; j++) {      sum = (sum + dp[n - 1][i][j]) % Mod;    }  }  return sum;};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;/**
* 学生出勤记录 II
* 给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：
* &amp;apos;A&amp;apos;：Absent，缺勤
* &amp;apos;L&amp;apos;：Late，
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://hi2048.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>study notes</title>
    <link href="http://hi2048.github.io/2021/11/01/study-notes-english/"/>
    <id>http://hi2048.github.io/2021/11/01/study-notes-english/</id>
    <published>2021-10-31T16:00:00.000Z</published>
    <updated>2021-11-10T04:42:03.212Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>和则两利，斗则俱伤<br>A peachful and harmonious bilateral relationship between these two countries will make both winners. While a confrontational one wil make both losers.</p></li><li><p>行百里者半九十<br>Half of the people who have embarked on a one-hundred-mile journey may fail by the wayside.</p></li><li><p>华山再高，顶有过路<br>No matter how hign the mountain is, one can always ascend to it’s top.</p></li><li><p>我深深爱着我的国家，没有一片土地让我这样深情和激动，没有一条河流让我这样沉思和祈福，余心之所善兮，虽九死而其尤未悔。<br>I have deep love for this country. I love erery inch of its land. I love every river that flows on this piece of earth with deep passion and deep affection. For the ideal that I hold dear to my heart. I will not regret a thousand depth to die.</p></li><li><p>人或加讪，心无疵兮<br>As a Chinese proverb goes, my conscience stays untained in spite of rumors and slanders from the outside.</p></li><li><p>兄弟虽有小忿，不废懿亲<br>Differences between brothers cannot server their blood ties.</p></li><li><p>不畏浮云遮望眼，只缘身在最高层。<br>As a Chinese poem reads, we have no fear of the clouds that may block our sight, as we are already at the top of the height.</p></li><li><p>入则恳恳以尽忠，出则谦谦以自诲<br>When one is in office he should discharge his duty conscientiously. When leaving office he should conduct himself with humanity and exercise self-reflection.</p></li><li><p>苟利国家生死以，岂因祸福避趋之<br>I shall dedicate myself to the interests of the country in life and death inrrespective of personal weal and woe.</p></li><li><p>知我罪我，其惟春秋<br>There are people who will appreciate what I have done but there are also people who will criticize me. Ultimately, history will have the final say.</p></li><li><p>守职而不废，处义而不回<br>In my last year in office, I will not waver and carrying out my duties, and will remain true to my conviction. I will always be with the people.</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;和则两利，斗则俱伤&lt;br&gt;A peachful and harmonious bilateral relationship between these two countries will make both winners. While a confro
      
    
    </summary>
    
    
      <category term="英文" scheme="http://hi2048.github.io/tags/%E8%8B%B1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>学生出勤记录2</title>
    <link href="http://hi2048.github.io/2021/10/25/%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%952/"/>
    <id>http://hi2048.github.io/2021/10/25/学生出勤记录2/</id>
    <published>2021-10-24T16:00:00.000Z</published>
    <updated>2021-11-22T15:19:25.851Z</updated>
    
    <content type="html"><![CDATA[<pre><code>/*** 学生出勤记录 II* 给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：* &apos;A&apos;：Absent，缺勤* &apos;L&apos;：Late，迟到* &apos;P&apos;：Present，到场* 如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：* 按 总出勤 计，学生缺勤（&apos;A&apos;）严格 少于两天。* 学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（&apos;L&apos;）记录。* 给你一个整数 n，表示出勤记录的长度(次数)。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 数量 。答案可能很大，所以返回对 109 + 7 取余 结果。* * method1: dfs* method2: dp* * @param {number} n* @return {number}*/const dfs = (day, n, absents, lates, memo) =&gt; {  if(day &gt;= n)    return 1;  if(memo[day][absents][lates] !== 0)    return memo[day][absents][lates];  let ans = 0, MOD = 1000000007;  //P  ans = (ans + dfs(day + 1, n, absents, 0, memo)) % MOD;  //A  if(absents &lt; 1) {    ans = (ans + dfs(day + 1, n, 1, 0, memo)) % MOD;  }  //L  if(lates &lt; 2) {    ans = (ans + dfs(day + 1, n, absents, lates + 1, memo)) % MOD;  }  memo[day][absents][lates] = ans;  return ans;}var checkRecord = function(n) {  const memo = new Array(n + 1).fill(0).map(() =&gt; new Array(2).fill(0).map(() =&gt; new Array(3).fill(0)));  return dfs(0, n, 0, 0, memo);};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;/**
* 学生出勤记录 II
* 给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：
* &amp;apos;A&amp;apos;：Absent，缺勤
* &amp;apos;L&amp;apos;：Late，
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://hi2048.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>排列硬币</title>
    <link href="http://hi2048.github.io/2021/10/10/%E6%8E%92%E5%88%97%E7%A1%AC%E5%B8%81/"/>
    <id>http://hi2048.github.io/2021/10/10/排列硬币/</id>
    <published>2021-10-09T16:00:00.000Z</published>
    <updated>2021-11-20T03:44:42.829Z</updated>
    
    <content type="html"><![CDATA[<pre><code>/*** 排列硬币* 你总共有 n 枚硬币，并计划将它们按阶梯状排列。对于一个由 k 行组成的阶梯，其第 i 行必须正好有 i 枚硬币。阶梯的最后一行 可能 是不完整的* 给你一个数字 n ，计算并返回可形成 完整阶梯行 的总行数。* @param {number} n* @return {number}*/const getTotal = n =&gt; {  return (1 + n) * n / 2;}var arrangeCoins = function(n) {  let maxRow = 0;  for(let i = 0; i &lt;= n; i++) {    if(getTotal(i) &lt;= n) {      maxRow = i;    } else {      return maxRow;    }  }  return maxRow;};/*** @param {number} n* @return {number}*/var arrangeCoins = function(n) {  let left = 1, right = n;  while(left &lt; right) {    const mid = Math.floor((right - left + 1) / 2) + left;    if(n &gt;= mid * (mid + 1) / 2) {      left = mid;    } else {      right = mid - 1;    }  }  return left;};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;/**
* 排列硬币
* 你总共有 n 枚硬币，并计划将它们按阶梯状排列。对于一个由 k 行组成的阶梯，其第 i 行必须正好有 i 枚硬币。阶梯的最后一行 可能 是不完整的
* 给你一个数字 n ，计算并返回可形成 完整阶梯行 的总行数。
* @param 
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://hi2048.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>只有两个键的键盘</title>
    <link href="http://hi2048.github.io/2021/09/19/%E5%8F%AA%E6%9C%89%E4%B8%A4%E4%B8%AA%E9%94%AE%E7%9A%84%E9%94%AE%E7%9B%98/"/>
    <id>http://hi2048.github.io/2021/09/19/只有两个键的键盘/</id>
    <published>2021-09-18T16:00:00.000Z</published>
    <updated>2021-11-26T03:59:12.191Z</updated>
    
    <content type="html"><![CDATA[<pre><code>/*** 只有两个键的键盘* 最初记事本上只有一个字符 &apos;A&apos; 。你每次可以对这个记事本进行两种操作：* Copy All（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。* Paste（粘贴）：粘贴 上一次 复制的字符。* 给你一个数字 n ，你需要使用最少的操作次数，在记事本上输出 恰好 n 个 &apos;A&apos; 。返回能够打印出 n 个 &apos;A&apos; 的最少操作次数。* i = j * i/j, i % j === 0,  j or i / j &lt; sqrt(i)* dp(i) = min(dp(i), dp(j) + i / j, dp(i / j) + j)* */function minSteps(n: number): number {  const dp = new Array(n + 1).fill(0);  for(let i = 2; i &lt;= n; i++) {    dp[i] = Number.MAX_SAFE_INTEGER;    for(let j = 1; j &lt;= Math.sqrt(i); j++) {      if(i % j === 0) {        dp[i] = Math.min(dp[i], dp[j] + i / j);        dp[i] = Math.min(dp[i], dp[i / j] + j);      }    }  }  return dp[n];};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;/**
* 只有两个键的键盘
* 最初记事本上只有一个字符 &amp;apos;A&amp;apos; 。你每次可以对这个记事本进行两种操作：
* Copy All（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。
* Paste（粘贴）：粘贴 上一次 复制
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://hi2048.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>系统性思维</title>
    <link href="http://hi2048.github.io/2021/09/01/%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%80%9D%E7%BB%B4/"/>
    <id>http://hi2048.github.io/2021/09/01/系统性思维/</id>
    <published>2021-08-31T16:00:00.000Z</published>
    <updated>2021-09-05T02:58:19.188Z</updated>
    
    <content type="html"><![CDATA[<p>系统性思维与局部性思维</p><p>  <strong> 系统性思维做出决策，然后在局部中做出选择 </strong>。<strong> 先有方向再有选择 </strong>，而不是随便做出了选择，然后再从选择中确定方向。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;系统性思维与局部性思维&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt; 系统性思维做出决策，然后在局部中做出选择 &lt;/strong&gt;。&lt;strong&gt; 先有方向再有选择 &lt;/strong&gt;，而不是随便做出了选择，然后再从选择中确定方向。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学生出勤记录1</title>
    <link href="http://hi2048.github.io/2021/08/17/%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%951/"/>
    <id>http://hi2048.github.io/2021/08/17/学生出勤记录1/</id>
    <published>2021-08-16T16:00:00.000Z</published>
    <updated>2021-11-22T15:18:59.679Z</updated>
    
    <content type="html"><![CDATA[<pre><code>/*** 学生出勤记录 I* 给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：* &apos;A&apos;：Absent，缺勤* &apos;L&apos;：Late，迟到* &apos;P&apos;：Present，到场* 如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：* 按 总出勤 计，学生缺勤（&apos;A&apos;）严格 少于两天。* 学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（&apos;L&apos;）记录。* 如果学生可以获得出勤奖励，返回 true ；否则，返回 false 。* * @param {string} s* @return {boolean}*/var checkRecord = function(s) {  let absents = 0, lates = 0;  for(let i = 0; i &lt; s.length; i++) {    const c = s[i];    if(c === &apos;A&apos;) {      absents ++;      if(absents &gt;= 2) {          return false;      }    }    if(c === &apos;L&apos;) {      lates ++;      if(lates &gt;= 3) {        return false;      }    } else {      lates = 0;    }  }  return true;};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;/**
* 学生出勤记录 I
* 给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：
* &amp;apos;A&amp;apos;：Absent，缺勤
* &amp;apos;L&amp;apos;：Late，迟
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://hi2048.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>连续子数组的最大和</title>
    <link href="http://hi2048.github.io/2021/07/17/%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <id>http://hi2048.github.io/2021/07/17/连续子数组的最大和/</id>
    <published>2021-07-16T16:00:00.000Z</published>
    <updated>2021-11-24T12:02:06.386Z</updated>
    
    <content type="html"><![CDATA[<pre><code>/*** 剑指 Offer: 连续子数组的最大和* 输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。* 要求时间复杂度为O(n)。* dp(i)以i结尾的连续最大子数组* dp(i - 1) &lt;= 0, dp(i) = n[i]* dp(i - 1 ) &gt; 0, dp(i) = dp(i - 1) + n[i]* * @param {number[]} nums* @return {number}*/var maxSubArray = function(nums) {  const dp = new Array(nums.length).fill(nums[0]);  let max = nums[0];  for(let i = 1; i &lt; nums.length; i++) {    if(dp[i - 1] &lt;= 0) {      dp[i] = nums[i];    } else {      dp[i] = dp[i - 1] + nums[i];    }    max = Math.max(max, dp[i]);  }  return max;};var maxSubArray = function(nums) {  let dp = nums[0], max = nums[0];  for(let i = 1; i &lt; nums.length; i++) {    if(dp &lt;= 0) {      dp = nums[i];    } else {      dp += nums[i];    }    max = Math.max(max, dp);  }  return max;};var maxSubArray = function(nums) {  let dp = nums[0], max = nums[0];  for(let i = 1; i &lt; nums.length; i++) {    dp = Math.max(dp + nums[i], nums[i]);    max = Math.max(max, dp);  }  return max;};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;/**
* 剑指 Offer: 连续子数组的最大和
* 输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。
* 要求时间复杂度为O(n)。
* dp(i)以i结尾的连续最大子数组
* dp(i - 1) &amp;lt;= 0, 
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://hi2048.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>石子游戏</title>
    <link href="http://hi2048.github.io/2021/06/16/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/"/>
    <id>http://hi2048.github.io/2021/06/16/石子游戏/</id>
    <published>2021-06-15T16:00:00.000Z</published>
    <updated>2021-11-25T04:53:11.191Z</updated>
    
    <content type="html"><![CDATA[<pre><code>/*** 石子游戏* * 亚历克斯和李 用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。* 游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。* 亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。* 假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。* dp(i)(j) [i, j]中当前玩家与另一玩家的差值* dp(i)(i) = piles[i]* dp(i)(j) = max(piles[i] - dp(i + 1)(j), piles[j] - dp(i)(j - 1) )* * @param {number[]} piles* @return {boolean}*/var stoneGame = function(piles) {  const dp = new Array(piles.length).fill(0).map((arrItem1, i) =&gt; new Array(piles.length).fill(0).map((arrItem2, j) =&gt; {    if(i == j) {      return piles[i];    } else {      return 0;    }  }));  for(let i = piles.length - 2; i &gt;= 0; i--) {    for(let j = i + 1; j &lt; piles.length; j++) {      dp[i][j] = Math.max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1]);    }  }  return dp[0][piles.length - 1] &gt; 0;};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;/**
* 石子游戏
* 
* 亚历克斯和李 用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。
* 游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。
* 亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://hi2048.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Scrum笔记</title>
    <link href="http://hi2048.github.io/2021/05/02/Scrum%E7%AC%94%E8%AE%B0/"/>
    <id>http://hi2048.github.io/2021/05/02/Scrum笔记/</id>
    <published>2021-05-02T06:21:41.000Z</published>
    <updated>2021-09-05T02:24:18.442Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Scrum 采用<strong>迭代、增量</strong>的方法来优化可预见性并控制风险。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;Scrum 采用&lt;strong&gt;迭代、增量&lt;/strong&gt;的方法来优化可预见性并控制风险。&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>商品折扣后的最终价格</title>
    <link href="http://hi2048.github.io/2021/04/06/%E5%95%86%E5%93%81%E6%8A%98%E6%89%A3%E5%90%8E%E7%9A%84%E6%9C%80%E7%BB%88%E4%BB%B7%E6%A0%BC/"/>
    <id>http://hi2048.github.io/2021/04/06/商品折扣后的最终价格/</id>
    <published>2021-04-05T16:00:00.000Z</published>
    <updated>2021-11-20T02:05:41.003Z</updated>
    
    <content type="html"><![CDATA[<pre><code>/*** 给你一个数组 prices ，其中 prices[i] 是商店里第 i 件商品的价格。* 商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 prices[j] 相等的折扣，* 其中 j 是满足 j &gt; i 且 prices[j] &lt;= prices[i]的 最小下标 ，如果没有满足条件的 j ，你将没有任何折扣。* 请你返回一个数组，数组中第 i 个元素是折扣后你购买商品 i 最终需要支付的价格。* * Notice: ** Array.sort ** will change the original array, ** Array.map ** will not change the original array, and both will return new created array* * @param {number[]} prices* @return {number[]}*/const getDiscount = (prices, index) =&gt; {  for(let i = index + 1; i &lt; prices.length; i++) {    if(prices[i] &lt;= prices[index]) {      return prices[i]    }  }  return 0;}var finalPrices = function(prices) {  return prices.map((price, index, prices) =&gt; price - getDiscount(prices, index));};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;/**
* 给你一个数组 prices ，其中 prices[i] 是商店里第 i 件商品的价格。
* 商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 prices[j] 相等的折扣，
* 其中 j 是满足 j &amp;gt; i 且 pric
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://hi2048.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>俄罗斯套娃信封问题</title>
    <link href="http://hi2048.github.io/2021/03/15/%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98/"/>
    <id>http://hi2048.github.io/2021/03/15/俄罗斯套娃信封问题/</id>
    <published>2021-03-14T16:00:00.000Z</published>
    <updated>2021-11-19T11:35:33.661Z</updated>
    
    <content type="html"><![CDATA[<pre><code>/*** 俄罗斯套娃信封问题* 给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。* 当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。* 请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。* @param {number[][]} envelopes* @return {number}* envelopes sort by first value, and sort by second value for the same first value envelopes* dp(i) = max(dp(i), dp(j) + 1)*/var maxEnvelopes = function(envelopes) {  const dp = new Array(envelopes.length).fill(1);  envelopes.sort((item1, item2) =&gt; {    return item1[0] - item2[0];  }).sort((item1, item2) =&gt; {    if(item1[0] === item2[0]) {      return item2[1] - item1[1];    }    return 0;  });  for(let i = 0; i &lt; envelopes.length; i++ ) {    for(let j = 0; j &lt; i; j++) {      if(envelopes[i][1] &gt; envelopes[j][1]) {        dp[i] = Math.max(dp[i], dp[j] + 1);      }    }  }  return Math.max(...dp);};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;/**
* 俄罗斯套娃信封问题
* 给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。
* 当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://hi2048.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>最长递增子序列</title>
    <link href="http://hi2048.github.io/2021/02/05/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://hi2048.github.io/2021/02/05/最长递增子序列/</id>
    <published>2021-02-04T16:00:00.000Z</published>
    <updated>2021-11-19T11:32:13.065Z</updated>
    
    <content type="html"><![CDATA[<pre><code>/*** 最长递增子序列* 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。* @param {number[]} nums* @return {number}* dp(i) = max(dp(i), dp(j) + 1)*/var lengthOfLIS = function(nums) {  const dp = new Array(nums.length).fill(1);  for(let i = 0; i &lt; nums.length; i++) {    for(let j = 0; j &lt; i; j++) {      if(nums[j] &lt; nums[i]) {        dp[i] = Math.max(dp[i], dp[j] + 1);      }    }  }  return Math.max(...dp);};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;/**
* 最长递增子序列
* 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
* @param {number[]} nums
* @return {number}
* dp(i) = max(dp(i), dp(j) + 1)
*/
v
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://hi2048.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>理财笔记</title>
    <link href="http://hi2048.github.io/2021/02/01/%E7%90%86%E8%B4%A2%E7%AC%94%E8%AE%B0/"/>
    <id>http://hi2048.github.io/2021/02/01/理财笔记/</id>
    <published>2021-01-31T16:00:00.000Z</published>
    <updated>2021-09-12T16:05:41.164Z</updated>
    
    <content type="html"><![CDATA[<p>市场概率：1. 胜率 2. 赔率： 即盈亏比 3. 破产率：仓位控制或者资金管理 </p><p>赔率才是交易员要考虑的根本问题。<br>你正确或错误并不是最重要的，最重要的是你正确的时候能赚多少钱，错误的时候会亏多少钱。 – 索罗斯</p><p><strong>赚大赔小，生存第一。</strong></p><p>第一保住本金，第二保住本金，第三认真考虑第一第二条。 – 巴菲特</p><p>一律：纪律，用纪律去统领一切概率的可能性。 1. 胜败：<strong>趋势掌控能力</strong>，行情是否按照计划的大概率事件进行 2. 对错：<strong>计划执行能力</strong>，整体策略的执行力结果 3. 盈亏</p><p>信念： 大道至简，坚信自己可以成功，信念的坚定其实是中庸之道。</p><p>左倾冒进主义： 盲目自信，扛单，频繁交易，重仓交易，赌气交易。<br>右倾投降主义： 做单太谨小慎微，明明是很好的机会，不敢下单，<strong>错失机会</strong>。</p><p>知识与智慧： 知识是可以通过学习获得，智慧只能通过体悟和实践获得。</p><p>熟知与真知： 通过学习知道与通过实践知道的区别。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;市场概率：1. 胜率 2. 赔率： 即盈亏比 3. 破产率：仓位控制或者资金管理 &lt;/p&gt;
&lt;p&gt;赔率才是交易员要考虑的根本问题。&lt;br&gt;你正确或错误并不是最重要的，最重要的是你正确的时候能赚多少钱，错误的时候会亏多少钱。 – 索罗斯&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;赚大赔小
      
    
    </summary>
    
      <category term="杂谈" scheme="http://hi2048.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="理财" scheme="http://hi2048.github.io/tags/%E7%90%86%E8%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript notes</title>
    <link href="http://hi2048.github.io/2021/01/09/TypeScript-notes/"/>
    <id>http://hi2048.github.io/2021/01/09/TypeScript-notes/</id>
    <published>2021-01-08T16:00:00.000Z</published>
    <updated>2021-11-27T06:32:09.321Z</updated>
    
    <content type="html"><![CDATA[<pre><code>/*** * 1. origin data type: number, string, boolean, null, undefined, void, symbol, bigint* 2. non-origin data type: object, array, tuple, enum* const arr: string[] = [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;]* const tuple: [string, number, string] = [&apos;1&apos;, 2, &apos;3&apos;]* 3. any, unknown, never* any 类型的变量是可以进行任意进行赋值、实例化、函数执行等操作，但是 unknown 只允许赋值，不允许实例化、函数执行等操作* never 的字面意思是 “永不”，在 TS 中代表不存在的值类型，一般用于给函数进行类型声明，函数绝不会有返回值的时候使用，比如函数内抛出错误* 4. interface* interface Todo {*  content: string;*  readonly user: string;*  time?: string;*  isComplete: boolean;*  [propName: string]: any;* }* 5. enum* enum UserId {*  tuture = &apos;666&apos;,*  mRcfps = 6,* }* 6. 函数类型* const add: (x: number, y: number, z?: number): number = function(x, y) {*  // ...*  return x + y;* }* 7. 交叉类型 &amp;* interface ErrorHandling {*  success: boolean;*  error?: { message: string };* }* interface ArtistsData {*  artists: { name: string }[];* }* const handleArtistsResponse = (response: ArtistsData &amp; ErrorHandling) =&gt; {*  if(response.error) {*    console.error(response.error.message);*    return;*  }*  console.log(response.artists);* }* 7. 联合类型 |* const padLeft = (value: string, padding: string | number) =&gt; void* 8. 字面量类型* 字面量可是说是 TS 类型系统里面最小的类型。 * 数字字面量* let tuture: 520* 字符串字面量* let tuture: &apos;520&apos;* 9. 类型守卫* 联合类型+字面量类型* 主要用于在进行 ”联合“ 的多个类型之间，存在相同的字段，也存在不同的字段，然后需要区分具体什么时候是使用哪个类型* 10. 类型别名* type NameParams = &apos;string&apos; | () =&gt; &apos;string&apos;;* function getName(n: NameParams): string {}* 11. 类型别名与接口* type name = &apos;string&apos;* type tuture ={*  tutureCommunity: string;*  editure: string;*  tutureDocs: string;* }* interface Tuture {*  tutureCommunity: string;*  editure: string;*  tutureDocs: string;* }* 12. 类* ES6* 构造函数* 属性* 实例属性* 静态属性* 方法* 实例方法* 静态方法* TS* 注解构造函数* 注解属性* 访问限定符: public/protected/private* 修饰符: readonly* 注解方法* 访问限定符: public/protected/private* class Animal {*  name: string;* *  static isAnimal(a: Animal): boolean {*    return a instanceof Animal;*  }* *  constructor(name: string) {*    this.name = name;*  }* *  move(distance: number) {*    console.log(`${this.name} moved ${distance}m.`);*  }* }* Public* public 代表公共的，表示被此访问限定符修饰的属性，方法可以任何地方访问到：1）类中 2）类的实例对象 3）类的子类中 4）子类的实例对象 等，默认所有类的属性和方法都是 public 修饰的* Protected* 在类和子类中访问，不能被类的实例对象访问也不能被子类的实例对象访问* Private* 在类的内部访问* 只读修饰符* readonly* 抽象类* 抽象类与抽象方法* abstract class Animal {*  abstract makeSound(): void;*  move(): void {*    console.log(&quot;Roaming the earth...&quot;);*  }* }* 抽象类的继承* class Bird extends Animal {*  makeSound(): void {*    console.log(&apos;Tuture tuture tuture.&apos;);*  }* }* 构造函数* 声明的 Animal 类型不包括构造函数 constructor 以及类中的静态方法和静态属性，就像实例对象中是不包含类的构造函数、静态方法和静态属性一样* 类与接口* 类实现接口* interface Alarm {*  alert(): void;* }* interface Light {*  lightOn(): void;*  lightOff(): void;* }* class Car implements Alarm, Light {*  alert() {*    console.log(&apos;Car alarm&apos;);*  }*  lightOn() {*    console.log(&apos;Car light on&apos;);*  }*  lightOff() {*    console.log(&apos;Car light off&apos;);*  }* }* class Door implements Alarm {*    alert() {*      console.log(&apos;Door alarm&apos;);*    }* }* 接口继承类* class Point {*  x: number;*  y: number; * }* interface Point3D extends Point {*  z: number;* }* 接口继承的是声明 Point 类时同时声明的用于注解类实例的那个类型, 而这个类型只包含类的实例属性和方法，所以接口继承类也是继承此类的实例属性和方法的类型* 类作为接口使用*  1）多个类实现同一个接口来复用接口的属性或者方法 2）一个类实现多个接口 3）接口也可以继承类，只不过是继承类声明时同时声明的同名类型 4）类作为接口使用，通过进一步应用类声明的两个内容来简化 React 组件代码，提高代码的逻辑性和可复用性* 13. 泛型* 配置TypeScript npx tsc --init* tsconfig.json* {      &quot;compilerOptions&quot;: {        &quot;outDir&quot;: &quot;./dist&quot; // 设置编译输出的文件夹      },      &quot;include&quot;: [        // 需要编译的ts文件一个*表示文件匹配**表示忽略文件的深度问题        &quot;./src/*.ts&quot;       ],      &quot;exclude&quot;: [&quot;node_modules&quot;, &quot;dist&quot;, &quot;*.test.ts&quot;] // 排除不需要编译的文件夹    }* * &quot;build:w&quot;: &quot;tsc -w&quot; // watch 模式* 类型的函数* function getTutureTutorialsInfo&lt;T, U&gt;(info: T[], profile: U): T[] {*  console.log(info.length);*  console.log(profile);*  return info;* }* getTutureTutorialsInfo&lt;string, object&gt;([&apos;hello tuture&apos;, &apos;hello world&apos;], { username: &apos;tuture&apos; });* 泛型是在调用时再限定类型* 我们在定义泛型的时候，是一系列类型变量，如 T 、 U 等，这些变量实际的类型我们在定义的时候是不知道的，只有在进行泛型调用的时候，由用户给定实际的类型，所以这里有一种延迟声明类型的作用。* 匿名函数泛型* const getTUtureTutorialsInfo: &lt;T&gt;(info: T[]) =&gt; T[] = (info) =&gt; {*  console.log(info.length);*  return info;* }* 泛型默认类型参数* &lt;T, U = number&gt;* 泛型数组 Array&lt;T&gt;* 类泛型* class TodoInput extends React.Component&lt;TodoInputProps, TodoInputState&gt;* 接口泛型* interface Profile&lt;T&gt; {*  username: string;*  nickName: string;*  avatar: string;*  age: T;* }* type ProfileWithAge = Profile&lt;string&gt;* 类型别名泛型* type Profile&lt;T&gt; = {*  username: string;*  age: T;* }* type ProfileWithAge = Profile&lt;string&gt;;* 泛型约束* type Profile&lt;T&gt; = {*  username: string;*  age: T;* }* function getTutureTutorialsInfo&lt;T, U extends Profile&lt;string&gt;&gt;(info: T[], profile: U): T[] {*  console.log(info.length);*  console.log(profile);*  return info;* }* * 类：* class Profile&lt;T&gt;{*  username: string;*  age: T;* }* 接口:* interface Profile&lt;T&gt; {*  username: string;*  age: T;* }* 类型别名：* type Profile&lt;T&gt; = {*  username: string;*  age: T;* }* duck typing* 当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。* TS 类型是鸭子类型, 是基于代码的实际样子来进行类型注解的* 构造函数的注解* interface ConstructorFunction&lt;C&gt; {*  new (): C;* }* 类在声明的时候会声明两个东西：1）用于注解此类实例的类型 2）以及此类的构造函数。* const profileConstructor: ConstructorFunction&lt;Profile&lt;string&gt;&gt; = Profile;* 注解构造函数* class Profile&lt;T&gt; {*  username: string;*  age: T;* }* class TutureProfile extends Profile&lt;string&gt; {*  github: string;*  remote: string[];* }* interface ConstructorFunction&lt;C&gt; {*  new (): C;* }* function createInstance&lt;A extends Profile&lt;string&gt;&gt;(B: ConstructorFunction&lt;A&gt;) {*  return new B();* }* const myTutureProfile = createInstance(TutureProfile);*/</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;/**
* 
* 1. origin data type: number, string, boolean, null, undefined, void, symbol, bigint
* 2. non-origin data type: object, a
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="TypeScript" scheme="http://hi2048.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>谈谈拖延症</title>
    <link href="http://hi2048.github.io/2021/01/09/%E8%B0%88%E8%B0%88%E6%8B%96%E5%BB%B6%E7%97%87/"/>
    <id>http://hi2048.github.io/2021/01/09/谈谈拖延症/</id>
    <published>2021-01-08T16:00:00.000Z</published>
    <updated>2021-09-09T08:24:54.630Z</updated>
    
    <content type="html"><![CDATA[<pre>1月1日新开这本日记，也为了督促自己后面多下些苦功。1. 先要读完手边的 The Moon and Sixpence2. 考取GCP3. 加强自己的英语听力和口语4. 学习管理方面的知识5. 开始理财并制定计划6. 加强锻炼并保持健康1月2日打牌1月3日打牌1月4日打牌1月5日刷微博，水贴1月6日刷微博，水贴1月7日打牌1月8日刷微博，水贴</pre><p><strong>我本可以</strong>， 不要让自己在将来后悔，需要正视并做出改变。</p><ol><li>把自己的目标大声讲出来<ul><li>周围人的压力会让你开始执行计划</li></ul></li><li>利用帕金森定律，设定一个Deadline</li><li>把大的目标<strong>分解</strong>成细小的目标</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;
1月1日
新开这本日记，也为了督促自己后面多下些苦功。
1. 先要读完手边的 The Moon and Sixpence
2. 考取GCP
3. 加强自己的英语听力和口语
4. 学习管理方面的知识
5. 开始理财并制定计划
6. 加强锻炼并保持健康

1月2日
打牌
      
    
    </summary>
    
      <category term="杂谈" scheme="http://hi2048.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="团队" scheme="http://hi2048.github.io/tags/%E5%9B%A2%E9%98%9F/"/>
    
      <category term="Scrum Master" scheme="http://hi2048.github.io/tags/Scrum-Master/"/>
    
  </entry>
  
  <entry>
    <title>理财杂谈</title>
    <link href="http://hi2048.github.io/2020/12/25/%E7%90%86%E8%B4%A2%E6%9D%82%E8%B0%88/"/>
    <id>http://hi2048.github.io/2020/12/25/理财杂谈/</id>
    <published>2020-12-24T16:00:00.000Z</published>
    <updated>2021-09-10T10:27:07.368Z</updated>
    
    <content type="html"><![CDATA[<p>  市场上通常没有好，更多的时候是<strong>更好</strong>，同样的，也很少有坏，更多的时候是<strong>更坏</strong>，所以更多的时候，我们是需要在更好与更坏中做出选择。</p><p>  市场本身并没有太过复杂，我们都可以总结出自己的好的<strong>交易系统</strong>，只是各种<strong>干扰太多并且太强</strong>，会让你迷失，所以第一个要做的就是<strong>坚守本心</strong>。</p><p>  交易系统需要<strong>简单且有效</strong>。总结起来就是<strong>资金，趋势，择时</strong>。</p><ol><li>可持续的热点</li><li>向上的趋势</li><li>龙头</li><li>在回调中入场，在趋势变坏时果断离场</li><li>果断的止损</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  市场上通常没有好，更多的时候是&lt;strong&gt;更好&lt;/strong&gt;，同样的，也很少有坏，更多的时候是&lt;strong&gt;更坏&lt;/strong&gt;，所以更多的时候，我们是需要在更好与更坏中做出选择。&lt;/p&gt;
&lt;p&gt;  市场本身并没有太过复杂，我们都可以总结出自己的好的&lt;str
      
    
    </summary>
    
      <category term="杂谈" scheme="http://hi2048.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="理财" scheme="http://hi2048.github.io/tags/%E7%90%86%E8%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>浅谈生活</title>
    <link href="http://hi2048.github.io/2020/11/05/%E6%B5%85%E8%B0%88%E7%94%9F%E6%B4%BB/"/>
    <id>http://hi2048.github.io/2020/11/05/浅谈生活/</id>
    <published>2020-11-04T16:00:00.000Z</published>
    <updated>2021-09-10T06:45:00.760Z</updated>
    
    <content type="html"><![CDATA[<p>生活就像一面镜子，你投入什么，它就会回应相同的东西。 所以当我在对着生活发怒，抱怨的时候，是不是应该想想，我投入了什么。</p><p>日子过得太快，每天都是机械的，重复的，唯一不同的是，孩子在慢慢长大，每当看着他那无忧无虑的笑声，我都会想为什么我不能也这样呢。如果仔细想想，却也是不大可能，因为我们有太多的东西要承担，这就注定了不能像孩子那样。但是幸运的是，在这里，我有记录，3年，5年，还有更早的自己，心境，以及生活。每每看到这些，我都会笑得像个孩子。这将让我可以更加坚定的站立在当下。</p><p>所以请放慢脚步，张开双臂，闭上眼睛，感受生活的伟大。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;生活就像一面镜子，你投入什么，它就会回应相同的东西。 所以当我在对着生活发怒，抱怨的时候，是不是应该想想，我投入了什么。&lt;/p&gt;
&lt;p&gt;日子过得太快，每天都是机械的，重复的，唯一不同的是，孩子在慢慢长大，每当看着他那无忧无虑的笑声，我都会想为什么我不能也这样呢。如果仔细想想
      
    
    </summary>
    
      <category term="杂谈" scheme="http://hi2048.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>团队的思考</title>
    <link href="http://hi2048.github.io/2020/10/19/%E5%9B%A2%E9%98%9F%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://hi2048.github.io/2020/10/19/团队的思考/</id>
    <published>2020-10-18T16:00:00.000Z</published>
    <updated>2021-09-09T08:10:14.242Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>交付与成长<br><pre>交付是团队存在的基础，成长是团队持续的核心。 团队成员的成长 ==〉高质量的交付</pre></p><ul><li>团队成员的成长</li><li>高质量的交付</li></ul></li><li><p>技术与方法<br>技术是IT行业的根本。技术可以贯穿整个IT团队，也是IT团队的灵魂，凝聚力的关键。方法则为技术铺平道路。</p><ul><li>技术：技术型团队，对技术保持初心，炙热</li><li>方法：敏捷开发，实践</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;交付与成长&lt;br&gt;&lt;pre&gt;交付是团队存在的基础，成长是团队持续的核心。 团队成员的成长 ==〉高质量的交付&lt;/pre&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;团队成员的成长&lt;/li&gt;
&lt;li&gt;高质量的交付&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;技术与方法&lt;
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="团队" scheme="http://hi2048.github.io/tags/%E5%9B%A2%E9%98%9F/"/>
    
      <category term="Scrum Master" scheme="http://hi2048.github.io/tags/Scrum-Master/"/>
    
  </entry>
  
  <entry>
    <title>腐烂的橘子一</title>
    <link href="http://hi2048.github.io/2020/09/09/%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/"/>
    <id>http://hi2048.github.io/2020/09/09/腐烂的橘子/</id>
    <published>2020-09-08T16:00:00.000Z</published>
    <updated>2021-08-09T14:47:31.828Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>腐烂的橘子</p><pre><code>在给定的网格中，每个单元格可以有以下三个值之一：0 空单元格, 1 新鲜橘子, 2 腐烂的橘子。每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。返回网格中没有新鲜橘子必须经过的最小分钟数。如果不可能，返回 -1。const isAllRotting = grid =&gt; {  for(let row of grid) {      for(let col of row) {          if(col === 1)              return false;      }  }  return true;}const isInGrid = (i, j, grid) =&gt; {  if(i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; grid.length &amp;&amp; j &lt; grid[i].length) {      return true;  }  return false;}const rotting = grid =&gt; {  const nextGrid = copyGrid(grid);  for(let i = 0; i &lt; grid.length; i++) {      for(let j = 0; j &lt; grid[i].length; j++) {          if(grid[i][j] === 2) {              if(isInGrid(i - 1, j, grid) &amp;&amp; nextGrid[i - 1][j] === 1) {                  nextGrid[i - 1][j] = 2;              }              if(isInGrid(i + 1, j, grid) &amp;&amp; nextGrid[i + 1][j] === 1) {                  nextGrid[i + 1][j] = 2;              }              if(isInGrid(i, j - 1, grid) &amp;&amp; nextGrid[i][j - 1] === 1) {                  nextGrid[i][j - 1] = 2;              }              if(isInGrid(i, j + 1, grid) &amp;&amp; nextGrid[i][j + 1] === 1) {                  nextGrid[i][j + 1] = 2;              }          }      }  }  return nextGrid;}const sameGrid = (grid, nextGrid) =&gt; {  for(let i = 0; i &lt; grid.length; i++) {      for(let j = 0; j &lt; grid[i].length; j++) {          if(grid[i][j] !== nextGrid[i][j]) {              return false;          }      }  }  return true;}const copyGrid = grid =&gt; {  let nextGrid = [];  for(let row of grid){      nextGrid.push(row.slice());  }  return nextGrid;}const orangesRotting = grid =&gt; {  let count = 0;  let nextGrid = grid;  while(!isAllRotting(nextGrid)){    if(count &gt; 0 &amp;&amp; sameGrid(grid, nextGrid)) {      return -1;    }    count++;    grid = nextGrid;    nextGrid = rotting(grid);  }  return count;};</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;腐烂的橘子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在给定的网格中，每个单元格可以有以下三个值之一：
0 空单元格, 1 新鲜橘子, 2 腐烂的橘子。
每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。
返回网格中没有新鲜橘子必须经过的最小分钟数
      
    
    </summary>
    
      <category term="设计与代码" scheme="http://hi2048.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://hi2048.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://hi2048.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://hi2048.github.io/tags/leetcode/"/>
    
  </entry>
  
</feed>
