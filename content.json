{"meta":{"title":"苏小蜂的个人博客","subtitle":"放慢脚步，享受生活！","description":null,"author":"Jsu","url":"http://hi2048.github.io","root":"/"},"pages":[{"title":"关于","date":"2013-08-18T10:02:40.000Z","updated":"2019-09-05T09:41:17.692Z","comments":true,"path":"about/index.html","permalink":"http://hi2048.github.io/about/index.html","excerpt":"","text":"To be, or not to be: that is a querstion. 每当要做出选择的时候，我总会想到上面的那句话。西大7年，哭过，笑过，疯狂过，累过，也伤心过。在这里的经历也是最宝贵的。 每当我回忆，这么久了，西大给我带来了什么，西大的什么让我不能忘怀，我找不到答案，但是每次心头都会浮现出四个字，公诚勤朴。 就要毕业了，再见了7年。 在西大，我爱这里，一草一木。"},{"title":"MY WORKS","date":"2013-08-18T10:03:03.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"my-works/index.html","permalink":"http://hi2048.github.io/my-works/index.html","excerpt":"","text":""}],"posts":[{"title":"学生出勤记录3","slug":"学生出勤记录3","date":"2021-11-21T16:00:00.000Z","updated":"2021-11-22T15:19:48.852Z","comments":true,"path":"2021/11/22/学生出勤记录3/","link":"","permalink":"http://hi2048.github.io/2021/11/22/学生出勤记录3/","excerpt":"","text":"/** * 学生出勤记录 II * 给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符： * &apos;A&apos;：Absent，缺勤 * &apos;L&apos;：Late，迟到 * &apos;P&apos;：Present，到场 * 如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励： * 按 总出勤 计，学生缺勤（&apos;A&apos;）严格 少于两天。 * 学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（&apos;L&apos;）记录。 * 给你一个整数 n，表示出勤记录的长度(次数)。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 数量 。答案可能很大，所以返回对 109 + 7 取余 结果。 * * method1: dfs * method2: dp * * @param {number} n * @return {number} */ var checkRecord = function(n) { const Mod = 1000000007; const dp = new Array(n).fill(0).map(() =&gt; new Array(2).fill(0).map(() =&gt; new Array(3).fill(0))); //p dp[0][0][0] = 1; //A dp[0][1][0] = 1; //L dp[0][0][1] = 1; for(let i = 1; i &lt; n; i++) { //p dp[i][0][0] = (dp[i - 1][0][0] + dp[i - 1][0][1] + dp[i - 1][0][2]) % Mod; dp[i][1][0] = (dp[i - 1][1][0] + dp[i - 1][1][1] + dp[i - 1][1][2]) % Mod; //A dp[i][1][0] = (dp[i][1][0] + dp[i - 1][0][0] + dp[i - 1][0][1] + dp[i - 1][0][2]) % Mod; //L dp[i][0][1] = dp[i - 1][0][0]; dp[i][0][2] = dp[i - 1][0][1]; dp[i][1][1] = dp[i - 1][1][0]; dp[i][1][2] = dp[i - 1][1][1]; } let sum = 0; for(let i = 0; i &lt; 2; i++) { for(let j = 0; j &lt; 3; j++) { sum = (sum + dp[n - 1][i][j]) % Mod; } } return sum; };","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hi2048.github.io/tags/算法/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://hi2048.github.io/tags/Leetcode/"}]},{"title":"study notes","slug":"study-notes-english","date":"2021-10-31T16:00:00.000Z","updated":"2021-11-10T04:42:03.212Z","comments":true,"path":"2021/11/01/study-notes-english/","link":"","permalink":"http://hi2048.github.io/2021/11/01/study-notes-english/","excerpt":"","text":"和则两利，斗则俱伤A peachful and harmonious bilateral relationship between these two countries will make both winners. While a confrontational one wil make both losers. 行百里者半九十Half of the people who have embarked on a one-hundred-mile journey may fail by the wayside. 华山再高，顶有过路No matter how hign the mountain is, one can always ascend to it’s top. 我深深爱着我的国家，没有一片土地让我这样深情和激动，没有一条河流让我这样沉思和祈福，余心之所善兮，虽九死而其尤未悔。I have deep love for this country. I love erery inch of its land. I love every river that flows on this piece of earth with deep passion and deep affection. For the ideal that I hold dear to my heart. I will not regret a thousand depth to die. 人或加讪，心无疵兮As a Chinese proverb goes, my conscience stays untained in spite of rumors and slanders from the outside. 兄弟虽有小忿，不废懿亲Differences between brothers cannot server their blood ties. 不畏浮云遮望眼，\b只缘身在最高层。As a Chinese poem reads, we have no fear of the clouds that may block our sight, as we are already at the top of the height. 入则恳恳以尽忠，出则谦谦以自诲When one is in office he should discharge his duty conscientiously. When leaving office he should conduct himself with humanity and exercise self-reflection. 苟利国家生死以，岂因祸福避趋之I shall dedicate myself to the interests of the country in life and death inrrespective of personal weal and woe. 知我罪我，其惟春秋There are people who will appreciate what I have done but there are also people who will criticize me. Ultimately, history will have the final say. 守职而不废，处义而不回In my last year in office, I will not waver and carrying out my duties, and will remain true to my conviction. I will always be with the people.","categories":[],"tags":[{"name":"英文","slug":"英文","permalink":"http://hi2048.github.io/tags/英文/"}]},{"title":"学生出勤记录2","slug":"学生出勤记录2","date":"2021-10-24T16:00:00.000Z","updated":"2021-11-22T15:19:25.851Z","comments":true,"path":"2021/10/25/学生出勤记录2/","link":"","permalink":"http://hi2048.github.io/2021/10/25/学生出勤记录2/","excerpt":"","text":"/** * 学生出勤记录 II * 给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符： * &apos;A&apos;：Absent，缺勤 * &apos;L&apos;：Late，迟到 * &apos;P&apos;：Present，到场 * 如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励： * 按 总出勤 计，学生缺勤（&apos;A&apos;）严格 少于两天。 * 学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（&apos;L&apos;）记录。 * 给你一个整数 n，表示出勤记录的长度(次数)。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 数量 。答案可能很大，所以返回对 109 + 7 取余 结果。 * * method1: dfs * method2: dp * * @param {number} n * @return {number} */ const dfs = (day, n, absents, lates, memo) =&gt; { if(day &gt;= n) return 1; if(memo[day][absents][lates] !== 0) return memo[day][absents][lates]; let ans = 0, MOD = 1000000007; //P ans = (ans + dfs(day + 1, n, absents, 0, memo)) % MOD; //A if(absents &lt; 1) { ans = (ans + dfs(day + 1, n, 1, 0, memo)) % MOD; } //L if(lates &lt; 2) { ans = (ans + dfs(day + 1, n, absents, lates + 1, memo)) % MOD; } memo[day][absents][lates] = ans; return ans; } var checkRecord = function(n) { const memo = new Array(n + 1).fill(0).map(() =&gt; new Array(2).fill(0).map(() =&gt; new Array(3).fill(0))); return dfs(0, n, 0, 0, memo); };","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hi2048.github.io/tags/算法/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://hi2048.github.io/tags/Leetcode/"}]},{"title":"排列硬币","slug":"排列硬币","date":"2021-10-09T16:00:00.000Z","updated":"2021-11-20T03:44:42.829Z","comments":true,"path":"2021/10/10/排列硬币/","link":"","permalink":"http://hi2048.github.io/2021/10/10/排列硬币/","excerpt":"","text":"/** * 排列硬币 * 你总共有 n 枚硬币，并计划将它们按阶梯状排列。对于一个由 k 行组成的阶梯，其第 i 行必须正好有 i 枚硬币。阶梯的最后一行 可能 是不完整的 * 给你一个数字 n ，计算并返回可形成 完整阶梯行 的总行数。 * @param {number} n * @return {number} */ const getTotal = n =&gt; { return (1 + n) * n / 2; } var arrangeCoins = function(n) { let maxRow = 0; for(let i = 0; i &lt;= n; i++) { if(getTotal(i) &lt;= n) { maxRow = i; } else { return maxRow; } } return maxRow; }; /** * @param {number} n * @return {number} */ var arrangeCoins = function(n) { let left = 1, right = n; while(left &lt; right) { const mid = Math.floor((right - left + 1) / 2) + left; if(n &gt;= mid * (mid + 1) / 2) { left = mid; } else { right = mid - 1; } } return left; };","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hi2048.github.io/tags/算法/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://hi2048.github.io/tags/Leetcode/"}]},{"title":"只有两个键的键盘","slug":"只有两个键的键盘","date":"2021-09-18T16:00:00.000Z","updated":"2021-11-26T03:59:12.191Z","comments":true,"path":"2021/09/19/只有两个键的键盘/","link":"","permalink":"http://hi2048.github.io/2021/09/19/只有两个键的键盘/","excerpt":"","text":"/** * 只有两个键的键盘 * 最初记事本上只有一个字符 &apos;A&apos; 。你每次可以对这个记事本进行两种操作： * Copy All（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。 * Paste（粘贴）：粘贴 上一次 复制的字符。 * 给你一个数字 n ，你需要使用最少的操作次数，在记事本上输出 恰好 n 个 &apos;A&apos; 。返回能够打印出 n 个 &apos;A&apos; 的最少操作次数。 * i = j * i/j, i % j === 0, j or i / j &lt; sqrt(i) * dp(i) = min(dp(i), dp(j) + i / j, dp(i / j) + j) * */ function minSteps(n: number): number { const dp = new Array(n + 1).fill(0); for(let i = 2; i &lt;= n; i++) { dp[i] = Number.MAX_SAFE_INTEGER; for(let j = 1; j &lt;= Math.sqrt(i); j++) { if(i % j === 0) { dp[i] = Math.min(dp[i], dp[j] + i / j); dp[i] = Math.min(dp[i], dp[i / j] + j); } } } return dp[n]; };","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hi2048.github.io/tags/算法/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://hi2048.github.io/tags/Leetcode/"}]},{"title":"系统性思维","slug":"系统性思维","date":"2021-08-31T16:00:00.000Z","updated":"2021-09-05T02:58:19.188Z","comments":true,"path":"2021/09/01/系统性思维/","link":"","permalink":"http://hi2048.github.io/2021/09/01/系统性思维/","excerpt":"","text":"系统性思维与局部性思维 系统性思维做出决策，然后在局部中做出选择 。 先有方向再有选择 ，而不是随便做出了选择，然后再从选择中确定方向。","categories":[],"tags":[]},{"title":"学生出勤记录1","slug":"学生出勤记录1","date":"2021-08-16T16:00:00.000Z","updated":"2021-11-22T15:18:59.679Z","comments":true,"path":"2021/08/17/学生出勤记录1/","link":"","permalink":"http://hi2048.github.io/2021/08/17/学生出勤记录1/","excerpt":"","text":"/** * 学生出勤记录 I * 给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符： * &apos;A&apos;：Absent，缺勤 * &apos;L&apos;：Late，迟到 * &apos;P&apos;：Present，到场 * 如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励： * 按 总出勤 计，学生缺勤（&apos;A&apos;）严格 少于两天。 * 学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（&apos;L&apos;）记录。 * 如果学生可以获得出勤奖励，返回 true ；否则，返回 false 。 * * @param {string} s * @return {boolean} */ var checkRecord = function(s) { let absents = 0, lates = 0; for(let i = 0; i &lt; s.length; i++) { const c = s[i]; if(c === &apos;A&apos;) { absents ++; if(absents &gt;= 2) { return false; } } if(c === &apos;L&apos;) { lates ++; if(lates &gt;= 3) { return false; } } else { lates = 0; } } return true; };","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hi2048.github.io/tags/算法/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://hi2048.github.io/tags/Leetcode/"}]},{"title":"连续子数组的最大和","slug":"连续子数组的最大和","date":"2021-07-16T16:00:00.000Z","updated":"2021-11-24T12:02:06.386Z","comments":true,"path":"2021/07/17/连续子数组的最大和/","link":"","permalink":"http://hi2048.github.io/2021/07/17/连续子数组的最大和/","excerpt":"","text":"/** * 剑指 Offer: 连续子数组的最大和 * 输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。 * 要求时间复杂度为O(n)。 * dp(i)以i结尾的连续最大子数组 * dp(i - 1) &lt;= 0, dp(i) = n[i] * dp(i - 1 ) &gt; 0, dp(i) = dp(i - 1) + n[i] * * @param {number[]} nums * @return {number} */ var maxSubArray = function(nums) { const dp = new Array(nums.length).fill(nums[0]); let max = nums[0]; for(let i = 1; i &lt; nums.length; i++) { if(dp[i - 1] &lt;= 0) { dp[i] = nums[i]; } else { dp[i] = dp[i - 1] + nums[i]; } max = Math.max(max, dp[i]); } return max; }; var maxSubArray = function(nums) { let dp = nums[0], max = nums[0]; for(let i = 1; i &lt; nums.length; i++) { if(dp &lt;= 0) { dp = nums[i]; } else { dp += nums[i]; } max = Math.max(max, dp); } return max; }; var maxSubArray = function(nums) { let dp = nums[0], max = nums[0]; for(let i = 1; i &lt; nums.length; i++) { dp = Math.max(dp + nums[i], nums[i]); max = Math.max(max, dp); } return max; };","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hi2048.github.io/tags/算法/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://hi2048.github.io/tags/Leetcode/"}]},{"title":"石子游戏","slug":"石子游戏","date":"2021-06-15T16:00:00.000Z","updated":"2021-11-25T04:53:11.191Z","comments":true,"path":"2021/06/16/石子游戏/","link":"","permalink":"http://hi2048.github.io/2021/06/16/石子游戏/","excerpt":"","text":"/** * 石子游戏 * * 亚历克斯和李 用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。 * 游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。 * 亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。 * 假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。 * dp(i)(j) [i, j]中当前玩家与另一玩家的差值 * dp(i)(i) = piles[i] * dp(i)(j) = max(piles[i] - dp(i + 1)(j), piles[j] - dp(i)(j - 1) ) * * @param {number[]} piles * @return {boolean} */ var stoneGame = function(piles) { const dp = new Array(piles.length).fill(0).map((arrItem1, i) =&gt; new Array(piles.length).fill(0).map((arrItem2, j) =&gt; { if(i == j) { return piles[i]; } else { return 0; } })); for(let i = piles.length - 2; i &gt;= 0; i--) { for(let j = i + 1; j &lt; piles.length; j++) { dp[i][j] = Math.max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1]); } } return dp[0][piles.length - 1] &gt; 0; };","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hi2048.github.io/tags/算法/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://hi2048.github.io/tags/Leetcode/"}]},{"title":"Scrum笔记","slug":"Scrum笔记","date":"2021-05-02T06:21:41.000Z","updated":"2021-09-05T02:24:18.442Z","comments":true,"path":"2021/05/02/Scrum笔记/","link":"","permalink":"http://hi2048.github.io/2021/05/02/Scrum笔记/","excerpt":"","text":"Scrum 采用迭代、增量的方法来优化可预见性并控制风险。","categories":[],"tags":[]},{"title":"商品折扣后的最终价格","slug":"商品折扣后的最终价格","date":"2021-04-05T16:00:00.000Z","updated":"2021-11-20T02:05:41.003Z","comments":true,"path":"2021/04/06/商品折扣后的最终价格/","link":"","permalink":"http://hi2048.github.io/2021/04/06/商品折扣后的最终价格/","excerpt":"","text":"/** * 给你一个数组 prices ，其中 prices[i] 是商店里第 i 件商品的价格。 * 商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 prices[j] 相等的折扣， * 其中 j 是满足 j &gt; i 且 prices[j] &lt;= prices[i]的 最小下标 ，如果没有满足条件的 j ，你将没有任何折扣。 * 请你返回一个数组，数组中第 i 个元素是折扣后你购买商品 i 最终需要支付的价格。 * * Notice: ** Array.sort ** will change the original array, ** Array.map ** will not change the original array, and both will return new created array * * @param {number[]} prices * @return {number[]} */ const getDiscount = (prices, index) =&gt; { for(let i = index + 1; i &lt; prices.length; i++) { if(prices[i] &lt;= prices[index]) { return prices[i] } } return 0; } var finalPrices = function(prices) { return prices.map((price, index, prices) =&gt; price - getDiscount(prices, index)); };","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hi2048.github.io/tags/算法/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://hi2048.github.io/tags/Leetcode/"}]},{"title":"俄罗斯套娃信封问题","slug":"俄罗斯套娃信封问题","date":"2021-03-14T16:00:00.000Z","updated":"2021-11-19T11:35:33.661Z","comments":true,"path":"2021/03/15/俄罗斯套娃信封问题/","link":"","permalink":"http://hi2048.github.io/2021/03/15/俄罗斯套娃信封问题/","excerpt":"","text":"/** * 俄罗斯套娃信封问题 * 给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。 * 当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。 * 请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。 * @param {number[][]} envelopes * @return {number} * envelopes sort by first value, and sort by second value for the same first value envelopes * dp(i) = max(dp(i), dp(j) + 1) */ var maxEnvelopes = function(envelopes) { const dp = new Array(envelopes.length).fill(1); envelopes.sort((item1, item2) =&gt; { return item1[0] - item2[0]; }).sort((item1, item2) =&gt; { if(item1[0] === item2[0]) { return item2[1] - item1[1]; } return 0; }); for(let i = 0; i &lt; envelopes.length; i++ ) { for(let j = 0; j &lt; i; j++) { if(envelopes[i][1] &gt; envelopes[j][1]) { dp[i] = Math.max(dp[i], dp[j] + 1); } } } return Math.max(...dp); };","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hi2048.github.io/tags/算法/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://hi2048.github.io/tags/Leetcode/"}]},{"title":"最长递增子序列","slug":"最长递增子序列","date":"2021-02-04T16:00:00.000Z","updated":"2021-11-19T11:32:13.065Z","comments":true,"path":"2021/02/05/最长递增子序列/","link":"","permalink":"http://hi2048.github.io/2021/02/05/最长递增子序列/","excerpt":"","text":"/** * 最长递增子序列 * 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 * @param {number[]} nums * @return {number} * dp(i) = max(dp(i), dp(j) + 1) */ var lengthOfLIS = function(nums) { const dp = new Array(nums.length).fill(1); for(let i = 0; i &lt; nums.length; i++) { for(let j = 0; j &lt; i; j++) { if(nums[j] &lt; nums[i]) { dp[i] = Math.max(dp[i], dp[j] + 1); } } } return Math.max(...dp); };","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hi2048.github.io/tags/算法/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://hi2048.github.io/tags/Leetcode/"}]},{"title":"理财笔记","slug":"理财笔记","date":"2021-01-31T16:00:00.000Z","updated":"2021-09-12T16:05:41.164Z","comments":true,"path":"2021/02/01/理财笔记/","link":"","permalink":"http://hi2048.github.io/2021/02/01/理财笔记/","excerpt":"","text":"市场概率：1. 胜率 2. 赔率： 即盈亏比 3. 破产率：仓位控制或者资金管理 赔率才是交易员要考虑的根本问题。你正确或错误并不是最重要的，最重要的是你正确的时候能赚多少钱，错误的时候会亏多少钱。 – 索罗斯 赚大赔小，生存第一。 第一保住本金，第二保住本金，第三认真考虑第一第二条。 – 巴菲特 一律：纪律，用纪律去统领一切概率的可能性。 1. 胜败：趋势掌控能力，行情是否按照计划的大概率事件进行 2. 对错：计划执行能力，整体策略的执行力结果 3. 盈亏 信念： 大道至简，坚信自己可以成功，信念的坚定其实是中庸之道。 左倾冒进主义： 盲目自信，扛单，频繁交易，重仓交易，赌气交易。右倾投降主义： 做单太谨小慎微，明明是很好的机会，不敢下单，错失机会。 知识与智慧： 知识是可以通过学习获得，智慧只能通过体悟和实践获得。 熟知与真知： 通过学习知道与通过实践知道的区别。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hi2048.github.io/categories/杂谈/"}],"tags":[{"name":"理财","slug":"理财","permalink":"http://hi2048.github.io/tags/理财/"}]},{"title":"TypeScript notes","slug":"TypeScript-notes","date":"2021-01-08T16:00:00.000Z","updated":"2021-11-27T07:03:34.058Z","comments":true,"path":"2021/01/09/TypeScript-notes/","link":"","permalink":"http://hi2048.github.io/2021/01/09/TypeScript-notes/","excerpt":"","text":"origin data type: number, string, boolean, null, undefined, void, symbol, bigint non-origin data type: object, array, tuple, enum const arr: string[] = [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;] const tuple: [string, number, string] = [&apos;1&apos;, 2, &apos;3&apos;] any, unknown, neverany 类型的变量是可以进行任意进行赋值、实例化、函数执行等操作，但是 unknown 只允许赋值，不允许实例化、函数执行等操作never 的字面意思是 “永不”，在 TS 中代表不存在的值类型，一般用于给函数进行类型声明，函数绝不会有返回值的时候使用，比如函数内抛出错误 interface interface Todo { content: string; readonly user: string; time?: string; isComplete: boolean; [propName: string]: any; } enum enum UserId { tuture = &apos;666&apos;, mRcfps = 6, } 函数类型 const add: (x: number, y: number, z?: number): number = function(x, y) { // ... return x + y; } 7.1 交叉类型 &amp; interface ErrorHandling { success: boolean; error?: { message: string }; } interface ArtistsData { artists: { name: string }[]; } const handleArtistsResponse = (response: ArtistsData &amp; ErrorHandling) =&gt; { if(response.error) { console.error(response.error.message); return; } console.log(response.artists); } 7.2 联合类型 | const padLeft = (value: string, padding: string | number) =&gt; void 字面量类型字面量可是说是 TS 类型系统里面最小的类型。数字字面量let tuture: 520字符串字面量let tuture: ‘520’ 类型守卫联合类型+字面量类型主要用于在进行 ”联合“ 的多个类型之间，存在相同的字段，也存在不同的字段，然后需要区分具体什么时候是使用哪个类型 类型别名 type NameParams = &apos;string&apos; | () =&gt; &apos;string&apos;; function getName(n: NameParams): string {} 类型别名与接口 type name = &apos;string&apos; type tuture ={ tutureCommunity: string; editure: string; tutureDocs: string; } interface Tuture { tutureCommunity: string; editure: string; tutureDocs: string; } 类ES6构造函数属性实例属性静态属性方法实例方法静态方法TS注解构造函数注解属性访问限定符: public/protected/private修饰符: readonly注解方法访问限定符: public/protected/private class Animal { name: string; static isAnimal(a: Animal): boolean { return a instanceof Animal; } constructor(name: string) { this.name = name; } move(distance: number) { console.log(`${this.name} moved ${distance}m.`); } } Publicpublic 代表公共的，表示被此访问限定符修饰的属性，方法可以任何地方访问到：1）类中 2）类的实例对象 3）类的子类中 4）子类的实例对象 等，默认所有类的和方法都是 public 修饰的Protected在类和子类中访问，不能被类的实例对象访问也不能被子类的实例对象访问Private在类的内部访问只读修饰符readonly抽象类抽象类与抽象方法 abstract class Animal { abstract makeSound(): void; move(): void { console.log(&quot;Roaming the earth...&quot;); } } 抽象类的继承 class Bird extends Animal { makeSound(): void { console.log(&apos;Tuture tuture tuture.&apos;); } } 构造函数声明的 Animal 类型不包括构造函数 constructor 以及类中的静态方法和静态属性，就像实例对象中是不包含类的构造函数、静态方法和静态属性一样类与接口类实现接口 interface Alarm { alert(): void; } interface Light { lightOn(): void; lightOff(): void; } class Car implements Alarm, Light { alert() { console.log(&apos;Car alarm&apos;); } lightOn() { console.log(&apos;Car light on&apos;); } lightOff() { console.log(&apos;Car light off&apos;); } } class Door implements Alarm { alert() { console.log(&apos;Door alarm&apos;); } } 接口继承类 class Point { x: number; y: number; } interface Point3D extends Point { z: number; } 接口继承的是声明 Point 类时同时声明的用于注解类实例的那个类型, 而这个类型只包含类的实例属性和方法，所以接口继承类也是继承此类的实例属性和方法的类型类作为接口使用1）多个类实现同一个接口来复用接口的属性或者方法 2）一个类实现多个接口 3）接口也可以继承类，只不过是继承类声明时同时声明的同名类型 4）类作为接口，通过进一步应用类声明的两个内容来简化 React 组件代码，提高代码的逻辑性和可复用性 泛型配置TypeScript npx tsc –init tsconfig.json { &quot;compilerOptions&quot;: { &quot;outDir&quot;: &quot;./dist&quot; // 设置编译输出的文件夹 }, &quot;include&quot;: [ // 需要编译的ts文件一个*表示文件匹配**表示忽略文件的深度问题 &quot;./src/**/*.ts&quot; ], &quot;exclude&quot;: [&quot;node_modules&quot;, &quot;dist&quot;, &quot;**/*.test.ts&quot;] // 排除不需要编译的文件夹 } &quot;build:w&quot;: &quot;tsc -w&quot; // watch 模式 类型的函数 function getTutureTutorialsInfo&lt;T, U&gt;(info: T[], profile: U): T[] { console.log(info.length); console.log(profile); return info; } getTutureTutorialsInfo&lt;string, object&gt;([&apos;hello tuture&apos;, &apos;hello world&apos;], { username: &apos;tuture&apos; }); 泛型是在调用时再限定类型我们在定义泛型的时候，是一系列类型变量，如 T 、 U 等，这些变量实际的类型我们在定义的时候是不知道的，只有在进行泛型调用的时候，由用户给定实际的类型以这里有一种延迟声明类型的作用。匿名函数泛型 const getTUtureTutorialsInfo: &lt;T&gt;(info: T[]) =&gt; T[] = (info) =&gt; { console.log(info.length); return info; } 泛型默认类型参数&lt;T, U = number&gt;泛型数组 Array类泛型class TodoInput extends React.Component&lt;TodoInputProps, TodoInputState&gt;接口泛型 interface Profile&lt;T&gt; { username: string; nickName: string; avatar: string; age: T; } type ProfileWithAge = Profile&lt;string&gt; 类型别名泛型 type Profile&lt;T&gt; = { username: string; age: T; } type ProfileWithAge = Profile&lt;string&gt;; 泛型约束 type Profile&lt;T&gt; = { username: string; age: T; } function getTutureTutorialsInfo&lt;T, U extends Profile&lt;string&gt;&gt;(info: T[], profile: U): T[] { console.log(info.length); console.log(profile); return info; } 类： class Profile{ username: string; age: T; } 接口: interface Profile { username: string; age: T; } 类型别名： type Profile = { username: string; age: T; } duck typing当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。TS 类型是鸭子类型, 是基于代码的实际样子来进行类型注解的构造函数的注解 interface ConstructorFunction { new (): C; } 类在声明的时候会声明两个东西：1）用于注解此类实例的类型 2）以及此类的构造函数。 const profileConstructor: ConstructorFunction&lt;Profile&gt; = Profile; 注解构造函数 class Profile { username: string; age: T; } class TutureProfile extends Profile { github: string; remote: string[]; } interface ConstructorFunction { new (): C; } function createInstance&lt;A extends Profile&gt;(B: ConstructorFunction) { return new B(); } const myTutureProfile = createInstance(TutureProfile); 参考：一只图雀 类型即正义","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://hi2048.github.io/tags/TypeScript/"}]},{"title":"谈谈拖延症","slug":"谈谈拖延症","date":"2021-01-08T16:00:00.000Z","updated":"2021-09-09T08:24:54.630Z","comments":true,"path":"2021/01/09/谈谈拖延症/","link":"","permalink":"http://hi2048.github.io/2021/01/09/谈谈拖延症/","excerpt":"","text":"1月1日 新开这本日记，\b也为了督促自己后面多下些苦功。 1. 先要读完手边的 The Moon and Sixpence 2. 考取GCP 3. 加强自己的英语听力和口语 4. 学习管理方面的知识 5. 开始理财并制定计划 6. 加强锻炼并保持健康 1月2日 打牌 1月3日 打牌 1月4日 打牌 1月5日 刷微博，水贴 1月6日 刷微博，水贴 1月7日 打牌 1月8日 刷微博，水贴 我本可以， 不要让自己在将来后悔，需要正视并做出改变。 把自己的目标大声讲出来 周围人的压力会让你开始执行计划 利用帕金森定律，设定一个Deadline 把大的目标分解成细小的目标","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hi2048.github.io/categories/杂谈/"}],"tags":[{"name":"团队","slug":"团队","permalink":"http://hi2048.github.io/tags/团队/"},{"name":"Scrum Master","slug":"Scrum-Master","permalink":"http://hi2048.github.io/tags/Scrum-Master/"}]},{"title":"理财杂谈","slug":"理财杂谈","date":"2020-12-24T16:00:00.000Z","updated":"2021-09-10T10:27:07.368Z","comments":true,"path":"2020/12/25/理财杂谈/","link":"","permalink":"http://hi2048.github.io/2020/12/25/理财杂谈/","excerpt":"","text":"市场上通常没有好，更多的时候是更好，同样的，也很少有坏，更多的时候是更坏，所以更多的时候，我们是需要在更好与更坏中做出选择。 市场本身并没有太过复杂，我们都可以总结出自己的好的交易系统，只是各种干扰太多并且太强，会让你迷失，所以第一个要做的就是坚守本心。 交易系统需要简单且有效。总结起来就是资金，趋势，择时。 可持续的热点 向上的趋势 龙头 在回调中入场，在趋势变坏时果断离场 果断的止损","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hi2048.github.io/categories/杂谈/"}],"tags":[{"name":"理财","slug":"理财","permalink":"http://hi2048.github.io/tags/理财/"}]},{"title":"浅谈生活","slug":"浅谈生活","date":"2020-11-04T16:00:00.000Z","updated":"2021-09-10T06:45:00.760Z","comments":true,"path":"2020/11/05/浅谈生活/","link":"","permalink":"http://hi2048.github.io/2020/11/05/浅谈生活/","excerpt":"","text":"生活就像一面镜子，你投入什么，它就会回应相同的东西。 所以当我在对着生活发怒，抱怨的时候，是不是应该想想，我投入了什么。 日子过得太快，每天都是机械的，重复的，唯一不同的是，孩子在慢慢长大，每当看着他那无忧无虑的笑声，我都会想为什么我不能也这样呢。如果仔细想想，却也是不大可能，因为我们有太多的东西要承担，这就注定了不能像孩子那样。但是幸运的是，在这里，我有记录，3年，5年，还有更早的自己，心境，以及生活。每每看到这些，我都会笑得像个孩子。这将让我可以更加坚定的站立在当下。 所以请放慢脚步，张开双臂，闭上眼睛，感受生活的伟大。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hi2048.github.io/categories/杂谈/"}],"tags":[]},{"title":"团队的思考","slug":"团队的思考","date":"2020-10-18T16:00:00.000Z","updated":"2021-09-09T08:10:14.242Z","comments":true,"path":"2020/10/19/团队的思考/","link":"","permalink":"http://hi2048.github.io/2020/10/19/团队的思考/","excerpt":"","text":"交付与成长交付是团队存在的基础，成长是团队持续的核心。 团队成员的成长 ==〉高质量的交付 团队成员的成长 高质量的交付 技术与方法技术是IT行业的根本。技术可以贯穿整个IT团队，也是IT团队的灵魂，凝聚力的关键。方法则为技术铺平道路。 技术：技术型团队，对技术保持初心，炙热 方法：敏捷开发，实践","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"团队","slug":"团队","permalink":"http://hi2048.github.io/tags/团队/"},{"name":"Scrum Master","slug":"Scrum-Master","permalink":"http://hi2048.github.io/tags/Scrum-Master/"}]},{"title":"腐烂的橘子一","slug":"腐烂的橘子","date":"2020-09-08T16:00:00.000Z","updated":"2021-08-09T14:47:31.828Z","comments":true,"path":"2020/09/09/腐烂的橘子/","link":"","permalink":"http://hi2048.github.io/2020/09/09/腐烂的橘子/","excerpt":"","text":"腐烂的橘子 在给定的网格中，每个单元格可以有以下三个值之一： 0 空单元格, 1 新鲜橘子, 2 腐烂的橘子。 每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。 返回网格中没有新鲜橘子必须经过的最小分钟数。如果不可能，返回 -1。 const isAllRotting = grid =&gt; { for(let row of grid) { for(let col of row) { if(col === 1) return false; } } return true; } const isInGrid = (i, j, grid) =&gt; { if(i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; grid.length &amp;&amp; j &lt; grid[i].length) { return true; } return false; } const rotting = grid =&gt; { const nextGrid = copyGrid(grid); for(let i = 0; i &lt; grid.length; i++) { for(let j = 0; j &lt; grid[i].length; j++) { if(grid[i][j] === 2) { if(isInGrid(i - 1, j, grid) &amp;&amp; nextGrid[i - 1][j] === 1) { nextGrid[i - 1][j] = 2; } if(isInGrid(i + 1, j, grid) &amp;&amp; nextGrid[i + 1][j] === 1) { nextGrid[i + 1][j] = 2; } if(isInGrid(i, j - 1, grid) &amp;&amp; nextGrid[i][j - 1] === 1) { nextGrid[i][j - 1] = 2; } if(isInGrid(i, j + 1, grid) &amp;&amp; nextGrid[i][j + 1] === 1) { nextGrid[i][j + 1] = 2; } } } } return nextGrid; } const sameGrid = (grid, nextGrid) =&gt; { for(let i = 0; i &lt; grid.length; i++) { for(let j = 0; j &lt; grid[i].length; j++) { if(grid[i][j] !== nextGrid[i][j]) { return false; } } } return true; } const copyGrid = grid =&gt; { let nextGrid = []; for(let row of grid){ nextGrid.push(row.slice()); } return nextGrid; } const orangesRotting = grid =&gt; { let count = 0; let nextGrid = grid; while(!isAllRotting(nextGrid)){ if(count &gt; 0 &amp;&amp; sameGrid(grid, nextGrid)) { return -1; } count++; grid = nextGrid; nextGrid = rotting(grid); } return count; };","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hi2048.github.io/tags/算法/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"leetcode","slug":"leetcode","permalink":"http://hi2048.github.io/tags/leetcode/"}]},{"title":"剑雨有感","slug":"剑雨有感","date":"2020-08-05T16:00:00.000Z","updated":"2021-08-06T11:09:15.321Z","comments":true,"path":"2020/08/06/剑雨有感/","link":"","permalink":"http://hi2048.github.io/2020/08/06/剑雨有感/","excerpt":"","text":"佛陀阿难出家前，在道上见一美貌少女，从此爱慕难舍。佛祖问他：你有多喜欢那少女？ 阿难回答： 愿化身为青石桥，受五百年风吹，五百年日晒，五百年雨打， 只求那少女从桥上走过。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hi2048.github.io/categories/杂谈/"}],"tags":[]},{"title":"数组中有效三角形的数量","slug":"数组中有效三角形的数量","date":"2020-07-11T16:00:00.000Z","updated":"2021-08-04T10:04:22.637Z","comments":true,"path":"2020/07/12/数组中有效三角形的数量/","link":"","permalink":"http://hi2048.github.io/2020/07/12/数组中有效三角形的数量/","excerpt":"","text":"数组nums中有效三角形的数量 var triangleNumber = function(nums) { let count = 0; nums.sort((a, b) =&gt; a - b); for(let i = nums.length - 1; i &gt;= 2; i--) { let j = i - 1, k = 0; while(k &lt; j) { if(nums[k] + nums[j] &gt; nums[i]) { count += j - k; j--; } else { k++; } } } return count; };","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hi2048.github.io/tags/算法/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"}]},{"title":"SMART原则","slug":"SMART原则","date":"2020-06-07T16:00:00.000Z","updated":"2021-08-04T04:41:48.617Z","comments":true,"path":"2020/06/08/SMART原则/","link":"","permalink":"http://hi2048.github.io/2020/06/08/SMART原则/","excerpt":"","text":"SMART原则（S=Specific、M=Measurable、A=Attainable、R=Relevant、T=Time-bound） 绩效指标必须是具体的（Specific） 绩效指标必须是可以衡量的（Measurable） 绩效指标必须是可以达到的（Attainable） 绩效指标是要与其他目标具有一定的相关性(Relevant) 绩效指标必须具有明确的截止期限（Time-bound）","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"Agile","slug":"Agile","permalink":"http://hi2048.github.io/tags/Agile/"}]},{"title":"GCP","slug":"GCP","date":"2020-05-24T16:00:00.000Z","updated":"2021-08-04T04:36:32.442Z","comments":true,"path":"2020/05/25/GCP/","link":"","permalink":"http://hi2048.github.io/2020/05/25/GCP/","excerpt":"","text":"Computer Engine, App Engine HTTPS load balance Stackdriver Datastore BigQuery Cloud Pub/Sub Cloud storage Cloud Dataflow Cloud Endpoints Cloud SQL Hadoop/Spark Cloud dataproc Jenkins Cloud BigTable Cloud Memorystore Cloud Datastore k8s(Kubernetes)/Containers Cloud Marketplace CDN Local SSD, SSD persistent disks Cloud VPN Cloud Functions CSEK Firewall rules ETL","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"GCP","slug":"GCP","permalink":"http://hi2048.github.io/tags/GCP/"}]},{"title":"logger","slug":"logger","date":"2020-04-11T16:00:00.000Z","updated":"2021-08-04T04:36:35.137Z","comments":true,"path":"2020/04/12/logger/","link":"","permalink":"http://hi2048.github.io/2020/04/12/logger/","excerpt":"","text":"– logger github npm demo -- index.js import { isFunction, isString } from &apos;../type&apos;; const log = type =&gt; (target, name, descriptor) =&gt; { if(isFunction(target[name])) { const originFunction = descriptor.value; descriptor.value = function(...args) { console.log(`${target.constructor.name}: `); console.log(`${type} start: ${name} (${args}).`); try { const ret = originFunction.call(this, ...args); console.log(`${type} succeed: ${name} (${args} =&gt; ${ret}).`); } catch(err) { console.log(`${type} failed: ${name} (${args} =&gt; ${err}).`); } } } return descriptor; } export const logger = (...args) =&gt; { if(!isString(args[0])) { return log(&apos;&apos;)(...args); } return log(...args); }","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"hi2048","slug":"hi2048","permalink":"http://hi2048.github.io/tags/hi2048/"},{"name":"hi2048-utils","slug":"hi2048-utils","permalink":"http://hi2048.github.io/tags/hi2048-utils/"}]},{"title":"creater","slug":"creater","date":"2020-03-19T16:00:00.000Z","updated":"2021-08-04T04:36:40.407Z","comments":true,"path":"2020/03/20/creater/","link":"","permalink":"http://hi2048.github.io/2020/03/20/creater/","excerpt":"","text":"– creater github npm demo -- index.js import { isFunction } from &apos;../type&apos;; export const creater = Target =&gt; config =&gt; class { constructor(...args) { if(isFunction(config)) { return new Target(config, ...args); } return new Target(Object.assign(config, ...args)); } }; const builder = creater =&gt; array =&gt; array.map(item =&gt; creater(item)); export const factory = Target =&gt; builder(creater(Target));","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"hi2048","slug":"hi2048","permalink":"http://hi2048.github.io/tags/hi2048/"},{"name":"hi2048-utils","slug":"hi2048-utils","permalink":"http://hi2048.github.io/tags/hi2048-utils/"}]},{"title":"unicode","slug":"unicode","date":"2020-03-07T16:00:00.000Z","updated":"2020-03-14T19:09:03.238Z","comments":true,"path":"2020/03/08/unicode/","link":"","permalink":"http://hi2048.github.io/2020/03/08/unicode/","excerpt":"","text":"– unicode github npm demo -- index.js import { isFunction } from &apos;../type&apos;; import { random } from &apos;../random&apos;; import { familyNames, firstNames } from &apos;./index.config&apos;; export const encode = str =&gt; `\\\\u${Array.from(str).map(char =&gt; `00${char.charCodeAt().toString(16)}`.slice(-4)).join(&apos;\\\\u&apos;)}`; export const decode = par =&gt; { let str = par; if(isFunction(par)) { str = par(); } return unescape(str.replace(/\\\\/g, &apos;%&apos;)); }; export const create = () =&gt; `\\\\u${(random(20901) + 19968).toString(16)}`; export const createWord = () =&gt; decode(create); export const createRandomName = () =&gt; { const count = random(2, 4); const result = []; for(let i = 0; i &lt; count; i++) { result.push(createWord()); } return result.join(&apos;&apos;); }; export const createName = () =&gt; { return `${familyNames[random(familyNames.length)]}${firstNames[random(firstNames.length)]}`; }; export const unicode = { encode, decode, create, createWord, createName, createRandomName }; -- index.test.js import { encode, decode, create, createWord, createName, createRandomName } from &apos;.&apos;; test(&apos;encode&apos;, () =&gt; expect(encode(&apos;苏小蜂&apos;)).toBe(&quot;\\\\u82cf\\\\u5c0f\\\\u8702&quot;)); test(&apos;decode&apos;, () =&gt; expect(decode(&apos;\\\\u82cf\\\\u5c0f\\\\u8702&apos;)).toBe(&apos;苏小蜂&apos;)); test(&apos;create&apos;, () =&gt; expect(create()).toBeDefined()); test(&apos;create&apos;, () =&gt; expect(createWord()).toBeDefined()); test(&apos;create&apos;, () =&gt; expect(createName()).toBeDefined()); test(&apos;create&apos;, () =&gt; expect(createRandomName()).toBeDefined());","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"hi2048","slug":"hi2048","permalink":"http://hi2048.github.io/tags/hi2048/"},{"name":"hi2048-utils","slug":"hi2048-utils","permalink":"http://hi2048.github.io/tags/hi2048-utils/"}]},{"title":"简单对象","slug":"简单对象","date":"2020-03-05T16:00:00.000Z","updated":"2020-03-14T19:08:17.499Z","comments":true,"path":"2020/03/06/简单对象/","link":"","permalink":"http://hi2048.github.io/2020/03/06/简单对象/","excerpt":"","text":"– isPlainObject github npm demo -- index.js import { isObject } from &apos;../type&apos;; export const isPlainObject = obj =&gt; { if(isObject(obj)) { return Object.getPrototypeOf(obj) === Object.prototype; } return false; }; -- index.test.js import { isPlainObject } from &apos;.&apos;; test(&quot;isPlainObject&quot;, () =&gt; expect(isPlainObject({ x: 1 })).toBeTruthy()); test(&quot;isPlainObject&quot;, () =&gt; expect(isPlainObject(new Object({ x: 1 }))).toBeTruthy()); test(&quot;isPlainObject&quot;, () =&gt; expect(isPlainObject(new class Test{})).toBeFalsy());","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"hi2048","slug":"hi2048","permalink":"http://hi2048.github.io/tags/hi2048/"},{"name":"hi2048-utils","slug":"hi2048-utils","permalink":"http://hi2048.github.io/tags/hi2048-utils/"}]},{"title":"array基本操作","slug":"array基本操作","date":"2020-02-24T16:00:00.000Z","updated":"2020-03-14T19:07:33.558Z","comments":true,"path":"2020/02/25/array基本操作/","link":"","permalink":"http://hi2048.github.io/2020/02/25/array基本操作/","excerpt":"","text":"– array github npm demo -- index.js export const add = array =&gt; item =&gt; array.push(item); export const remove = array =&gt; item =&gt; array = array.filter(v =&gt; v !== item); export const array = { add, remove };","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"hi2048","slug":"hi2048","permalink":"http://hi2048.github.io/tags/hi2048/"},{"name":"hi2048-utils","slug":"hi2048-utils","permalink":"http://hi2048.github.io/tags/hi2048-utils/"}]},{"title":"curry, compose and pipe","slug":"curry-compose-and-pipe","date":"2020-02-19T16:00:00.000Z","updated":"2020-02-29T12:51:42.148Z","comments":true,"path":"2020/02/20/curry-compose-and-pipe/","link":"","permalink":"http://hi2048.github.io/2020/02/20/curry-compose-and-pipe/","excerpt":"","text":"– curry, compose, pipe实现 github npm -- index.js /** * * @param {...function} funs * f1, f2, f3 ... = f1(f2(f3(...))) */ const compose = (...funs) =&gt; funs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args))); /** * * @param {...function} funs * f1, f2, f3 ... = ...f3(f2(f1(args))) */ const pipe = (...funs) =&gt; compose(...funs.reverse()); /** * * @param {function} fun * @param {array} args * f(a, b, c, ...) = f(a)(b)(c)... */ const curry = (fun, args = []) =&gt; args.length === fun.length?fun(...args) : (...arg1) =&gt; curry(fun, [...args, ...arg1]); module.exports = { compose, pipe, curry }; -- index.test.js const assert = require(&apos;assert&apos;); const { compose, pipe, curry } = require(&apos;.&apos;); assert.equal(compose(Math.abs, a =&gt; a + 1, a =&gt; Math.pow(a, 2))(10), 101); assert.equal(pipe(Math.abs, a =&gt; a + 1, a =&gt; Math.pow(a, 2))(-10), 121); assert.equal(curry((a, b, c) =&gt; a + b - c)(10)(9)(11), 8);","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"hi2048","slug":"hi2048","permalink":"http://hi2048.github.io/tags/hi2048/"},{"name":"hi2048-utils","slug":"hi2048-utils","permalink":"http://hi2048.github.io/tags/hi2048-utils/"}]},{"title":"DynamicNumber","slug":"DynamicNumber","date":"2020-02-09T16:00:00.000Z","updated":"2020-02-26T08:19:00.631Z","comments":true,"path":"2020/02/10/DynamicNumber/","link":"","permalink":"http://hi2048.github.io/2020/02/10/DynamicNumber/","excerpt":"","text":"– 数字跳动控件 github npm demo -- index.js import React, { useState, useEffect } from &apos;react&apos;; import { NORMAL, getSpeed } from &apos;./config&apos;; import { random } from &apos;hi2048-utils&apos;; import &apos;./style.css&apos;; export const DynamicNumber = props =&gt; { const { start = 100, end = 0, stepping = 1, isRandom = true, speed = NORMAL } = props; const [count, setCount] = useState(start); const dynamic = () =&gt; { let dynamicStepping = stepping; let distance = end - start; const direction = distance &lt; 0?-1 : 1; const timer = setInterval(() =&gt; { if(isRandom) { dynamicStepping = random(stepping); } if(Math.abs(distance) &lt; dynamicStepping) { distance = 0; setCount(end); return clearInterval(timer); } distance -= dynamicStepping * direction; setCount(count =&gt; count + dynamicStepping * direction); }, getSpeed(speed)) } useEffect(dynamic, []); return ( &lt;div className=&quot;hi2048 dynamic-number-container&quot;&gt; &lt;span className=&quot;counter&quot;&gt;{ count }&lt;/span&gt; &lt;/div&gt; ); }; -- config.js const SPEED_TYPES = { FASTER: &apos;faster&apos;, FAST: &apos;fast&apos;, NORMAL: &apos;normal&apos;, SLOW: &apos;slow&apos;, SLOWER: &apos;slower&apos; }; export const { FASTER, FAST, NORMAL, SLOW, SLOWER } = SPEED_TYPES; export const getSpeed = speed =&gt; { switch(speed.toLowerCase()) { case FASTER: return 25; case FAST: return 50; case NORMAL: return 100; case SLOW: return 150; case SLOWER: return 200; } }; -- style.css .hi2048.dynamic-number-container { &amp; .counter { display: inline-block; height: 22px; width: auto; min-width: 48px; text-align: center; color: #555; } }","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hi2048.github.io/tags/React/"},{"name":"hi2048","slug":"hi2048","permalink":"http://hi2048.github.io/tags/hi2048/"},{"name":"hi2048-design","slug":"hi2048-design","permalink":"http://hi2048.github.io/tags/hi2048-design/"}]},{"title":"类型判断","slug":"类型判断","date":"2020-01-07T16:00:00.000Z","updated":"2020-02-29T12:44:07.258Z","comments":true,"path":"2020/01/08/类型判断/","link":"","permalink":"http://hi2048.github.io/2020/01/08/类型判断/","excerpt":"","text":"– 基本数据类型判断 github npm -- type.js const types = { &apos;Number&apos;: &apos;Number&apos;, &apos;String&apos;: &apos;String&apos;, &apos;Boolean&apos;: &apos;Boolean&apos;, &apos;Object&apos;: &apos;Object&apos;, &apos;Array&apos;: &apos;Array&apos;, &apos;Function&apos;: &apos;Function&apos;, &apos;Date&apos;: &apos;Date&apos;, &apos;RegExp&apos;: &apos;RegExp&apos;, &apos;Symbol&apos;: &apos;Symbol&apos;, &apos;null&apos;: &apos;Null&apos;, &apos;NaN&apos;: &apos;NaN&apos;, &apos;undefined&apos;: &apos;Undefined&apos; }; const isType = type =&gt; obj =&gt; Object.prototype.toString.call(obj) === `[object ${type}]`; const isTypeFactory = types =&gt; { const isTypes = {}; for(let key of Object.keys(types)) { if(types[key] === &apos;NaN&apos;) { isTypes[&apos;isNaN&apos;] = isNaN; } else if(types[key] === &apos;Number&apos;) { isTypes[&apos;isNumber&apos;] = obj =&gt; { if(isNaN(obj)) { return false; } return isType(types[key])(obj); }; } else { isTypes[`is${types[key]}`] = isType(types[key]); } } return isTypes; }; module.exports = { isNumber, isString, isBoolean, isObject, isArray, isFunction, isDate, isRegExp, isSymbol, isNull, isNaN, isUndefined } = isTypeFactory(types); -- type.test.js const assert = require(&apos;assert&apos;); const { isNumber, isString, isBoolean, isObject, isArray, isFunction, isDate, isRegExp, isSymbol, isNull, isNaN, isUndefined } = require(&apos;.&apos;); assert.equal(isNumber(1), true); assert.equal(isNumber(&apos;a&apos;), false); assert.equal(isNumber(NaN), false); assert.equal(isString(&apos;a&apos;), true); assert.equal(isString({&apos;a&apos;: 1}), false); assert.equal(isBoolean(true), true); assert.equal(isBoolean(&apos;true&apos;), false); assert.equal(isObject({&apos;a&apos;: 1}), true); assert.equal(isObject([1,2]), false); assert.equal(isArray([1,2]), true); assert.equal(isArray({&apos;a&apos;: 1}), false); assert.equal(isFunction(console.log), true); assert.equal(isFunction(&apos;a&apos;), false); assert.equal(isDate(new Date()), true); assert.equal(isDate(&apos;a&apos;), false); assert.equal(isRegExp(/.*/g), true); assert.equal(isRegExp(&apos;a&apos;), false); assert.equal(isSymbol(Symbol()), true); assert.equal(isSymbol(&apos;a&apos;),false); assert.equal(isNull(null), true); assert.equal(isNull(&apos;null&apos;), false); assert.equal(isNaN(NaN), true); assert.equal(isNaN(&apos;NaN&apos;), true); assert.equal(isNaN(1), false); assert.equal(isUndefined(undefined), true); assert.equal(isUndefined(&apos;undefined&apos;), false);","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"hi2048","slug":"hi2048","permalink":"http://hi2048.github.io/tags/hi2048/"},{"name":"hi2048-utils","slug":"hi2048-utils","permalink":"http://hi2048.github.io/tags/hi2048-utils/"}]},{"title":"最大最小值","slug":"最大最小值","date":"2019-12-24T16:00:00.000Z","updated":"2020-02-29T12:55:29.878Z","comments":true,"path":"2019/12/25/最大最小值/","link":"","permalink":"http://hi2048.github.io/2019/12/25/最大最小值/","excerpt":"","text":"– min and max value in args(array or numbers). const min = (...args) =&gt; { return args.reduce((a, b) =&gt; { b = Array.isArray(b)?min(...b) : b; return a &lt; b?a : b; }, Infinity); } const max = (...args) =&gt; { return args.reduce((a, b) =&gt; { b = Array.isArray(b)?max(...b) : b; return a &gt; b?a : b; }, -Infinity); }","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"utils","slug":"utils","permalink":"http://hi2048.github.io/tags/utils/"}]},{"title":"“气球”的最大数量","slug":"“气球”的最大数量","date":"2019-11-17T16:00:00.000Z","updated":"2020-02-04T10:40:23.883Z","comments":true,"path":"2019/11/18/“气球”的最大数量/","link":"","permalink":"http://hi2048.github.io/2019/11/18/“气球”的最大数量/","excerpt":"","text":"给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 “balloon”（气球）。 字符串 text 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 “balloon”。 const min = (...args) =&gt; { return args.reduce((a, b) =&gt; a &lt; b?a : b); } var maxNumberOfBalloons = function(text) { const hash = {b: 0, a: 0, l: 0, o: 0, n: 0}; for(let c of text) { hash[c] = hash[c]?(++hash[c]) : 1; } return min(hash[&apos;b&apos;], hash[&apos;a&apos;], Math.floor(hash[&apos;l&apos;] / 2), Math.floor(hash[&apos;o&apos;] / 2), hash[&apos;n&apos;]); };","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://hi2048.github.io/tags/leetcode/"}]},{"title":"IndexedDB实践及封装","slug":"IndexedDB实践及封装","date":"2019-10-21T16:00:00.000Z","updated":"2019-11-17T05:43:55.567Z","comments":true,"path":"2019/10/22/IndexedDB实践及封装/","link":"","permalink":"http://hi2048.github.io/2019/10/22/IndexedDB实践及封装/","excerpt":"","text":"IndexedDButils for IndexedDB, crud operations. 代码实例 github -- config.js export default { name: &quot;testDB&quot; } -- connect.js import config from &apos;./config&apos;; const connect = ({ name = config.name, version }) =&gt; { const promise = new Promise((resolve, reject) =&gt; { let dbConnection; const request = window.indexedDB.open(name, version); request.onerror = e =&gt; { reject(e); } request.onsuccess = e =&gt; { dbConnection = request.result; resolve(dbConnection); } request.onupgradeneeded = e =&gt; { dbConnection = e.target.result; resolve(dbConnection); } }) return promise; } export default connect; -- index.js import connect from &apos;./connect&apos;; class IndexedDBOperator { constructor(version) { if(!IndexedDBOperator.instance || version) { this.dbConnection = connect({ version }); IndexedDBOperator.instance = this; } return IndexedDBOperator.instance; } static getInstance(version) { return new IndexedDBOperator(version); } getVersion() { return new Promise((resolve, reject) =&gt; { this.dbConnection.then(db =&gt; resolve(db.version)).catch(err =&gt; reject(err)); }); } containsObjectStore(name) { return new Promise((resolve, reject) =&gt; { this.dbConnection.then(db =&gt; { try { resolve(db.objectStoreNames.contains(name)); } catch(err) { reject(err); } }) }); } createObjectStore(name, keyPath) { return new Promise((resolve, reject) =&gt; { this.dbConnection.then(db =&gt; { if(!db.objectStoreNames.contains(name)) { try { const objectStore = db.createObjectStore(name, { keyPath: keyPath, autoIncrement: true }); resolve(objectStore); } catch(err) { reject(err); } } }); }); } create(objectStore, data) { return new Promise((resolve, reject) =&gt; { this.dbConnection.then(db =&gt; { const request = db.transaction([objectStore], &apos;readwrite&apos;).objectStore(objectStore).add(data); request.onsuccess = e =&gt; { resolve(e); } request.onerror = e =&gt; { reject(e); } }); }); } read(objectStore, searchIndex) { return new Promise((resolve, reject) =&gt; { this.dbConnection.then(db =&gt; { const request = db.transaction([objectStore]).objectStore(objectStore).get(searchIndex); request.onerror = e =&gt; { reject(e); }; request.onsuccess = e =&gt; { resolve(request.result); }; }); }); } readAll(objectStore) { return new Promise((resolve, reject) =&gt; { this.dbConnection.then(db =&gt; { const request = db.transaction([objectStore], &apos;readonly&apos;).objectStore(objectStore).openCursor(); const list = new Array(); // objectStore list request.onsuccess = e =&gt; { const cursor = event.target.result; if(cursor) { const { key, value } = cursor; list.push({ key, value }); cursor.continue(); } else { resolve(list); } }; request.onerror = e =&gt; { reject(e); }; }); }); } update(objectStore, data) { return new Promise((resolve, reject) =&gt; { this.dbConnection.then(db =&gt; { const request = db.transaction([objectStore], &apos;readwrite&apos;).objectStore(objectStore).put(data); request.onsuccess = e =&gt; { resolve(e); }; request.onerror = e =&gt; { reject(e); }; }); }); } delete(objectStore, searchIndex) { return new Promise((resolve, reject) =&gt; { this.dbConnection.then(db =&gt; { const request = db.transaction([objectStore], &apos;readwrite&apos;).objectStore(objectStore).delete(searchIndex); request.onsuccess = e =&gt; { resolve(e); }; request.onerror = e =&gt; { reject(e); }; }); }); } } export default IndexedDBOperator;","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"工具类","slug":"工具类","permalink":"http://hi2048.github.io/tags/工具类/"}]},{"title":"UML实践","slug":"UML实践","date":"2019-09-28T16:00:00.000Z","updated":"2019-09-29T10:11:35.778Z","comments":true,"path":"2019/09/29/UML实践/","link":"","permalink":"http://hi2048.github.io/2019/09/29/UML实践/","excerpt":"","text":"UML 代码实例 github -- water.js class Water { constructor(){ console.log(&apos;Water constructor.&apos;); } } module.exports = Water; -- o2.js class O2 { constructor(){ console.log(&apos;O2 constructor.&apos;); } } module.exports = O2; -- animal.js /** * 依赖关系：O2，Water----&gt; */ const O2 = require(&apos;./o2.js&apos;); const Water = require(&apos;./water.js&apos;); class Animal { constructor(){ if(new.target === Animal) throw new Error(`${Animal} cannot be initialized.`); console.log(&apos;Animal constructor.&apos;); this.life = true; } metaboly(o2 = new O2(), water = new Water()){ return; } breed(){} } module.exports = Animal; -- bird.js /** * 继承animal * 实线空心三角 */ const Animal = require(&apos;./animal.js&apos;); const Wing = require(&apos;./wing.js&apos;); class Bird extends Animal { constructor(feather) { super(); console.log(&apos;Bird constructor.&apos;); this.feather = feather; this.wings = new Wing(); } deposit() {} } module.exports = Bird; -- wing.js /** * 与鸟是组合关系 * 鸟 实心菱形 * 翅膀 实心箭头 * 左右数字： 1 2， 1对2 */ class Wing { constructor(){ console.log(&apos;Wing constructor.&apos;) } } module.exports = Wing; -- wildGoose.js /** * 继承鸟 * 实线空心三角 */ const Bird = require(&apos;./bird.js&apos;); class WildGoose extends Bird { constructor() { super(); console.log(&apos;WildGoose Construdtor.&apos;); } deposit() { console.log(&apos;WildGoose Deposit.&apos;); } fly() { console.log(&apos;WildGoose Fly.&apos;); } } module.exports = WildGoose; -- gooseGroup.js /** * 与大雁： 聚合关系 * 雁群： 空心菱形 * 大雁： 实线箭头 */ const WildGoose = require(&apos;./wildGoose.js&apos;); class GooseGroup { constructor(){ this.wildGooses = new WildGoose(); console.log(&apos;GooseGroup Constructor.&apos;); } } module.exports = GooseGroup; -- flyInterface.js /** * 接口 */ class FlyInterface { constructor() { if(new.target === FlyInterface){ throw(&apos;Fly Interface cannot be initialized.&apos;); } } fly() { console.log(&apos;fly interface fly.&apos;); } } module.exports = FlyInterface; -- duck.js /** * 继承自鸟 * 实线空心三角 */ class Duck extends Bird { constructor() { super(); console.log(&apos;Duck constructor.&apos;); } } module.exports = Duck; -- donaldDuck.js /** * 实现接口： talkInterface * 虚线空心三角 或者 实线空心小圆 */ const TalkInterface = require(&apos;./talkInterface.js&apos;); class DonaldDuck extends TalkInterface { constructor(){ super(); console.log(&apos;Donald Duck Constructor.&apos;); } talk() { super.talk(); console.log(&apos;Donald Duck talk.&apos;); } } module.exports = DonaldDuck; -- talkInterface.js class TalkInterface { constructor(){ if(new.target === TalkInterface){ throw new Error(&apos;Talk Interface cannot be initialized.&apos;); } console.log(&apos;Talk Interface Constructor.&apos;); } talk() { console.log(&apos;talk interface talk.&apos;); } } module.exports = TalkInterface; -- penguin.js /** * 继承自鸟 * 实线空心三角 */ const Bird = require(&apos;./bird.js&apos;); const Climate = require(&apos;./climate.js&apos;); class Penguin extends Bird { constructor() { super(); console.log(&apos;Penguin Constructor.&apos;); this.climate = new Climate(); } } module.exports = Penguin; -- climate.js /** * 企鹅 关联关系-〉气候 * 实线箭头 */ class Climate { constructor(){ console.log(&apos;Climate Constructor.&apos;); } } module.exports = Climate; -- test.js const Animal = require(&apos;./animal.js&apos;); // const animal = new Animal(); // animal.metaboly(); const Bird = require(&apos;./bird.js&apos;); const bird = new Bird(); bird.metaboly(); const WildGoose = require(&apos;./wildGoose.js&apos;); // const wildGoose = new WildGoose(); const GooseGroup = require(&apos;./gooseGroup.js&apos;); // const gooseGroup = new GooseGroup(); const Penguin = require(&apos;./penguin.js&apos;); // const penguin = new Penguin(); const DonaldDuck = require(&apos;./donaldDuck.js&apos;); // const donaldDuck = new DonaldDuck(); // donaldDuck.talk(); const TalkInterface = require(&apos;./talkInterface.js&apos;); // const talkInterface = new TalkInterface();","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hi2048.github.io/tags/设计模式/"},{"name":"大话设计模式","slug":"大话设计模式","permalink":"http://hi2048.github.io/tags/大话设计模式/"}]},{"title":"有向图的强连通分量算法","slug":"有向图的强连通分量算法","date":"2019-09-20T16:00:00.000Z","updated":"2019-09-22T12:23:50.800Z","comments":true,"path":"2019/09/21/有向图的强连通分量算法/","link":"","permalink":"http://hi2048.github.io/2019/09/21/有向图的强连通分量算法/","excerpt":"","text":"有向图的强连通分量： Tarjan算法 const Stack = require(&apos;./Stack.js&apos;); // 有向图的强连通分量算法 // dfs搜索 class Tarjan { constructor(n, connections, iDirected = true){ // 时间戳dfn: dfn[i] dfs搜索编号 this.dfn = []; // 追溯值low: low[i] 初始值为 dfn[i]，后续可能会产生更新， low[i] = Math.min(low[i], [low|dfn][c]) i为父节点 this.low = []; this.n = n; this.connections = connections; // dfs编号： 时间戳 this.index = 0; this.stack = new Stack(); // 有向图的强连通分量 this.sccs = new Stack(); // 桥 this.bridges = []; // true有向图， false单边无向图 this.iDirected = iDirected; } t(x, lastEdge) { this.dfn[x] = this.low[x] = ++this.index; this.stack.push(x); for(let c of this.connections) { // c = [x, y] // 无向图重边处理 if(!this.iDirected &amp;&amp; c === lastEdge) continue; // 默认为有向图 let directedX = c[0]; let directedY = c[1]; // 无向图 if(!this.iDirected){ if(x === c[1]){ directedX = c[1]; directedY = c[0]; } } if(directedX === x){ const y = directedY; if(!this.dfn[y]){ this.t(y, c); // 若𝑦没被访问过，则说明(𝑥,𝑦)是树枝边，递归访问𝑦,从𝑦回溯后，令𝑙𝑜𝑤[𝑥]=𝑚𝑖𝑛(𝑙𝑜𝑤[𝑥],𝑙𝑜𝑤[𝑦]) this.low[x] = Math.min(this.low[x], this.low[y]); // 关键连接 - 桥 if(this.low[y] &gt; this.dfn[x]){ this.bridges.push(c); } } else if(this.stack.has(y)){ // 若𝑦被访问过且𝑦在栈中，令𝑙𝑜𝑤[𝑥]=𝑚𝑖𝑛(𝑙𝑜𝑤[𝑥],𝑑𝑓𝑛[𝑦]) this.low[x] = Math.min(this.low[x], this.dfn[y]); } } } // 𝑙𝑜𝑤[𝑥]=𝑑𝑓𝑛[𝑥]成立，则栈中从𝑥到栈顶的所有节点构成一个强连通分量 if(this.dfn[x] === this.low[x]){ const scc = new Stack(); let y; do{ y = this.stack.pop(); scc.push(y); } while(x !== y); this.sccs.push(scc); } } execute() { for(let i = 0; i &lt; this.n; i++) { if(!this.dfn[i]) this.t(i); } return this.sccs; } getSccs() { return this.sccs; } getBridges() { return this.bridges; } contains(connection) { const x = connection[0]; const y = connection[1]; for(let scc of this.sccs.getArray()){ if(scc.has(x) &amp;&amp; scc.has(y)){ return true; } } return false; } print() { this.sccs.print(); } } module.exports = Tarjan;","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hi2048.github.io/tags/算法/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"}]},{"title":"求数据流的中位数","slug":"求数据流的中位数","date":"2019-09-19T16:00:00.000Z","updated":"2019-09-20T12:05:00.827Z","comments":true,"path":"2019/09/20/求数据流的中位数/","link":"","permalink":"http://hi2048.github.io/2019/09/20/求数据流的中位数/","excerpt":"","text":"思路：将有序列表分为大小根堆，左侧为大根堆，右侧为小根堆，从而将中位数变成求取大小根堆的根值。 class Heap { constructor(iLarge = true){ this.heap = new Array(); this.isLarge = iLarge; } swap(id1, id2) { let temp = this.heap[id1]; this.heap[id1] = this.heap[id2]; this.heap[id2] = temp; } up(id) { let pid = Math.floor((id - 1) / 2); if(this.isLarge){ if(id !== 0 &amp;&amp; this.heap[pid] &lt; this.heap[id]){ this.swap(pid, id); this.up(pid); } } else { if(id !== 0 &amp;&amp; this.heap[pid] &gt; this.heap[id]){ this.swap(pid, id); this.up(pid); } } } down(id) { let leftChildId = id * 2 + 1; let rightChildId = id * 2 + 2; let len = this.heap.length; if(this.isLarge){ if(leftChildId &lt; len &amp;&amp; this.heap[leftChildId] &gt; this.heap[id]){ this.swap(leftChildId, id); this.down(leftChildId); } if(rightChildId &lt; len &amp;&amp; this.heap[rightChildId] &gt; this.heap[id]){ this.swap(rightChildId, id); this.down(rightChildId); } } else { if(leftChildId &lt; len &amp;&amp; this.heap[leftChildId] &lt; this.heap[id]){ this.swap(leftChildId, id); this.down(leftChildId); } if(rightChildId &lt; len &amp;&amp; this.heap[rightChildId] &lt; this.heap[id]){ this.swap(rightChildId, id); this.down(rightChildId); } } } insert(x) { this.heap.push(x); this.up(this.heap.length - 1); } remove(){ this.swap(0, this.heap.length - 1); const ret = this.heap.pop(); this.down(0); return ret; } pop(){ return this.heap.pop(); } getRoot(){ return this.heap[0] } getLength(){ return this.heap.length; } } /** * initialize your data structure here. */ var MedianFinder = function() { // 思路：大小根堆 ， 左边为大根堆， 右边为小根堆 this.left = new Heap(true); this.right = new Heap(false); }; /** * @param {number} num * @return {void} */ MedianFinder.prototype.addNum = function(num) { // 具体算法： 如果num 大于 left 的最大值，则添加到右侧，添加完成后需要做大小根的平衡操作。 if(num &gt; this.left.getRoot()){ this.right.insert(num); // 大小根平衡操作 if(this.right.getLength() &gt; this.left.getLength()){ this.left.insert(this.right.remove()); } } else{ this.left.insert(num); if(this.left.getLength() &gt; (this.right.getLength() + 1)){ this.right.insert(this.left.remove()); } } }; /** * @return {number} */ MedianFinder.prototype.findMedian = function() { let len = this.left.getLength() + this.right.getLength(); if(len % 2 === 0){ return (this.left.getRoot() + this.right.getRoot()) / 2; } else{ return this.left.getRoot(); } };","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hi2048.github.io/tags/算法/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"leetcode","slug":"leetcode","permalink":"http://hi2048.github.io/tags/leetcode/"}]},{"title":"JavaScript哈希","slug":"JavaScript哈希","date":"2019-09-15T16:00:00.000Z","updated":"2019-09-16T04:33:10.127Z","comments":true,"path":"2019/09/16/JavaScript哈希/","link":"","permalink":"http://hi2048.github.io/2019/09/16/JavaScript哈希/","excerpt":"","text":"表结构与JS对象结构转换，将数据结构A转换为数据结构B。 // 定义数据结构 const nodeAStruct = function(id, pid, data) { this.id = id; this.pid = pid; this.data = data; } const nodeBStruct = function(id, children, data) { this.id = id; this.children = children; this.data = data; } // 打印：深度遍历 const print = (tree) =&gt; { console.log(tree.data); if(tree.children &amp;&amp; tree.children.length &gt; 0){ const children = tree.children; children.forEach(child =&gt; { print(child); }); } } // 方法一：递归遍历 const convert2Tree = (nodes = [], pid) =&gt; { const result = []; let temp = []; nodes.forEach((node) =&gt; { if(node.pid === pid){ const nodeB = new nodeBStruct(node.id, [], node.data); temp = convert2Tree(nodes, node.id); if(temp.length &gt; 0){ nodeB.children = temp; } result.push(nodeB); } }); return result; } // 方法二：hash处理 const convertNodes2Hash = (nodes = []) =&gt; { const hash = {}; nodes.forEach((node) =&gt; { const nodeB = new nodeBStruct(node.id, [], node.data); if(hash[node.pid]){ hash[node.pid].push(nodeB); } else{ hash[node.pid] = [nodeB]; } }); return hash; } const convertR = (hash, pid) =&gt; { hash[pid].forEach(hp =&gt; { const hc = hash[hp.id]; hp.children = hc?hc : []; if(hc){ convertR(hash, hp.id); } }); return hash; } const convert2TreeByHash = (nodes = []) =&gt; { const hash = convertNodes2Hash(nodes); convertR(hash, -1); return hash[-1]; } const nodes = []; nodes.push(new nodeAStruct(0, -1, &apos;data0&apos;)) nodes.push(new nodeAStruct(1, 0, &apos;data1&apos;)) nodes.push(new nodeAStruct(2, 0, &apos;data2&apos;)) nodes.push(new nodeAStruct(3, 1, &apos;data3&apos;)) nodes.push(new nodeAStruct(4, 1, &apos;data4&apos;)) nodes.push(new nodeAStruct(5, 2, &apos;data5&apos;)) nodes.push(new nodeAStruct(6, 2, &apos;data6&apos;)) let tree = convert2TreeByHash(nodes); print(tree[0]); console.log(tree[0]) console.log(&apos;-----------------------&apos;); tree = convert2Tree(nodes, -1); print(tree[0]); console.log(tree[0])","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hi2048.github.io/tags/算法/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"}]},{"title":"最大气球","slug":"最大气球","date":"2019-09-14T16:00:00.000Z","updated":"2019-09-16T03:29:09.212Z","comments":true,"path":"2019/09/15/最大气球/","link":"","permalink":"http://hi2048.github.io/2019/09/15/最大气球/","excerpt":"","text":"LeetCode - “气球” 的最大数量 给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 “balloon”（气球）。 字符串 text 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 “balloon”。 /** * @param {string} text * @return {number} 输入：text = &quot;nlaebolko&quot; 输出：1 输入：text = &quot;loonbalxballpoon&quot; 输出：2 输入：text = &quot;leetcode&quot; 输出：0 提示： - 1 &lt;= text.length &lt;= 10^4 - text 全部由小写英文字母组成 */ var getAlphaFromText = (text, alpha) =&gt; { const reg = new RegExp(`${alpha}`, &apos;g&apos;); if(reg.test(text)){ return text.match(reg).length; } return 0; } //balloon var maxNumberOfBalloons = function(text) { if(!text || (text &amp;&amp; text.length === 0)) return 0; const balloonByteChars = [&apos;b&apos;, &apos;a&apos;, &apos;l&apos;, &apos;o&apos;, &apos;n&apos;]; const ret = balloonByteChars.reduce((count, b) =&gt; { let len = getAlphaFromText(text, b); if(b === &apos;l&apos; || b === &apos;o&apos;){ len = Math.floor(len / 2); } if(count &gt; len){ count = len; } return count; }, text.length); return ret; };","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hi2048.github.io/tags/算法/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"}]},{"title":"状态管理","slug":"状态管理","date":"2019-09-01T16:00:00.000Z","updated":"2019-09-05T14:59:46.811Z","comments":true,"path":"2019/09/02/状态管理/","link":"","permalink":"http://hi2048.github.io/2019/09/02/状态管理/","excerpt":"","text":"vuex vuex 是一个专门为vue.js应用程序开发的状态管理模式。 状态自管理应用 state, view, actions vuex应用 为什么引入状态管理模式 多个视图依赖于同一状态。 来自不同视图的行为需要变更同一状态。 传统的vue在解决上述问题时，会导致代码复杂与难于维护，vuex采用全局单例模式管理，可以使得代码更结构化且易维护。","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hi2048.github.io/tags/React/"},{"name":"vue","slug":"vue","permalink":"http://hi2048.github.io/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"http://hi2048.github.io/tags/vuex/"}]},{"title":"访问者模式","slug":"访问者模式","date":"2019-08-14T16:00:00.000Z","updated":"2019-11-06T12:26:37.703Z","comments":true,"path":"2019/08/15/访问者模式/","link":"","permalink":"http://hi2048.github.io/2019/08/15/访问者模式/","excerpt":"","text":"访问者模式（Visitor） 代码实例 github -- element.js class Element { constructor() { if(new.target === Element) throw new Error(`${Element} cannot be initialized.`); } accept(vistor) { throw new Error(`${this.accept} should be overwrite.`); } } module.exports = Element; -- concreteElementA.js const Element = require(&apos;./element&apos;); class ConcreteElementA extends Element { accept(visitor) { visitor.visitConcreteElementA(this); } operatorA() { console.log(&apos;ConcreteElementA operatorA.&apos;); } } module.exports = ConcreteElementA; -- concreteElementB.js const Element = require(&apos;./element&apos;); class ConcreteElementB extends Element { accept(visitor) { visitor.visitConcreteElementB(this); } operatorB() { console.log(`ConcreteElementB operatorB.`); } } module.exports = ConcreteElementB; -- visitor.js class Visitor { constructor() { if(new.target === Visitor) throw new Error(`${Visitor} cannot be initialized.`); } visitConcreteElementA(concreteElementA) { throw new Error(`${this.visitConcreteElementA} should be overwrite.`); } visitConcreteElementB(concreteELementB) { throw new Error(`${this.visitConcreteElementB} should be overwrite.`); } } module.exports = Visitor; -- concreteVisitor1.js const Visitor = require(&apos;./visitor&apos;); class ConcreteVisitor1 extends Visitor { visitConcreteElementA(concreteElementA) { console.log(`${this.constructor.name} visitConcreteElementA ${concreteElementA.constructor.name} .`); } visitConcreteElementB(concreteElementB) { console.log(`${this.constructor.name} visitConcreteElementB ${concreteElementB.constructor.name} .`); } } module.exports = ConcreteVisitor1; -- concreteVisitor2.js const Visitor = require(&apos;./visitor&apos;); class ConcreteVisitor2 extends Visitor { visitConcreteElementA(concreteElementA) { console.log(`${this.constructor.name} visitConcreteElementA ${concreteElementA.constructor.name} .`); } visitConcreteElementB(concreteElementB) { console.log(`${this.constructor.name} visitConcreteElementB ${concreteElementB.constructor.name} .`); } } module.exports = ConcreteVisitor2; -- objectStructure.js class ObjectStructure { constructor() { this.elements = new Set(); } add(element) { return element &amp;&amp; this.elements.add(element); } remove(element) { return this.elements.delete(element); } accept(visitor) { this.elements.forEach(element =&gt; (element.accept(visitor))); } } module.exports = ObjectStructure; -- client.js const ObjectStructure = require(&apos;./objectStructure&apos;); const ConcreteElementA = require(&apos;./concreteElementA&apos;); const ConcreteElementB = require(&apos;./concreteElementB&apos;); const ConcreteVisitor1 = require(&apos;./concreteVisitor1&apos;); const ConcreteVisitor2 = require(&apos;./concreteVisitor2&apos;); const objectStructure = new ObjectStructure(); const concreteELementA = new ConcreteElementA(); objectStructure.add(concreteELementA); objectStructure.add(new ConcreteElementB()); const concreteVisitor1 = new ConcreteVisitor1(); objectStructure.accept(concreteVisitor1); objectStructure.accept(new ConcreteVisitor2());","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hi2048.github.io/tags/设计模式/"},{"name":"大话设计模式","slug":"大话设计模式","permalink":"http://hi2048.github.io/tags/大话设计模式/"}]},{"title":"Vue生命周期","slug":"Vue生命周期","date":"2019-08-01T16:00:00.000Z","updated":"2019-09-05T14:58:52.372Z","comments":true,"path":"2019/08/02/Vue生命周期/","link":"","permalink":"http://hi2048.github.io/2019/08/02/Vue生命周期/","excerpt":"","text":"Vue实例有一个完整的生命周期，也就是说从开始创建、初始化数据、编译模板、挂在DOM、渲染-更新-渲染、卸载等一系列过程，我们成为Vue 实例的生命周期，钩子就是在某个阶段给你一个做某些处理的机会。 Vue生命周期钩子 beforeCreate created beforeMount mounted beforeUpdate updated beforeDestroy destroyed","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://hi2048.github.io/tags/vue/"}]},{"title":"解释器模式","slug":"解释器模式","date":"2019-07-21T16:00:00.000Z","updated":"2019-11-05T12:13:26.633Z","comments":true,"path":"2019/07/22/解释器模式/","link":"","permalink":"http://hi2048.github.io/2019/07/22/解释器模式/","excerpt":"","text":"解释器模式（Interpreter） 代码实例 github -- abstractExpression.js class AbstractExpression { constructor() { if(new.target === AbstractExpression) { throw new Error(`${AbstractExpression} cannot be initialized.`); } } interpret() { throw new Error(`${this.interpret} should be overwrite.`); } } module.exports = AbstractExpression; -- context.js class Context { constructor(content) { this.content = content; } setContent(content) { return content &amp;&amp; (this.content = content); } getContent() { return this.content; } } module.exports = Context; -- terminalExpression.js const AbstractExpression = require(&apos;./abstractExpression&apos;); class TerminalExpression extends AbstractExpression { interpret(context) { console.log(`TerminalExpression interpret ${context}.`); } } module.exports = TerminalExpression; -- nonterminalExpression.js const AbstractExpression = require(&apos;./abstractExpression&apos;); class NonterminalExpression extends AbstractExpression { interpret(context) { console.log(`NonterminalExpression interpret ${context}.`); } } module.exports = NonterminalExpression; -- reTools.js module.exports = { numbers: /[0-9]/, operators: /[+*/-]/, verificationRule: /[0-9+*/-]/ }; -- abstractExpressionOperation.js const reTools = require(&apos;./reTools&apos;); class AbstractExpressionOperation { constructor(operator) { if(new.target === AbstractExpressionOperation) throw new Error(`${AbstractExpressionOperation} cannot be initialized.`); this.operator = operator; } interpret(operator = this.operator, prevExpresstion = this.prevExpresstion, nextExpression = this.nextExpression) { if(new RegExp(reTools.verificationRule).test(operator)) { return this.execute(operator, prevExpresstion, nextExpression); } } execute(c, exp1, exp2) { throw new Error(`${this.execute} should be overwrite.`); } } module.exports = AbstractExpressionOperation; -- terminalExpressionNumber.js const AbstractExpressionOperation = require(&apos;./abstractExpressionOperation&apos;); class TerminalExpressionNumber extends AbstractExpressionOperation { execute(number = this.operator) { return number; } } module.exports = TerminalExpressionNumber; -- nonterminalExpressionPlus.js const AbstractExpressionOperation = require(&apos;./abstractExpressionOperation&apos;); class NonterminalExpressionPlus extends AbstractExpressionOperation { constructor(operator, prevExpression, nextExpression) { super(operator); this.prevExpression = prevExpression; this.nextExpression = nextExpression; } setPrevExpression(prevExpression) { return prevExpression &amp;&amp; (this.prevExpression = prevExpression); } setNextExpression(nextExpression) { return nextExpression &amp;&amp; (this.nextExpression = nextExpression); } execute(operator = this.operator, expression1 = this.prevExpression, expression2 = this.nextExpression) { console.log(`NonterminalExpressionPlus execute: ${expression1.interpret()} + ${expression2.interpret()} = ${+expression1.interpret() + +expression2.interpret()} .`); return +expression1.interpret() + +expression2.interpret(); } } module.exports = NonterminalExpressionPlus; -- nonterminalExpressionMinus.js const AbstractExpressionOperation = require(&apos;./abstractExpressionOperation&apos;); class NonterminalExpressionMinus extends AbstractExpressionOperation { constructor(operator, prevExpression, nextExpression) { super(operator); this.prevExpression = prevExpression; this.nextExpression = nextExpression; } setPrevExpression(prevExpression) { return prevExpression &amp;&amp; (this.prevExpression = prevExpression); } setNextExpression(nextExpression) { return nextExpression &amp;&amp; (this.nextExpression = nextExpression); } execute(operator = this.operator, expression1 = this.prevExpression, expression2 = this.nextExpression) { console.log(`NonterminalExpressionMinus execute: ${expression1.interpret()} - ${expression2.interpret()} = ${expression1.interpret() - expression2.interpret()} .`); return expression1.interpret() - expression2.interpret(); } } module.exports = NonterminalExpressionMinus; -- client.js const Context = require(&apos;./context&apos;); const TerminalExpression = require(&apos;./terminalExpression&apos;); const NonterminalExpression = require(&apos;./nonterminalExpression&apos;); const reTools = require(&apos;./reTools&apos;); const TerminalExpressionNumber = require(&apos;./terminalExpressionNumber&apos;); const NonterminalExpressionPlus = require(&apos;./nonterminalExpressionPlus&apos;); const NonterminalExpressionMinus = require(&apos;./nonterminalExpressionMinus&apos;); const context = new Context(&apos;Interpreter DP&apos;); const terminalExpression = new TerminalExpression(); const nonterminalExpression = new NonterminalExpression(); const interpreter1 = new Set(); interpreter1.add(terminalExpression); interpreter1.add(new TerminalExpression()); interpreter1.add(nonterminalExpression); interpreter1.forEach(interpreter =&gt; (interpreter.interpret(context.getContent()))); console.log(&apos;------&apos;); const context2 = new Context(&apos;1 + 2&apos;); const content = context2.getContent(); let experssions = []; for(let c of content) { if(new RegExp(reTools.numbers).test(c)) { experssions.push(new TerminalExpressionNumber(c)) } else if(c === &apos;+&apos;) { experssions.push(new NonterminalExpressionPlus(c)); } else if(c === &apos;-&apos;) { experssions.push(new NonterminalExpressionMinus(c)); } } experssions.forEach((expression, index, expressions) =&gt; { if(!(expression instanceof TerminalExpressionNumber)) { expression.setPrevExpression(expressions[index - 1]); expression.setNextExpression(expressions[index + 1]); expression.interpret() } }); console.log(&apos;------&apos;); const context3 = new Context(&apos;2 - 3&apos;); const expressions3 = []; for(let c of context3.getContent()) { if(new RegExp(reTools.numbers).test(c)) { expressions3.push(new TerminalExpressionNumber(c)); } else if(c === &apos;+&apos;) { expressions3.push(new NonterminalExpressionPlus(c)); } else if(c === &apos;-&apos;) { expressions3.push(new NonterminalExpressionMinus(c)); } } expressions3.forEach((expression, index, expressions) =&gt; { if(!(expression instanceof TerminalExpressionNumber)) { expression.interpret(undefined, expressions[index - 1], expressions[index + 1]); } }); console.log(&apos;------&apos;);","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hi2048.github.io/tags/设计模式/"},{"name":"大话设计模式","slug":"大话设计模式","permalink":"http://hi2048.github.io/tags/大话设计模式/"}]},{"title":"享元模式","slug":"享元模式","date":"2019-06-14T16:00:00.000Z","updated":"2019-11-04T09:50:47.306Z","comments":true,"path":"2019/06/15/享元模式/","link":"","permalink":"http://hi2048.github.io/2019/06/15/享元模式/","excerpt":"","text":"享元模式（Flyweight） 代码实例 github -- flyweight.js class Flyweight { constructor() { if(new.target === Flyweight) throw new Error(`${Flyweight} cannot be initialized.`); } operation(extrinsicState) { throw new Error(`${this.operation} should be overwrite.`); } } module.exports = Flyweight; -- concreteFlyweight.js const Flyweight = require(&apos;./flyweight&apos;); class ConcreteFlyweight extends Flyweight { constructor() { super(); } operation(extrinsicState) { console.log(`ConcreteFlyweight operation: shared ${extrinsicState}`); } } module.exports = ConcreteFlyweight; -- unsharedConcreteFlyweight.js const Flyweight = require(&apos;./flyweight&apos;); class UnsharedConcreteFlyweight extends Flyweight { constructor() { super(); } operation(extrinsicState) { console.log(`UnsharedConcreteFlyweight operation: unshared ${extrinsicState}`); } } module.exports = UnsharedConcreteFlyweight; -- flyweightFactory.js class FlyweightFactory { constructor() { this.flyweights = new Map(); } getFlyweight(key) { return this.flyweights.get(key); } setFlyweight(key, value) { this.flyweights.set(key, value); } getFlyweightCount() { return this.flyweights.size; } } module.exports = FlyweightFactory; -- client.js const ConcreteFlyweight = require(&apos;./concreteFlyweight&apos;); const UnsharedConcreteFlyweight = require(&apos;./unsharedConcreteFlyweight&apos;); const FlyweightFactory = require(&apos;./flyweightFactory&apos;); const concreteFlyweight = new ConcreteFlyweight(); const unsharedConcreteFlyweight = new UnsharedConcreteFlyweight(); const flyweightFactory = new FlyweightFactory(); flyweightFactory.setFlyweight(&apos;x&apos;, concreteFlyweight); flyweightFactory.setFlyweight(&apos;y&apos;, new ConcreteFlyweight()); flyweightFactory.setFlyweight(&apos;z&apos;, new ConcreteFlyweight()); console.log(flyweightFactory.getFlyweightCount()); let extrinsicState = 20; flyweightFactory.getFlyweight(&apos;x&apos;).operation(--extrinsicState); flyweightFactory.getFlyweight(&apos;y&apos;).operation(--extrinsicState); flyweightFactory.getFlyweight(&apos;z&apos;).operation(--extrinsicState); unsharedConcreteFlyweight.operation(--extrinsicState);","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hi2048.github.io/tags/设计模式/"},{"name":"大话设计模式","slug":"大话设计模式","permalink":"http://hi2048.github.io/tags/大话设计模式/"}]},{"title":"compose","slug":"compose","date":"2019-06-09T16:00:00.000Z","updated":"2019-09-10T15:47:32.356Z","comments":true,"path":"2019/06/10/compose/","link":"","permalink":"http://hi2048.github.io/2019/06/10/compose/","excerpt":"","text":"JavaScript函数式编程：compose方法 const compose = (arr) =&gt; { return arr.reduce((a, b) =&gt; (...args) =&gt; a(b(...args))) } const composeT = (arr) =&gt; { return arr.reduce((a, b) =&gt; { return (...args) =&gt; { console.log(`${a.name}(${b.name}(${args}))`); return a(b(...args)); } }, ()=&gt;{}) } const a = (a, b) =&gt; {console.log(&quot;a: &quot;, a); return a;} const b = (a, b) =&gt; {console.log(&quot;b: &quot;, a); return a;} const c = (a, b) =&gt; {console.log(&quot;c: &quot;, a, b); return [a, b];} composeT([a,b,c])(&apos;1&apos;,&apos;2&apos;) (c(1,2)) c: 1 2 (b(1,2)) b: [ &apos;1&apos;, &apos;2&apos; ] (a(1,2)) a: [ &apos;1&apos;, &apos;2&apos; ]","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hi2048.github.io/tags/算法/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"}]},{"title":"中介者模式","slug":"中介者模式","date":"2019-05-21T16:00:00.000Z","updated":"2019-10-30T13:24:47.889Z","comments":true,"path":"2019/05/22/中介者模式/","link":"","permalink":"http://hi2048.github.io/2019/05/22/中介者模式/","excerpt":"","text":"中介者模式（Mediator） 代码实例 github -- mediator.js class Mediator { constructor() { if(new.target === Mediator) throw new Error(`${Mediator} cannot be initialized.`); this.colleagues = new Set(); } addColleague(colleague) { colleague &amp;&amp; this.colleagues.add(colleague); return this; } removeColleague(colleague) { this.colleagues.delete(colleague); return this; } send(message, colleague) { throw new Error(`${this.send} should be overwrite.`); } } module.exports = Mediator; -- concreteMediator.js const Mediator = require(&apos;./mediator&apos;); class ConcreteMediator extends Mediator { constructor() { super(); } send(message, colleague) { this.colleagues.forEach(coll =&gt; { if(coll !== colleague) { coll.notify(message); } }); } } module.exports = ConcreteMediator; -- colleague.js class Colleague { constructor(mediator) { if(new.target === Colleague) { throw new Error(`${Colleague} cannot be initialized.`); } this.mediator = mediator; } setMediator(mediator) { mediator &amp;&amp; (this.mediator = mediator); return this; } send(message) { this.mediator.send(message, this); } notify(message) { throw new Error(`${this.notify} should be overwrite.`); } } module.exports = Colleague; -- concreteColleague1.js const Colleague = require(&apos;./colleague&apos;); class ConcreteColleague1 extends Colleague { constructor(mediator) { super(mediator); } notify(message) { console.log(`ConcreteColleague1 notify ${message}.`); } } module.exports = ConcreteColleague1; -- concreteColleague2.js const Colleague = require(&apos;./colleague&apos;); class ConcreteColleague2 extends Colleague { constructor(mediator) { super(mediator); } notify(message) { console.log(`ConcreteColleague2 notify ${message}.`); } } module.exports = ConcreteColleague2; -- client.js const ConcreteMediator = require(&apos;./concreteMediator&apos;); const ConcreteColleague1 = require(&apos;./concreteColleague1&apos;); const ConcreteColleague2 = require(&apos;./concreteColleague2&apos;); const concreteMediator = new ConcreteMediator(); const concreteColleague1 = new ConcreteColleague1(concreteMediator); const concreteColleague2 = new ConcreteColleague2(concreteMediator); concreteMediator.addColleague(concreteColleague1); concreteMediator.addColleague(concreteColleague2); concreteColleague1.send(&apos;concreteColleague1 send message 1&apos;); concreteColleague2.send(&apos;concreteColleague2 send message 2&apos;); concreteColleague2.send(&apos;concreteColleague2 send message 3&apos;); concreteColleague1.send(&apos;concreteColleague1 send message 4&apos;);","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hi2048.github.io/tags/设计模式/"},{"name":"大话设计模式","slug":"大话设计模式","permalink":"http://hi2048.github.io/tags/大话设计模式/"}]},{"title":"职责链模式","slug":"职责链模式","date":"2019-05-01T16:00:00.000Z","updated":"2019-10-29T12:19:18.862Z","comments":true,"path":"2019/05/02/职责链模式/","link":"","permalink":"http://hi2048.github.io/2019/05/02/职责链模式/","excerpt":"","text":"职责链模式（ChainOfResponsibility） 代码实例 github -- handler.js class Handler { constructor(successor) { if(new.target === Handler) { throw new Error(`${Handler} cannot be initialized.`); } this.successor = successor; } setSuccessor(successor) { successor &amp;&amp; (this.successor = successor); return this; } handleRequest() { throw new Error(`${this.handleRequest} should be overwrite.`); } } module.exports = Handler; -- concreteHandler1.js const Handler = require(&apos;./handler&apos;); class ConcreteHandler1 extends Handler { constructor(successor) { super(successor); } handleRequest(request) { if(request &lt; 10) { console.log(&apos;Concretehandler1 handleRequest.&apos;); } else { this.successor &amp;&amp; this.successor.handleRequest(request); } } } module.exports = ConcreteHandler1; -- concreteHandler2.js const Handler = require(&apos;./handler&apos;); class ConcreteHandler2 extends Handler { constructor(successor) { super(successor); } handleRequest(request) { if(request &lt; 20){ console.log(&apos;ConcreteHandler2 handleRequest.&apos;); } else { this.successor &amp;&amp; this.successor.handleRequest(request); } } } module.exports = ConcreteHandler2; -- concreteHandler3.js const Handler = require(&apos;./handler&apos;); class ConcreteHandler3 extends Handler { constructor(successor) { super(successor); } handleRequest(request) { console.log(&apos;ConcreteHandler3 handleRequest.&apos;); } } module.exports = ConcreteHandler3; -- client.js const ConcreteHandler1 = require(&apos;./concreteHandler1&apos;); const ConcreteHandler2 = require(&apos;./concreteHandler2&apos;); const ConcreteHandler3 = require(&apos;./concreteHandler3&apos;); const concreteHandler3 = new ConcreteHandler3(); const concreteHandler2 = new ConcreteHandler2(); const concreteHandler1 = new ConcreteHandler1(concreteHandler2); concreteHandler2.setSuccessor(concreteHandler3); const request = [9, 10, 19, 20, 30, 999]; request.forEach(req =&gt; (concreteHandler1.handleRequest(req)));","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hi2048.github.io/tags/设计模式/"},{"name":"大话设计模式","slug":"大话设计模式","permalink":"http://hi2048.github.io/tags/大话设计模式/"}]},{"title":"命令模式","slug":"命令模式","date":"2019-04-17T16:00:00.000Z","updated":"2019-10-27T12:52:15.129Z","comments":true,"path":"2019/04/18/命令模式/","link":"","permalink":"http://hi2048.github.io/2019/04/18/命令模式/","excerpt":"","text":"命令模式（Command） 代码实例 github -- command.js class Command { constructor(receiver) { if(new.target === Command) throw new Error(`${Command} cannot be initialized.`); this.receiver = receiver; } setReceiver(receiver) { return receiver &amp;&amp; (this.receiver = receiver); } execute() { throw new Error(`{this.execute} should be overwrite.`); } } module.exports = Command; -- concreteCommand.js const Command = require(&apos;./command&apos;); class ConcreteCommand extends Command { constructor(receiver = {}) { super(receiver); } execute() { this.receiver.action(); } } module.exports = ConcreteCommand; -- invoker.js class Invoker { constructor() { this.orders = new Set(); } addCommand(command) { return command &amp;&amp; this.orders.add(command); } removeCommand(command) { return command &amp;&amp; this.orders.delete(command); } notify() { this.orders.forEach(order =&gt; (order.execute())); } } module.exports = Invoker; -- receiver.js class Receiver { action() { console.log(&apos;Receiver action.&apos;); } } module.exports = Receiver; -- client.js const Invoker = require(&apos;./invoker&apos;); const Receiver = require(&apos;./receiver&apos;); const ConcreteCommand = require(&apos;./concreteCommand&apos;); const invoker = new Invoker(); const receiver = new Receiver(); const concreteCommand1 = new ConcreteCommand(); concreteCommand1.setReceiver(receiver); const concreteCommand2 = new ConcreteCommand(receiver); const concreteCommand3 = new ConcreteCommand(receiver); invoker.addCommand(concreteCommand1); invoker.addCommand(); invoker.addCommand(concreteCommand1); invoker.addCommand(concreteCommand2); invoker.addCommand(concreteCommand3); invoker.removeCommand(); invoker.removeCommand(concreteCommand1); invoker.removeCommand(); invoker.removeCommand(concreteCommand1); invoker.notify();","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hi2048.github.io/tags/设计模式/"},{"name":"大话设计模式","slug":"大话设计模式","permalink":"http://hi2048.github.io/tags/大话设计模式/"}]},{"title":"JavaScript中的内存管理","slug":"JavaScript中的内存管理","date":"2019-03-22T16:00:00.000Z","updated":"2019-09-23T04:29:27.352Z","comments":true,"path":"2019/03/23/JavaScript中的内存管理/","link":"","permalink":"http://hi2048.github.io/2019/03/23/JavaScript中的内存管理/","excerpt":"","text":"内存管理的生命周期 Allocate Memory =&gt; Use Memory =&gt; Release Memory JavaScript中的GC机制 引用机制：主要通过引用计数进行垃圾收集，将“对象是否不再需要”简化定义为“对象是否有引用存在”. 引用机制无法处理对象的循环引用 标记清除（Mark and Sweep）：算法假定设置一个根Root，定期从根开始递归寻找引用，从而获取所有可以获得的对象和不能获得的对象，因此也解决了循环引用的问题。 将“对象是否不再需要”简化定义为“对象是否可以获得”。 内存泄露 不再需要的内存, 无法被释放。 常见内存泄露案例 全局变量 定时器和回调函数 闭包 Dom引用 Dom事件 console.log","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"}]},{"title":"桥接模式","slug":"桥接模式","date":"2019-03-04T16:00:00.000Z","updated":"2019-10-26T14:00:12.036Z","comments":true,"path":"2019/03/05/桥接模式/","link":"","permalink":"http://hi2048.github.io/2019/03/05/桥接模式/","excerpt":"","text":"桥接模式（Bridge） 代码实例 github -- abstraction.js class Abstraction { constructor(implementor) { if(new.target === Abstraction) throw new Error(`${Abstraction} cannot be initialized.`); this.implementor = implementor; } setImplementor(implementor) { implementor &amp;&amp; (this.implementor = implementor); return this; } operation() { throw new Error(`${this.operation} should be overwrite.`); } } module.exports = Abstraction; -- implementor.js class Implementor { constructor() { if(new.target === Implementor) { throw new Error(`${Implementor} cannot be initialized.`); } } operation() { throw new Error(`${this.operation} should be overwrite.`); } } module.exports = Implementor; -- refinedAbstraction.js const Abstraction = require(&apos;./abstraction&apos;); class RefinedAbstraction extends Abstraction { constructor(implementor = {}) { super(implementor); } operation() { console.log(&apos;RefinedAbstraction operation.&apos;); this.implementor.operation &amp;&amp; this.implementor.operation(); return this; } } module.exports = RefinedAbstraction; -- concreteImplementorA.js const Implementor = require(&apos;./implementor&apos;); class ConcreteImplementorA extends Implementor { constructor() { super(); } operation() { console.log(&apos;ConcreteImplementorA operation.&apos;); } } module.exports = ConcreteImplementorA; -- concreteImplementorB.js const Implementor = require(&apos;./implementor&apos;); class ConcreteImplementorB extends Implementor { constructor() { super(); } operation() { console.log(&apos;ConcreteImplementorB operation.&apos;); } } module.exports = ConcreteImplementorB; -- client.js const RefinedAbstraction = require(&apos;./refinedAbstraction&apos;); const ConcreteImplementorA = require(&apos;./concreteImplementorA&apos;); const ConcreteImplementorB = require(&apos;./concreteImplementorB&apos;); const refinedAbstraction = new RefinedAbstraction(); const concreteImplementorA = new ConcreteImplementorA(); const concreteImplementorB = new ConcreteImplementorB(); refinedAbstraction.operation(); console.log(&apos;------&apos;); refinedAbstraction.setImplementor().operation(); console.log(&apos;------&apos;); refinedAbstraction.setImplementor(concreteImplementorA).operation(); console.log(&apos;------&apos;); refinedAbstraction.setImplementor().operation(); console.log(&apos;------&apos;); refinedAbstraction.setImplementor(concreteImplementorB).operation(); console.log(&apos;------&apos;); new RefinedAbstraction(new ConcreteImplementorB()).operation().setImplementor().operation().setImplementor(new ConcreteImplementorA()).operation(); console.log(&apos;------&apos;);","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hi2048.github.io/tags/设计模式/"},{"name":"大话设计模式","slug":"大话设计模式","permalink":"http://hi2048.github.io/tags/大话设计模式/"}]},{"title":"Stack实现","slug":"Stack实现","date":"2019-02-28T16:00:00.000Z","updated":"2019-09-22T12:14:50.569Z","comments":true,"path":"2019/03/01/Stack实现/","link":"","permalink":"http://hi2048.github.io/2019/03/01/Stack实现/","excerpt":"","text":"栈FILO：先进后出 // 先进后出 FILO: first in last out class Stack { constructor(){ this.stack = new Array(); } pop() { return this.stack.pop(); } push(x) { this.stack.push(x); return this; } empty() { return this.size() === 0; } size() { return this.stack.length; } top() { return this.stack[this.stack.length - 1]; } has(x) { return this.stack.indexOf(x) !== -1; } getArray() { return this.stack; } getRoot() { return this.stack[0]; } print() { for(let s of [...this.stack]){ if(s.print){ console.log(`${s}：`); s.print(); } else{ console.log(s); } } return this; } } module.exports = Stack;","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hi2048.github.io/tags/算法/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"}]},{"title":"单例模式","slug":"单例模式","date":"2019-02-17T16:00:00.000Z","updated":"2019-10-24T11:52:46.047Z","comments":true,"path":"2019/02/18/单例模式/","link":"","permalink":"http://hi2048.github.io/2019/02/18/单例模式/","excerpt":"","text":"单例模式（Singleton） 代码实例 github -- singleton.js class Singleton { constructor(name = &apos;Singleton&apos;) { if(!Singleton.instance) { this.name = name; Singleton.instance = this; } return Singleton.instance } static getInstance(name) { return new Singleton(name); } } module.exports = Singleton; -- client.js const Singleton = require(&apos;./singleton&apos;); const singleton = Singleton.getInstance(); const singleton2 = Singleton.getInstance(&apos;singleton2&apos;); const singleton3 = new Singleton(&apos;singleton3&apos;); const singleton4 = new Singleton(&apos;singleton4&apos;); console.log(singleton === singleton2); console.log(singleton === singleton3); console.log(singleton === singleton4);","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hi2048.github.io/tags/设计模式/"},{"name":"大话设计模式","slug":"大话设计模式","permalink":"http://hi2048.github.io/tags/大话设计模式/"}]},{"title":"数组去重","slug":"数组去重","date":"2019-02-17T16:00:00.000Z","updated":"2019-09-18T14:31:10.318Z","comments":true,"path":"2019/02/18/数组去重/","link":"","permalink":"http://hi2048.github.io/2019/02/18/数组去重/","excerpt":"","text":"使用Array的filter方法 const distinctFilter = (arr) =&gt; (arr.filter((item, index) =&gt; (arr.indexOf(item) === index))) 使用ES6的Set const distinctSet = (arr) =&gt; (Array.from(new Set(arr))); 使用Hash方法 const distinctHash = (arr) =&gt; { const hash = {}; let disArr = []; for(let i of arr){ if(!hash[i]){ disArr.push(i); hash[i] = [i]; } } return disArr; }","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hi2048.github.io/tags/算法/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"}]},{"title":"LRU算法","slug":"LRU算法","date":"2019-02-09T16:00:00.000Z","updated":"2019-09-18T13:24:33.512Z","comments":true,"path":"2019/02/10/LRU算法/","link":"","permalink":"http://hi2048.github.io/2019/02/10/LRU算法/","excerpt":"","text":"LRU (least recently used) 缓存机制：实现get, put方法。 /** * 元素置顶 */ const popItemFromArray = (arr, key) =&gt;{ arr.splice(arr.indexOf(key), 1); arr.push(key); return arr; } /** * 实现思路：ES6 Map [+ 有序数组（或者双向链表）] * */ var LRUCache = function(capacity) { this.cache = new Map(); this.lruArr = new Array(); this.curLen = 0; this.capacity = capacity; }; LRUCache.prototype.get = function(key) { if(this.cache.has(key)){ const value = this.cache.get(key); popItemFromArray(this.lruArr, key); return value; } return -1; }; LRUCache.prototype.lruDel = function(){ const minKey = this.lruArr.shift(); const isucc = this.cache.delete(minKey); if(isucc){ this.curLen--; } return isucc; } // iorder : false descend true ascend LRUCache.prototype.sort = function(iorder) { return this.lruArr.sort((c1, c2) =&gt; { return c1 - c2; }); } LRUCache.prototype.put = function(key, value) { if(this.cache.has(key)){ // pop key from lru array popItemFromArray(this.lruArr, key); return this.cache.set(key, value); } if(this.curLen === this.capacity){ this.lruDel(); } this.curLen++; this.lruArr.push(key); return this.cache.set(key, value); };","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hi2048.github.io/tags/算法/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"}]},{"title":"迭代器模式","slug":"迭代器模式","date":"2019-02-07T16:00:00.000Z","updated":"2019-10-23T13:01:53.620Z","comments":true,"path":"2019/02/08/迭代器模式/","link":"","permalink":"http://hi2048.github.io/2019/02/08/迭代器模式/","excerpt":"","text":"迭代器模式（Iterator） 代码实例 github -- aggregate.js class Aggregate { constructor() { if(new.target === Aggregate) throw new Error(`${Aggregate} cannot be initialized.`); } createIterator() { throw new Error(`${this.createIterator} should be overwrite.`); } } module.exports = Aggregate; -- iterator.js class Iterator { constructor() { if(new.target === Iterator) throw new Error(`${Iterator} cannot be initialized.`); } first() { throw new Error(`${this.first} should be overwrite.`); } next() { throw new Error(`${this.next} should be overwrite.`); } isDone() { throw new Error(`${this.isDone} should be overwrite.`); } currentItem() { throw new Error(`${this.currentItem} should be overwrite.`); } } module.exports = Iterator; -- concreteAggregate1.js const Aggregate = require(&apos;./aggregate&apos;); const ConcreteIterator = require(&apos;./concreteIterator1&apos;); class ConcreteAggregate extends Aggregate { constructor() { super(); this.aggregate = new Array(); } add(item) { this.aggregate.push(item); } get(index) { return this.aggregate[index]; } count() { return this.aggregate.length; } createIterator() { return new ConcreteIterator(this); } } module.exports = ConcreteAggregate; -- concreteIterator1.js const Iterator = require(&apos;./iterator&apos;); class ConcreteIterator extends Iterator { constructor(aggregate = {}) { super(); this.aggregate = aggregate; this.cur = 0; } first() { return this.aggregate.get(0); } next() { this.cur++; if(this.cur &lt; this.aggregate.count()) { return this.currentItem(); } return undefined; } isDone() { return this.cur &lt; this.aggregate.count()? false : true; } currentItem() { return this.aggregate.get(this.cur); } } module.exports = ConcreteIterator; -- concreteAggregate2.js const Aggregate = require(&apos;./aggregate&apos;); const ConcreteIterator2 = require(&apos;./concreteIterator2&apos;); class ConcreteAggregate2 extends Aggregate { constructor() { super(); } createIterator() { return new ConcreteIterator2(this); } } module.exports = ConcreteAggregate2; -- concreteIterator2.js const Iterator = require(&apos;./iterator&apos;); class ConcreteIterator2 extends Iterator { constructor(aggregate = {}) { super(); this.aggregate = aggregate; this.initAggregateIterator(); // init iterator this.iterator = this.aggregate[Symbol.iterator](); } initAggregateIterator() { this.aggregate[Symbol.iterator] = function() { const aggregate = this; const keys = Object.keys(aggregate); let curIndex = 0; return { first: function() { return aggregate[keys[curIndex]]; }, next: function () { curIndex++; if(curIndex &lt; keys.length) { return this.currentItem(); } return undefined; }, isDone: function() { return curIndex &lt; keys.length? false : true; }, currentItem: function() { return aggregate[keys[curIndex]]; } } } } first() { return this.iterator.first(); } next() { return this.iterator.next(); } isDone() { return this.iterator.isDone(); } currentItem() { return this.iterator.currentItem(); } } module.exports = ConcreteIterator2; -- concreteAggregate3.js const Aggregate = require(&apos;./aggregate&apos;); const ConcreteIterator3 = require(&apos;./concreteIterator3&apos;); class ConcreteAggregate3 extends Aggregate { constructor() { super(); } createIterator() { return new ConcreteIterator3(this); } } module.exports = ConcreteAggregate3; -- concreteIterator3.js const Iterator = require(&apos;./iterator&apos;); class ConcreteIterator3 extends Iterator { constructor(aggregate = {}) { super(); this.aggregate = aggregate; this.initAggregateIterator(); // init iterator this.iterator = this.aggregate[Symbol.iterator](); } initAggregateIterator() { this.aggregate[Symbol.iterator] = function *() { const aggregateValues = Object.values(this); for(let value of aggregateValues) { yield value; } } } next() { return this.iterator.next(); } } module.exports = ConcreteIterator3; -- client.js const ConcreteAggregate1 = require(&apos;./concreteAggregate1&apos;); const ConcreteAggregate2 = require(&apos;./concreteAggregate2&apos;); const ConcreteAggregate3 = require(&apos;./concreteAggregate3&apos;); const concreteAggregate1 = new ConcreteAggregate1(); concreteAggregate1.add(&apos;a&apos;); concreteAggregate1.add(&apos;b&apos;); concreteAggregate1.add(&apos;c&apos;); console.log(&apos;Iterator dp1: &apos;); const iterator1 = concreteAggregate1.createIterator(); let iteratorValueDP1 = iterator1.first(); while(!iterator1.isDone()) { console.log(`${iteratorValueDP1} `); iteratorValueDP1 = iterator1.next(); } console.log(&apos;------&apos;); console.log(&apos;Iterator dp2: &apos;); const concreteAggregate2 = new ConcreteAggregate2(); concreteAggregate2[&apos;0&apos;] = &apos;a&apos;; concreteAggregate2[&apos;1&apos;] = &apos;b&apos;; concreteAggregate2[&apos;2&apos;] = &apos;c&apos;; const iterator2 = concreteAggregate2.createIterator(); let iteratorValueDP2 = iterator2.first(); while(!iterator2.isDone()) { console.log(`${iteratorValueDP2} `); iteratorValueDP2 = iterator2.next(); } console.log(&apos;------&apos;); console.log(&apos;Iterator dp3: &apos;); const concreteAggregate3 = new ConcreteAggregate3(); concreteAggregate3[1] = &apos;a&apos;; concreteAggregate3[2] = &apos;b&apos;; concreteAggregate3[3] = &apos;c&apos;; const iterator3 = concreteAggregate3.createIterator(); let iteratorValueDP3 = iterator3.next(); while(!iteratorValueDP3.done) { console.log(`${iteratorValueDP3.value} `); iteratorValueDP3 = iterator3.next(); } console.log(&apos;------&apos;); -- concreteAggregate4.js const Aggregate = require(&apos;./aggregate&apos;); const ConcreteIterator4 = require(&apos;./concreteIterator4&apos;); class ConcreteAggregate4 extends Aggregate { constructor() { super(); this.item = new Array(); // super array simulate indexer this.extend(this.item, this, Reflect.getPrototypeOf(this)); return this.item; } extend(target, ...origins) { for(let origin of origins) { const keys = Reflect.ownKeys(origin); for(let key of keys) { target[key] = origin[key]; } } } createIterator() { return new ConcreteIterator4(this.item); } } module.exports = ConcreteAggregate4; -- concreteIterator4.js const Iterator = require(&apos;./iterator&apos;); class ConcreteIterator4 extends Iterator { constructor(aggregate = []) { super(); this.aggregate = aggregate; this.curIndex = 0; } first() { return this.aggregate[this.curIndex]; } next() { let ret = null; this.curIndex ++; if(this.curIndex &lt; this.aggregate.length) { ret = this.currentItem(); } return ret; } isDone() { return this.curIndex &lt; this.aggregate.length?false : true; } currentItem() { return this.aggregate[this.curIndex]; } } module.exports = ConcreteIterator4; -- client2.js const ConcreteAggregate4 = require(&apos;./concreteAggregate4&apos;); const concreteAggregate4 = new ConcreteAggregate4(); concreteAggregate4[0] = &apos;a&apos;; concreteAggregate4[1] = &apos;b&apos;; concreteAggregate4[2] = &apos;c&apos;; const iterator = concreteAggregate4.createIterator(); let iteratorValue = iterator.first(); while(!iterator.isDone()) { console.log(`${iteratorValue} `); iteratorValue = iterator.next(); } console.log(&apos;------&apos;);","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hi2048.github.io/tags/设计模式/"},{"name":"大话设计模式","slug":"大话设计模式","permalink":"http://hi2048.github.io/tags/大话设计模式/"}]},{"title":"Heap实现","slug":"Heap实现","date":"2019-01-18T16:00:00.000Z","updated":"2019-09-19T11:46:09.241Z","comments":true,"path":"2019/01/19/Heap实现/","link":"","permalink":"http://hi2048.github.io/2019/01/19/Heap实现/","excerpt":"","text":"小根堆实现，大根堆类似 // 通过 up down方法实现 堆的有效性 class Heap { constructor(){ this.heap = new Array(); } swap(id1, id2) { let temp = this.heap[id1]; this.heap[id1] = this.heap[id2]; this.heap[id2] = temp; } up(id) { let pid = Math.floor((id - 1) / 2); if(id !== 0 &amp;&amp; this.heap[pid] &gt; this.heap[id]){ this.swap(pid, id); this.up(pid); } } down(id) { let leftChildId = id * 2 + 1; let rightChildId = id * 2 + 2; let len = this.heap.length; if(leftChildId &lt; len &amp;&amp; this.heap[leftChildId] &lt; this.heap[id]){ this.swap(leftChildId, id); this.down(leftChildId); } if(rightChildId &lt; len &amp;&amp; this.heap[rightChildId] &lt; this.heap[id]){ this.swap(rightChildId, id); this.down(rightChildId); } } insert(x) { this.heap.push(x); this.up(this.heap.length - 1); } remove(){ this.swap(0, this.heap.length - 1); const ret = this.heap.pop(); this.down(0); return ret; } }","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hi2048.github.io/tags/算法/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"}]},{"title":"组合模式","slug":"组合模式","date":"2019-01-04T16:00:00.000Z","updated":"2019-10-21T13:34:04.669Z","comments":true,"path":"2019/01/05/组合模式/","link":"","permalink":"http://hi2048.github.io/2019/01/05/组合模式/","excerpt":"","text":"组合模式（Composite） 代码实例 github -- component.js class Component { constructor(name = &apos;Component&apos;) { if(new.target === Component) throw new Error(`${Component} cannot be initialized.`); this.name = name; } add(c) { throw new Error(`${this.add} should be overwrite.`); } remove(c) { throw new Error(`${this.remove} should be overwrite.`); } display() { throw new Error(`${this.display} should be overwrite.`); } } module.exports = Component; -- composite.js const Component = require(&apos;./component&apos;); class Composite extends Component { constructor(name) { super(name); this.components = new Set(); } add(c) { this.components.add(c); } remove(c) { this.components.delete(c); } display(depth = 1) { console.log(`${&apos;-&apos;.repeat(depth)} ${this.name}`); this.components.forEach((component) =&gt; (component.display(depth + 2))); } } module.exports = Composite; -- leaf.js const Component = require(&apos;./component&apos;); class Leaf extends Component { constructor(name) { super(name); } display(depth = 1) { console.log(`${&apos;-&apos;.repeat(depth)} ${this.name}`); } } module.exports = Leaf; -- client.js const Composite = require(&apos;./composite&apos;); const Leaf = require(&apos;./leaf&apos;); const root = new Composite(&apos;Root&apos;); root.add(new Leaf(&apos;Leaf11&apos;)); root.add(new Leaf(&apos;Leaf12&apos;)); const composite1 = new Composite(&apos;Composite11&apos;); root.add(composite1); const leaf21 = new Leaf(&apos;Leaf21&apos;); composite1.add(leaf21); const composite2 = new Composite(&apos;Composite21&apos;); composite1.add(composite2); composite1.add(new Leaf(&apos;Leaf22&apos;)); composite2.add(new Leaf(&apos;Leaf31&apos;)); root.add(new Leaf(&apos;Leaf13&apos;)); const leaf14 = new Leaf(&apos;Leaf14&apos;); root.add(leaf14); composite1.remove(leaf21); root.display(2);","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hi2048.github.io/tags/设计模式/"},{"name":"大话设计模式","slug":"大话设计模式","permalink":"http://hi2048.github.io/tags/大话设计模式/"}]},{"title":"React16为什么更新","slug":"React16为什么更新","date":"2018-12-10T16:00:00.000Z","updated":"2019-09-11T09:35:37.523Z","comments":true,"path":"2018/12/11/React16为什么更新/","link":"","permalink":"http://hi2048.github.io/2018/12/11/React16为什么更新/","excerpt":"","text":"React16更新的根本原因是提升用户体验，解决同步更新带来的界面卡顿问题。 React16之前的版本中，更新过程是同步的，为什么会导致界面卡顿？ 大量的同步计算任务阻塞了浏览器的UI渲染 JavaScript是单线程的。 JavaScript运算、页面布局和页面绘制都是运行在浏览器的主线程当中，他们之间是互斥的关系。 React加载或者更新时，会调用生命周期函数，计算和对比Virtual DOM，更新UI，整个过程是同步的，如果需要更新的组件数量过大或者计算过于复杂，就会出现用户卡顿的体验。 React是如何解决上述问题的？ 引入了异步渲染(Async Rendering)机制 采用分片的思路，提出了Fiber的解决方案。","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hi2048.github.io/tags/React/"}]},{"title":"快乐数","slug":"快乐数","date":"2018-12-07T16:00:00.000Z","updated":"2019-09-08T13:53:44.932Z","comments":true,"path":"2018/12/08/快乐数/","link":"","permalink":"http://hi2048.github.io/2018/12/08/快乐数/","excerpt":"","text":"快乐数：正整数，求出每个位置的数字平方和，重复此过程，可以得到数字1，则为快乐数。求取平方和过程中如果重复之前的平方和，则非快乐数。 var getSquaresSum = function(n){ var ss = n.toString().split(&apos;&apos;); return ss.reduce(function(count, s){ return count + Math.pow(parseInt(s), 2); }, 0) } var isHappy = function(n) { var rets = [n]; var count = n; while(true){ count = getSquaresSum(count); if(count === 1){ return true; } var index = rets.indexOf(count); if(index !== -1){ return false; } rets.push(count); } };","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hi2048.github.io/tags/算法/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"}]},{"title":"React生命周期","slug":"React生命周期","date":"2018-12-01T16:00:00.000Z","updated":"2019-09-11T08:42:28.187Z","comments":true,"path":"2018/12/02/React生命周期/","link":"","permalink":"http://hi2048.github.io/2018/12/02/React生命周期/","excerpt":"","text":"React生命周期 - React16前 React生命周期总体上分为4个阶段：初始化阶段（initialization），挂载阶段（Mounting），更新阶段（update），卸载阶段（Unmount） initialization：初始化props和state。constructor mounting：执行一次。componentWillMount, render, componentDidMount update：setState引起的state更新或者父组件重新render引起的props更新。componentWillReceiveProps, shouldComponentUpdate, componentWillUpdate, render, componentDidUpdate unmount: 执行一次componentWillUnmount React生命周期 引入了两个新的生命周期函数getDerivedStateFromProps，getSnapshotBeforeUpdate 为什么会变化 React16推出Fiber，如果开启async rendering，会导致render函数之前的所有函数，有可能被执行多次。 componentWillMount componentWillReceiveProps componentWillUpdate shouldComponentUpdate 其中shouldComponentUpdate为纯函数，返回Boolean，没有副作用，而其他三个函数，开发者如果在里面执行有副作用的操作，如Ajax等，会产生不可预期的结果。所以其余三个统一被getDerivedStateFromProps替代，并且 采用静态函数，用禁止来替代以前的建议 。 react的component中static属性，里面放函数，官方解释： you can run them before any component instances are created, and the methods do not have access to the props or state of your components. 静态函数getDerivedStateFromProps来取代被deprecate的几个生命周期函数，就是强制开发者在render之前只做无副作用的操作，而且能做的操作局限在根据props和state决定新的state。","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hi2048.github.io/tags/React/"}]},{"title":"备忘录模式","slug":"备忘录模式","date":"2018-12-01T16:00:00.000Z","updated":"2019-10-20T12:28:43.599Z","comments":true,"path":"2018/12/02/备忘录模式/","link":"","permalink":"http://hi2048.github.io/2018/12/02/备忘录模式/","excerpt":"","text":"备忘录模式（Memento） 代码实例 github -- originator.js const Memento = require(&apos;./memento&apos;); class Originator { constructor(state = &apos;initial state&apos;) { this.state = state; console.log(&apos;Originator constructor.&apos;); } setState(state) { this.state = state; console.log(this.state); } setMemento(memento) { this.state = memento.getState(); console.log(`Originator setMemento state: ${this.state}.`); } createMemento() { console.log(`Originator createMemento state: ${this.state}.`); return new Memento(this.state); } } module.exports = Originator; -- memento.js class Memento { constructor(state) { this.state = state; console.log(&apos;Memento constructor.&apos;); } getState() { return this.state; } } module.exports = Memento; -- caretaker.js const Memento = require(&apos;./memento&apos;); class Caretaker { constructor() { console.log(&apos;Caretaker constructor.&apos;); } setMemento(memento) { this.memento = memento; } getMemento() { return this.memento; } } module.exports = Caretaker; -- client.js const Originator = require(&apos;./originator&apos;); const Caretaker = require(&apos;./caretaker&apos;); const originator = new Originator(); const caretaker = new Caretaker(); const memento1 = originator.createMemento(); caretaker.setMemento(memento1); originator.setState(&apos;state1&apos;); originator.setMemento(caretaker.getMemento()); console.log(&apos;------&apos;); originator.setState(&apos;state2&apos;); caretaker.setMemento(originator.createMemento()); originator.setState(&apos;state3&apos;); originator.setMemento(caretaker.getMemento()); console.log(&apos;------&apos;);","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hi2048.github.io/tags/设计模式/"},{"name":"大话设计模式","slug":"大话设计模式","permalink":"http://hi2048.github.io/tags/大话设计模式/"}]},{"title":"适配器模式","slug":"适配器模式","date":"2018-11-05T16:00:00.000Z","updated":"2019-10-20T10:18:33.441Z","comments":true,"path":"2018/11/06/适配器模式/","link":"","permalink":"http://hi2048.github.io/2018/11/06/适配器模式/","excerpt":"","text":"适配器模式（Adapter） 代码实例 github -- target.js class Target { constructor() { if(new.target === Target) throw new Error(`${Target} cannot be initialized.`); console.log(&apos;Target constructor.&apos;); } request() { throw new Error(`${this.request} should be overwrite.`); } } module.exports = Target; -- adapter.js const Target = require(&apos;./target&apos;); const Adaptee = require(&apos;./adaptee&apos;); class Adapter extends Target { constructor(adaptee = new Adaptee()) { super(); this.adaptee = adaptee; console.log(&apos;Adapter constructor.&apos;); } request() { this.adaptee.specificRequest(); } } module.exports = Adapter; -- adaptee.js class Adaptee { constructor() { console.log(&apos;Adaptee constructor.&apos;); } specificRequest() { console.log(&apos;Adaptee specificRequest.&apos;); } } module.exports = Adaptee; -- client.js const Adapter = require(&apos;./adapter&apos;); const Adaptee = require(&apos;./adaptee&apos;); const adapter = new Adapter(new Adaptee()); adapter.request(); console.log(&apos;------&apos;); const adapter2 = new Adapter(); adapter2.request(); console.log(&apos;------&apos;);","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hi2048.github.io/tags/设计模式/"},{"name":"大话设计模式","slug":"大话设计模式","permalink":"http://hi2048.github.io/tags/大话设计模式/"}]},{"title":"状态模式","slug":"状态模式","date":"2018-10-20T16:00:00.000Z","updated":"2019-10-19T12:48:21.274Z","comments":true,"path":"2018/10/21/状态模式/","link":"","permalink":"http://hi2048.github.io/2018/10/21/状态模式/","excerpt":"","text":"状态模式（State） 代码实例 github -- state.js class State { constructor() { if(new.target === State) throw new Error(`${State} cannot be initialized.`); console.log(&apos;State constructor.&apos;); } handle() { throw new Error(`${this.handle} should be overwrite.`); } } module.exports = State; -- concreteStateA.js const State = require(&apos;./state&apos;); class ConcreteStateA extends State { constructor() { super(); console.log(&apos;ConcreteStateA constructor.&apos;); } handle(context) { console.log(&apos;Current State: ConcreteStateA. &apos;); context.setState(&apos;ConcreteStateB&apos;); } } module.exports = ConcreteStateA; -- concreteStateB.js const State = require(&apos;./state&apos;); class ConcreteStateB extends State { constructor() { super(); console.log(&apos;ConcreteStateB constructor.&apos;); }; handle(context) { console.log(&apos;Current State: ConcreteStateB. &apos;); context.setState(&apos;ConcreteStateC&apos;); }; } module.exports = ConcreteStateB; -- concreteStateC.js const State = require(&apos;./state&apos;); class ConcreteStateC extends State { constructor() { super(); console.log(&apos;ConcreteStateC constructor.&apos;); }; handle(context) { console.log(&apos;Current State: ConcreteStateC. &apos;); context.setState(&apos;ConcreteStateA&apos;); }; } module.exports = ConcreteStateC; -- states.js const ConcreteStateA = require(&apos;./concreteStateA&apos;); const ConcreteStateB = require(&apos;./concreteStateB&apos;); const ConcreteStateC = require(&apos;./concreteStateC&apos;); module.exports = { ConcreteStateA, ConcreteStateB, ConcreteStateC }; -- context.js const states = require(&apos;./states&apos;); class Context { constructor(state = &apos;ConcreteStateA&apos;) { this.state = state; console.log(&apos;Context constructor.&apos;); } setState(state) { this.state = state; }; request() { new states[this.state]().handle(this); }; } module.exports = Context; -- client.js const Context = require(&apos;./context&apos;); const context = new Context(); context.request(); context.request(); context.request(); context.request();","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hi2048.github.io/tags/设计模式/"},{"name":"大话设计模式","slug":"大话设计模式","permalink":"http://hi2048.github.io/tags/大话设计模式/"}]},{"title":"React之setState","slug":"React之setState","date":"2018-10-10T16:00:00.000Z","updated":"2019-09-11T12:14:16.446Z","comments":true,"path":"2018/10/11/React之setState/","link":"","permalink":"http://hi2048.github.io/2018/10/11/React之setState/","excerpt":"","text":"setState是异步还是同步 合成事件（react自定义的事件，如在组件中的onClick等）和生命周期函数中是“异步”的。这里的异步并非是真正的异步实现，其本身还是属于同步操作，只是采用了批处理机制。 原生事件（DOM中的原生事件，如通过addEventListener添加的等）和 setTimeout 中都是同步的 setState(updater[, callback]) updater可以是一个函数或者一个对象。 如果是对象，则执行对象跟state的浅合并。 如果传入一个函数，则会把函数的返回对象跟state进行浅合并。这个函数会传入两个参数state和props，返回一个对象 (state, props) =&gt; stateChange 第二个参数，state更新完毕之后调用的回调函数。如果有需要在state更新之后的操作，可以放在这里。不过官方更建议在componentDidUpdate里面处理更新之后的操作。 使用注意事项 不要直接修改state setState不能保证是同步的 setState造成不必要的渲染 setState的优化 声名变量能用const就不要用let 减少setState的调用次数，如可以一次set多个值，不要一个一个set。 多利用shouldComponentUpdate","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hi2048.github.io/tags/React/"}]},{"title":"秋","slug":"秋","date":"2018-10-04T16:00:00.000Z","updated":"2019-09-05T14:51:31.779Z","comments":true,"path":"2018/10/05/秋/","link":"","permalink":"http://hi2048.github.io/2018/10/05/秋/","excerpt":"","text":"秋风送爽，炎暑渐消，此时宜甘味以益气，进补应坚持“燥者濡之”，“上燥清气，中燥增液，下燥养血。”同时应早睡早起，早餐宜营养丰富，以预防抑郁症，保持乐观轻松心情。","categories":[{"name":"未分类","slug":"未分类","permalink":"http://hi2048.github.io/categories/未分类/"}],"tags":[]},{"title":"Swagger","slug":"Swagger","date":"2018-09-11T16:00:00.000Z","updated":"2019-09-06T06:24:46.889Z","comments":true,"path":"2018/09/12/Swagger/","link":"","permalink":"http://hi2048.github.io/2018/09/12/Swagger/","excerpt":"","text":"Swagger解决了什么问题？ 接口文档的一致性与可维护性 Swagger是什么？ 通过自己定义的描述文件（yml或json格式），更新接口文档，以及生成各端代码. Swagger可以做什么？ 可以做到生成各种格式的接口文档，生成多种语言的客户端和服务端的代码，以及在线接口调试页面等等。 Springfox-swagger 通过扫描代码去生成这个描述文件","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://hi2048.github.io/tags/Spring/"}]},{"title":"抽象工厂模式","slug":"抽象工厂模式","date":"2018-09-09T16:00:00.000Z","updated":"2019-10-18T09:18:47.332Z","comments":true,"path":"2018/09/10/抽象工厂模式/","link":"","permalink":"http://hi2048.github.io/2018/09/10/抽象工厂模式/","excerpt":"","text":"抽象工厂模式（Abstract Factory） 代码实例 github -- abstractProductA.js class AbstractProductA { constructor() { if(new.target === AbstractProductA) throw new Error(`${AbstractProductA} cannot be initialized.`); console.log(&apos;AbstractProductA constructor.&apos;); } method() { throw new Error(`${this.method} should be overwrite.`); } } module.exports = AbstractProductA; -- productA1.js const AbstractProductA = require(&apos;./abstractProductA&apos;); class ProductA1 extends AbstractProductA { constructor() { super(); console.log(&apos;ProductA1 constructor.&apos;); } method() { console.log(&apos;ProductA1 method.&apos;); } } module.exports = ProductA1; -- productA2.js const AbstractProductA = require(&apos;./abstractProductA&apos;); class ProductA2 extends AbstractProductA { constructor() { super(); console.log(&apos;ProductA2 constructor.&apos;); } method() { console.log(&apos;ProductA2 method.&apos;); } } module.exports = ProductA2; -- abstractProductB.js class AbstractProductB { constructor() { if(new.target === AbstractProductB) throw new Error(`${AbstractProductB} cannot be initialized.`); console.log(&apos;AbstractProductB constructor.&apos;); } method() { throw new Error(`${this.method} should be overwrite.`); } } module.exports = AbstractProductB; -- productB1.js const AbstractProductB = require(&apos;./abstractProductB&apos;); class ProductB1 extends AbstractProductB { constructor() { super(); console.log(&apos;ProductB1 constructor.&apos;); } method() { console.log(&apos;ProductB1 method.&apos;); } } module.exports = ProductB1; -- productB2.js const AbstractProductB = require(&apos;./abstractProductB&apos;); class ProductB2 extends AbstractProductB { constructor() { super(); console.log(&apos;ProductB2 constructor.&apos;); } method() { console.log(&apos;ProductB2 method.&apos;); } } module.exports = ProductB2; -- abstractFactory.js class AbstractFactory { constructor() { if(new.target === AbstractFactory) throw new Error(`${AbstractFactory} cannot be initialized.`); console.log(&apos;AbstractFactory constructor.&apos;); }; createProductA() { throw new Error(`${this.createProductA} should be overwrite.`); }; createProductB() { throw new Error(`${this.createProductB} should be overwrite.`); }; } module.exports = AbstractFactory; -- concreteFactory1.js const AbstractFactory = require(&apos;./abstractFactory&apos;); const ProductA1 = require(&apos;./productA1&apos;); const ProductB1 = require(&apos;./productB1&apos;); class ConcreteFactory1 extends AbstractFactory { constructor() { super(); console.log(&apos;ConcreteFactory1 constructor.&apos;); } createProductA() { return new ProductA1(); } createProductB() { return new ProductB1(); } } module.exports = ConcreteFactory1; -- concreteFactory2.js const AbstractFactory = require(&apos;./abstractFactory&apos;); const ProductA2 = require(&apos;./productA2&apos;); const ProductB2 = require(&apos;./productB2&apos;); class ConcreteFactory2 extends AbstractFactory { constructor() { super(); console.log(&apos;ConcreteFactory2 constructor.&apos;); } createProductA() { return new ProductA2(); } createProductB() { return new ProductB2(); } } module.exports = ConcreteFactory2; -- client.js const ConcreteFactory1 = require(&apos;./concreteFactory1&apos;); const ConcreteFactory2 = require(&apos;./concreteFactory2&apos;); const concreteFactory1 = new ConcreteFactory1(); const concreteFactory2 = new ConcreteFactory2(); console.log(&apos;------&apos;); concreteFactory1.createProductA().method(); console.log(&apos;------&apos;); concreteFactory1.createProductB().method(); console.log(&apos;------&apos;); concreteFactory2.createProductA().method(); concreteFactory2.createProductB().method(); console.log(&apos;------&apos;); -- productClasses.js const ProductA1 = require(&apos;./productA1&apos;); const ProductA2 = require(&apos;./productA2&apos;); const ProductB1 = require(&apos;./productB1&apos;); const ProductB2 = require(&apos;./productB2&apos;); const productClasses = { ProductA1, ProductA2, ProductB1, ProductB2 }; module.exports = productClasses; -- productAccess.js const productClasses = require(&apos;./productClasses&apos;); class ProductAccess { constructor() { console.log(&apos;ProductAccess constructor.&apos;); } create(product = &apos;ProductA1&apos;) { return new productClasses[product](); } } module.exports = ProductAccess; -- client2.js const ProductAccess = require(&apos;./productAccess&apos;); const productClasses = require(&apos;./productClasses&apos;); console.dir(productClasses); console.log(&apos;------&apos;); const productAccess = new ProductAccess(); console.log(&apos;------&apos;); productAccess.create().method(); console.log(&apos;------&apos;); productAccess.create(&apos;ProductB1&apos;).method(); console.log(&apos;------&apos;); productAccess.create(&apos;ProductA1&apos;).method(); console.log(&apos;------&apos;); productAccess.create(&apos;ProductA2&apos;).method(); productAccess.create(&apos;ProductB2&apos;).method(); console.log(&apos;------&apos;);","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hi2048.github.io/tags/设计模式/"},{"name":"大话设计模式","slug":"大话设计模式","permalink":"http://hi2048.github.io/tags/大话设计模式/"}]},{"title":"观察者模式","slug":"观察者模式","date":"2018-08-01T16:00:00.000Z","updated":"2019-10-17T14:03:39.006Z","comments":true,"path":"2018/08/02/观察者模式/","link":"","permalink":"http://hi2048.github.io/2018/08/02/观察者模式/","excerpt":"","text":"观察者模式（Observer） 代码实例 github -- subject.js class Subject { constructor() { if(new.target === Subject) throw new Error(`${Subject} cannot be initialized.`); this.observers = new Set(); console.log(&quot;Subject constructor.&quot;); } attach(observer) { this.observers.add(observer); } detach(observer) { this.observers.delete(observer); } notify() { console.log(&apos;notify&apos;); this.observers.forEach((observer) =&gt; (observer.update())); } } module.exports = Subject; -- concreteSubject.js const Subject = require(&apos;./subject&apos;); class ConcreteSubject extends Subject { constructor(subjectState = &quot;ConcreteSubject&quot;) { super(); this.subjectState = subjectState; console.log(&apos;ConcreteSubject constructor.&apos;); } setSubjectState(subjectState) { this.subjectState = subjectState; this.notify(); } } module.exports = ConcreteSubject; -- observer.js class Observer { constructor() { if(new.target === Observer) throw new Error(`${Observer} cannot be initialized.`); console.log(&apos;Observer constructor.&apos;); } update() { throw new Error(`${this.update} should be overwrite.`); } } module.exports = Observer; -- concreteObserver.js const Observer = require(&apos;./observer&apos;); class ConcreteObserver extends Observer { constructor(name = &quot;concreteObserver&quot;, subject = {}) { super(); this.name = name; this.subject = subject; this.observerState = subject.subjectState; console.log(&apos;ConcreteObserver constructor.&apos;); } update() { this.observerState = this.subject.subjectState; console.log(`${this.observerState} notify ${this.name}.`); } } module.exports = ConcreteObserver; -- client.js const ConcreteSubject = require(&apos;./concreteSubject&apos;); const ConcreteObserver = require(&apos;./concreteObserver&apos;); const concreteSubject = new ConcreteSubject(); const concreteObserverX = new ConcreteObserver(&apos;X&apos;, concreteSubject); const concreteObserverXX = new ConcreteObserver(&apos;X&apos;, concreteSubject); const concreteObserverY = new ConcreteObserver(&apos;Y&apos;, concreteSubject); const concreteObserverZ = new ConcreteObserver(&apos;Z&apos;, concreteSubject); console.log(&apos;------&apos;); concreteSubject.setSubjectState(&apos;Changed ConcreteSubject SubjectState.&apos;); console.log(&apos;------&apos;); concreteSubject.attach(concreteObserverX); concreteSubject.setSubjectState(&apos;subjectState 1&apos;); console.log(&apos;------&apos;); concreteSubject.detach(concreteObserverX); concreteSubject.setSubjectState(&apos;subjectState 2&apos;); console.log(&apos;------&apos;); concreteSubject.attach(concreteObserverX); concreteSubject.attach(concreteObserverY); concreteSubject.attach(concreteObserverX); concreteSubject.setSubjectState(&apos;subjectState 3&apos;); console.log(&apos;------&apos;); concreteSubject.attach(concreteObserverZ); concreteSubject.setSubjectState(&apos;subjectState 4&apos;); console.log(&apos;------&apos;); concreteSubject.detach(concreteObserverX); concreteSubject.setSubjectState(&apos;subjectState 5&apos;); console.log(&apos;------&apos;); concreteSubject.detach(concreteObserverX); concreteSubject.setSubjectState(&apos;subjectState 6&apos;); console.log(&apos;------&apos;); concreteSubject.detach(concreteObserverY); concreteSubject.detach(concreteObserverZ); concreteSubject.setSubjectState(&apos;subjectState 7&apos;); console.log(&apos;------&apos;); concreteSubject.attach(concreteObserverY); concreteSubject.attach(concreteObserverX); concreteSubject.attach(concreteObserverXX); concreteSubject.setSubjectState(&apos;subjectState 8&apos;); console.log(&apos;------&apos;);","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hi2048.github.io/tags/设计模式/"},{"name":"大话设计模式","slug":"大话设计模式","permalink":"http://hi2048.github.io/tags/大话设计模式/"}]},{"title":"建造者模式","slug":"建造者模式","date":"2018-07-11T16:00:00.000Z","updated":"2019-10-16T14:46:59.983Z","comments":true,"path":"2018/07/12/建造者模式/","link":"","permalink":"http://hi2048.github.io/2018/07/12/建造者模式/","excerpt":"","text":"建造者模式（Builder） 代码实例 github -- product.js class Product { constructor() { this.parts = new Array(); console.log(&apos;Product constructor.&apos;); } add(part) { this.parts.push(part); } show() { console.log(...this.parts); } } module.exports = Product; -- builder.js class Builder { constructor() { if(new.target === Builder) throw new Error(`${Builder} cannot be initialized.`); console.log(&apos;Builder constructor.&apos;); } buildPartA() { throw new Error(`${this.buildPartA} should be overwrite.`); } buildPartB() { throw new Error(`${this.buildPartB} should be overwrite.`); } getResult() { throw new Error(`${this.getResult} should be overwrite.`); } } module.exports = Builder; -- concreteBuilder1.js const Builder = require(&apos;./builder&apos;); const Product = require(&apos;./product&apos;); class ConcreteBuilder1 extends Builder { constructor(product) { super(); this.product = product || new Product(); console.log(&apos;ConcreteBuilder1 constructor.&apos;); } buildPartA() { this.product.add(&apos;partA1&apos;); } buildPartB() { this.product.add(&apos;partB1&apos;); } getResult() { return this.product; } } module.exports = ConcreteBuilder1; -- concreteBuilder2.js const Builder = require(&apos;./builder&apos;); const Product = require(&apos;./product&apos;); class ConcreteBuilder2 extends Builder { constructor(product) { super(); this.product = product || new Product(); console.log(&apos;ConcreteBuilder2 constructor.&apos;); } buildPartA() { this.product.add(&apos;partA2&apos;); } buildPartB() { this.product.add(&apos;partB2&apos;); } getResult() { return this.product; } } module.exports = ConcreteBuilder2; -- director.js class Director { constructor() { console.log(&apos;Director constructor.&apos;); } construct(builder) { builder.buildPartA(); builder.buildPartB(); console.log(&apos;Director construct.&apos;); } } module.exports = Director; -- client.js const Director = require(&apos;./director&apos;); const Product = require(&apos;./product&apos;); const ConcreteBuilder1 = require(&apos;./concreteBuilder1&apos;); const ConcreteBuilder2 = require(&apos;./concreteBuilder2&apos;); const director = new Director(); console.log(&apos;------&apos;); const concreteBuilder1 = new ConcreteBuilder1(); director.construct(concreteBuilder1); concreteBuilder1.getResult().show(); console.log(&apos;------&apos;); const productB = new Product(); const concreteBuilder2 = new ConcreteBuilder2(productB); director.construct(concreteBuilder2); console.log(&apos;product B: &apos;); productB.show(); console.log(&apos;concreteBuilder2 getResult: &apos;); concreteBuilder2.getResult().show(); console.log(&apos;------&apos;);","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hi2048.github.io/tags/设计模式/"},{"name":"大话设计模式","slug":"大话设计模式","permalink":"http://hi2048.github.io/tags/大话设计模式/"}]},{"title":"外观模式","slug":"外观模式","date":"2018-06-14T16:00:00.000Z","updated":"2019-10-16T04:29:36.718Z","comments":true,"path":"2018/06/15/外观模式/","link":"","permalink":"http://hi2048.github.io/2018/06/15/外观模式/","excerpt":"","text":"外观模式（Facade） 代码实例 github -- subSystemOne.js class SubSystemOne { constructor() { console.log(&apos;SubSystemOne constructor.&apos;); } methodOne() { console.log(&apos;SubSystemOne methodOne.&apos;); } } module.exports = SubSystemOne; -- subSystemTwo.js class SubSystemTwo { constructor() { console.log(&apos;SubSystemTwo constructor.&apos;); } methodTwo() { console.log(&apos;SubSystemTwo methodTwo.&apos;); } } module.exports = SubSystemTwo; -- subSystemThree.js class SubSystemThree { constructor() { console.log(&apos;SubSystemThree constructor.&apos;); } methodThree() { console.log(&apos;SubSystemThree methodThree.&apos;); } } module.exports = SubSystemThree; -- subSystemFour.js class SubSystemFour { constructor() { console.log(&apos;SubSystemFour constructor.&apos;); } methodFour() { console.log(&apos;SubSystemFour methodFour.&apos;); } } module.exports = SubSystemFour; -- facade.js const SubSystemOne = require(&apos;./subSystemOne&apos;); const SubSystemTwo = require(&apos;./subSystemTwo&apos;); const SubSystemThree = require(&apos;./subSystemThree&apos;); const SubSystemFour = require(&apos;./subSystemFour&apos;); class Facade { constructor() { this.subSystemOne = new SubSystemOne(); this.subSystemTwo = new SubSystemTwo(); this.subSystemThree = new SubSystemThree(); this.subSystemFour = new SubSystemFour(); console.log(&apos;Facade constructor.&apos;); } methodA() { console.log(&apos;Facade methodA.&apos;); this.subSystemOne.methodOne(); this.subSystemTwo.methodTwo(); this.subSystemFour.methodFour(); } methodB() { console.log(&apos;Facade methodB.&apos;); this.subSystemThree.methodThree(); this.subSystemFour.methodFour(); } } module.exports = Facade; -- client.js const Facade = require(&apos;./facade&apos;); const facade = new Facade(); console.log(&apos;------&apos;); facade.methodA(); console.log(&apos;------&apos;); facade.methodB();","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hi2048.github.io/tags/设计模式/"},{"name":"大话设计模式","slug":"大话设计模式","permalink":"http://hi2048.github.io/tags/大话设计模式/"}]},{"title":"Fiber","slug":"Fiber","date":"2018-06-10T16:00:00.000Z","updated":"2019-09-11T10:00:46.794Z","comments":true,"path":"2018/06/11/Fiber/","link":"","permalink":"http://hi2048.github.io/2018/06/11/Fiber/","excerpt":"","text":"什么是Fiber React Fibler 采用分片的思路实现UI的异步渲染。 React Fiber把更新过程碎片化，分成很多小片，当分配给小片的时间用尽时，则将控制权交出，如果有优先级更高的任务，就开始做新的任务，没有就断续原来的更新。 Fiber运行原理 React Fiber一个更新过程被分为两个阶段(Phase)：第一个阶段Reconciliation Phase和第二阶段Commit Phase。 Reconciliation Phase， 可以被打断，计算与对比虚拟DOM，找出需要更新的DOMcomponentWillMountcomponentWillReceivePropsshouldComponentUpdatecomponentWillUpdate Commit Phase， 无法打断，更新DOMcomponentDidMountcomponentDidUpdatecomponentWillUnmount React16前的生命周期函数componentWillUpdate等，为什么会多次执行？ requestIdleCallback cancelIdleCallback 异步渲染的时候，会调用requestIdleCallback API，在回调函数中可以获得当前callback参数（也就是fiber的分片任务），包括执行时间，如果时间不够，分片任务会被打断（使用cancelIdleCallback API），再次执行则会在空闲时重新执行。","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hi2048.github.io/tags/React/"}]},{"title":"React高阶组件","slug":"React高阶组件","date":"2018-06-09T16:00:00.000Z","updated":"2019-09-18T13:09:21.246Z","comments":true,"path":"2018/06/10/React高阶组件/","link":"","permalink":"http://hi2048.github.io/2018/06/10/React高阶组件/","excerpt":"","text":"高阶组件：higher order Component，装饰器模式 基本形式：const EnhancedComponent = higherOrderComponent(WrappedComponent); 高阶组件两种常见用法： 属性代理 Props Proxy: 通过WrappedComponent的Props来进行操作 function hocPropsProxy(WrappedComponent) { return class hocComponent extends React.Component { constructor(){ super(props); this.state = { name: &apos;&apos; } } render() { const props = { name: this.state.name } return ( &lt;div className=&quot;layout&quot;&gt; &lt;WrappedComponent {...this.props} {...props} /&gt; &lt;/div&gt; ) } } } 继承反转 Inheritance Inversion：继承自WrappedComponent function hocInheritanceInversion(WrappedComponent){ return class hocComponent extends WrappedComponent { render() { // 可以实现渲染劫持，实现Loading等功能 return super.render(); } } }","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hi2048.github.io/tags/React/"}]},{"title":"React组件","slug":"React组件","date":"2018-05-14T16:00:00.000Z","updated":"2019-09-16T07:20:38.604Z","comments":true,"path":"2018/05/15/React组件/","link":"","permalink":"http://hi2048.github.io/2018/05/15/React组件/","excerpt":"","text":"无状态组件：采用函数式定义 不含状态管理 不包含任何状态，但可以包含属性，同样的props会得到同样的渲染结果，不会有副作用； 无状态组件生成时不会实例化，整体渲染性能得到提升； 无状态组件没有this，ref和生命周期；function Welcome(props){ return (&lt;h1&gt;Hello, {props.name}&lt;/h1&gt;); } 有状态组件：采用ES6 Component形式定义 实例化的，并且可以访问组件的生命周期方法 class Welcome extends React.Component{ constructor(props){ super(props); this.state = { iShow: true } } render(){ return ( this.state.iShow?(&lt;h1&gt; Hello, {this.props.name} &lt;/h1&gt;) : null ) } }","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hi2048.github.io/tags/React/"}]},{"title":"同构字符串","slug":"同构字符串","date":"2018-05-08T16:00:00.000Z","updated":"2019-09-09T14:36:53.724Z","comments":true,"path":"2018/05/09/同构字符串/","link":"","permalink":"http://hi2048.github.io/2018/05/09/同构字符串/","excerpt":"","text":"判断两个长度相同的字符串是否是同构字符串。同构字符串为将一个字符串中的相同字符进行替换可以得到另一个字符串。 同构代表两个字符串中每个位置上字符在自身第一次出现的索引相同 var isPositionSame = function(ss, ts, index){ var sIndex = ss.indexOf(ss[index]); var tIndex = ts.indexOf(ts[index]); return sIndex === tIndex; } var isIsomorphic = function(s, t) { var ss = s.split(&apos;&apos;); var ts = t.split(&apos;&apos;); for(var i = 0, len = ts.length; i &lt; len; i++){ if(!isPositionSame(ss, ts, i)){ return false; } } return true; };","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hi2048.github.io/tags/算法/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"}]},{"title":"模板方法模式","slug":"模板方法模式","date":"2018-05-04T16:00:00.000Z","updated":"2019-10-15T15:28:55.343Z","comments":true,"path":"2018/05/05/模板方法模式/","link":"","permalink":"http://hi2048.github.io/2018/05/05/模板方法模式/","excerpt":"","text":"模板方法模式（Template Method） 代码实例 github -- abstractClass.js class AbstractClass { constructor() { if(new.target === AbstractClass) throw new Error(`${AbstractClass} cannot be initialized.`); console.log(&apos;AbstractClass constructor.&apos;); } templateMethod() { this.primitiveOperation1(); this.primitiveOperation2(); console.log(&apos;Abstract class template method.&apos;); } primitiveOperation1() { throw new Error(`${this.primitiveOperation1} should be overwrite.`) } primitiveOperation2() { throw new Error(`${this.primitiveOperation2} should be overwrite.`); } } module.exports = AbstractClass; -- concreteClass1.js const AbstractClass = require(&apos;./abstractClass&apos;); class ConcreteClass1 extends AbstractClass { constructor() { super(); console.log(&apos;ConcreteClass1 constructor.&apos;); } primitiveOperation1() { console.log(&apos;ConcreteClass1 primitiveOperation1.&apos;); } primitiveOperation2() { console.log(&apos;ConcreteClass1 primitiveOperation2.&apos;); } } module.exports = ConcreteClass1; -- concreteClass2.js const AbstractClass = require(&apos;./abstractClass&apos;); class ConcreteClass2 extends AbstractClass { constructor() { super(); console.log(&apos;ConcreteClass2 constructor.&apos;); } primitiveOperation1() { console.log(&apos;ConcreteClass2 primitiveOperation1.&apos;); } primitiveOperation2() { console.log(&apos;ConcreteClass2 primitiveOperation2.&apos;); } } module.exports = ConcreteClass2; -- concreteClass3.js const AbstractClass = require(&apos;./abstractClass&apos;); class ConcreteClass3 extends AbstractClass { constructor() { super(); console.log(&apos;ConcreteClass3 constructor.&apos;); } primitiveOperation2() { console.log(&apos;ConcreteClass3 primitiveOperation2.&apos;); } } module.exports = ConcreteClass3; -- client.js const AbstractClass = require(&apos;./abstractClass&apos;); const ConcreteClass1 = require(&apos;./concreteClass1&apos;); const ConcreteClass2 = require(&apos;./concreteClass2&apos;); const ConcreteClass3 = require(&apos;./concreteClass3&apos;); // test1 // const abstractClass = new AbstractClass(); // test concrete class 1 const concreteClass1 = new ConcreteClass1(); concreteClass1.templateMethod(); console.log(&apos;------&apos;); // test concrete class 2 const concreteClass2 = new ConcreteClass2(); concreteClass2.templateMethod(); console.log(&apos;------&apos;); // test concrete class 3 const concreteClass3 = new ConcreteClass3(); concreteClass3.templateMethod(); console.log(&apos;------&apos;);","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hi2048.github.io/tags/设计模式/"},{"name":"大话设计模式","slug":"大话设计模式","permalink":"http://hi2048.github.io/tags/大话设计模式/"}]},{"title":"原型模式","slug":"原型模式","date":"2018-04-11T16:00:00.000Z","updated":"2019-10-13T12:06:34.336Z","comments":true,"path":"2018/04/12/原型模式/","link":"","permalink":"http://hi2048.github.io/2018/04/12/原型模式/","excerpt":"","text":"原型模式（Prototype） 代码实例 github -- prototype.js class Prototype { constructor(prototypeId = &quot;prototypeId&quot;) { if(new.target === Prototype) throw new Error(`${Prototype} cannot be initialized.`); this.prototypeId = prototypeId; console.log(&apos;Prototype constructor.&apos;); } clone() { return; } } module.exports = Prototype; -- concretePrototype1.js const Prototype = require(&apos;./prototype&apos;); class ConcretePrototype1 extends Prototype { constructor(id = &quot;id&quot;) { super(); this.id = id; console.log(&apos;ConcretePrototype1 constructor.&apos;); } clone() { return Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this)); } } module.exports = ConcretePrototype1; -- concretePrototype2.js const Prototype = require(&apos;./prototype&apos;); class ConcretePrototype2 extends Prototype { constructor(name = &quot;name&quot;) { super(); this.name = name; console.log(&apos;ConcretePrototype2 constructor.&apos;); } clone(initObj = {}) { return Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(Object.assign({}, this, initObj))); } } module.exports = ConcretePrototype2; -- client.js const ConcretePrototype1 = require(&apos;./concretePrototype1&apos;); const ConcretePrototype2 = require(&apos;./concretePrototype2&apos;); const concretePrototype1 = new ConcretePrototype1(); const concretePrototype2 = new ConcretePrototype2(); // test prototype1 clone const prototype1Demo1 = concretePrototype1.clone(); const prototype1Demo2 = concretePrototype1.clone(); console.log(prototype1Demo1); console.log(prototype1Demo2); prototype1Demo1.id = &apos;id1&apos;; console.log(prototype1Demo1); console.log(prototype1Demo2); prototype1Demo2.id = &apos;id2&apos;; console.log(prototype1Demo1); console.log(prototype1Demo2); console.log(&apos;------&apos;); const prototype2Demo1 = concretePrototype2.clone(); const prototype2Demo2 = concretePrototype2.clone({name: &quot;prototype2demo2 name2&quot;}); console.dir(prototype2Demo1); console.dir(prototype2Demo2); prototype2Demo1.name = &apos;change name 1&apos;; console.dir(prototype2Demo1); console.dir(prototype2Demo2); prototype2Demo2.name = &apos;change name 2&apos;; console.dir(prototype2Demo1); console.dir(prototype2Demo2); console.log(&apos;------&apos;);","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hi2048.github.io/tags/设计模式/"},{"name":"大话设计模式","slug":"大话设计模式","permalink":"http://hi2048.github.io/tags/大话设计模式/"}]},{"title":"工厂方法模式","slug":"工厂方法模式","date":"2018-03-08T16:00:00.000Z","updated":"2019-10-13T05:25:05.442Z","comments":true,"path":"2018/03/09/工厂方法模式/","link":"","permalink":"http://hi2048.github.io/2018/03/09/工厂方法模式/","excerpt":"","text":"工厂方法模式（Factory Method） 代码实例 github -- product.js class Product { constructor() { if(new.target === Product) throw new Error(`${Product} cannot be initialized.`); console.log(&apos;Product constructor.&apos;); } method() { return; } } module.exports = Product; -- concreteProduct.js const Product = require(&apos;./product&apos;); class ConcreteProduct extends Product { constructor() { super(); console.log(&apos;ConcreteProduct constructor&apos;); } method() { console.log(&apos;ConcreteProduct method&apos;); } } module.exports = ConcreteProduct; -- creator.js class Creator { constructor() { if(new.target === Creator) throw new Error(`${Creator} cannot be initialized.`); console.log(&apos;Creator constructor.&apos;); } factoryMethod() { return; } } module.exports = Creator; -- concreteCreator.js const Creator = require(&apos;./creator&apos;); const ConcreteProduct = require(&apos;./concreteProduct&apos;); class ConcreteCreator extends Creator { constructor(product) { super(); this.product = product; console.log(&apos;ConcreteCreator constructor.&apos;); } factoryMethod() { return this.product || new ConcreteProduct(); } } module.exports = ConcreteCreator; -- client.js const ConcreteCreator = require(&apos;./concreteCreator&apos;); const concreteCreator = new ConcreteCreator(); const concreteProduct = concreteCreator.factoryMethod(); concreteProduct.method();","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hi2048.github.io/tags/设计模式/"},{"name":"大话设计模式","slug":"大话设计模式","permalink":"http://hi2048.github.io/tags/大话设计模式/"}]},{"title":"代理模式","slug":"代理模式","date":"2018-02-14T16:00:00.000Z","updated":"2019-10-11T14:09:17.876Z","comments":true,"path":"2018/02/15/代理模式/","link":"","permalink":"http://hi2048.github.io/2018/02/15/代理模式/","excerpt":"","text":"代理模式（Proxy） 代码实例 github -- subject.js class Subject { constructor() { if(new.target === Subject) throw new Error(`${Subject} cannot be initialized.`); console.log(&apos;Subject constructor.&apos;); } request() { console.log(&apos;Subject request.&apos;); return; } } module.exports = Subject; -- realSubject.js const Subject = require(&apos;./subject&apos;); class RealSubject extends Subject { constructor() { super(); console.log(&apos;RealSubject constructor.&apos;); } request() { console.log(&apos;RealSubject request.&apos;); } } module.exports = RealSubject; -- proxy.js const Subject = require(&apos;./subject&apos;); const RealSubject = require(&apos;./realSubject&apos;); class Proxy extends Subject { constructor(realSubject) { super(); this.realSubject = this.initRealSubject(realSubject); console.log(&apos;Proxy constructor.&apos;); } initRealSubject(realSubject) { return realSubject || new RealSubject(); } getRealSubject() { return this.realSubject; } request() { this.getRealSubject().request(); } } module.exports = Proxy; -- client.js const Subject = require(&apos;./subject&apos;); const RealSubject = require(&apos;./realSubject&apos;); const Proxy = require(&apos;./proxy&apos;); const proxy = new Proxy(); proxy.request(); console.log(&apos;------&apos;); new Proxy(new RealSubject()).request(); console.log(&apos;------&apos;); new Subject();","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hi2048.github.io/tags/设计模式/"},{"name":"大话设计模式","slug":"大话设计模式","permalink":"http://hi2048.github.io/tags/大话设计模式/"}]},{"title":"React通信","slug":"React通信","date":"2018-01-11T16:00:00.000Z","updated":"2019-09-18T13:35:13.015Z","comments":true,"path":"2018/01/12/React通信/","link":"","permalink":"http://hi2048.github.io/2018/01/12/React通信/","excerpt":"","text":"父组件向子组件通信: props 子组件向父组件通信: 回调函数 跨级组件通信: context 非嵌套组件间通信: 自定义事件（发布-订阅模式或者观察者模式）emit","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hi2048.github.io/tags/React/"}]},{"title":"React之虚拟Dom","slug":"React之虚拟Dom","date":"2018-01-10T16:00:00.000Z","updated":"2019-09-18T14:15:39.964Z","comments":true,"path":"2018/01/11/React之虚拟Dom/","link":"","permalink":"http://hi2048.github.io/2018/01/11/React之虚拟Dom/","excerpt":"","text":"为什么引入虚拟Dom JavaScript速度快，Dom操作速度很慢 虚拟Dom通过diff算法实现Dom操作的优化，本质是通过JavaScript的运算，减少Dom的操作。 虚拟Dom 抽象出虚拟Dom（tagName, props, children） =&gt; 生成Patches（通过diff算法得到虚拟Dom的差异描述） =&gt; Update（通过Patch将差异更新到真实Dom上） Diff算法 深度遍历，记录差异 差异类型：涉及最小编辑距离问题","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"React","slug":"React","permalink":"http://hi2048.github.io/tags/React/"}]},{"title":"twoSum","slug":"twoSum","date":"2018-01-10T16:00:00.000Z","updated":"2019-09-10T16:00:16.268Z","comments":true,"path":"2018/01/11/twoSum/","link":"","permalink":"http://hi2048.github.io/2018/01/11/twoSum/","excerpt":"","text":"求数组中两个数值之和为指定值的下标，可以采用hash来解决 const twoSum = (nums, target) =&gt; { let hash = {}; for(let i = 0, len = nums.length; i &lt; len; i++){ if(typeof hash[target - nums[i]] !== &apos;undefined&apos;){ return [hash[target - nums[i]], i]; } hash[nums[i]] = i; } }","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hi2048.github.io/tags/算法/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"}]},{"title":"arrayTwoSum","slug":"arrayTwoSum","date":"2018-01-09T16:00:00.000Z","updated":"2019-09-10T15:52:00.476Z","comments":true,"path":"2018/01/10/arrayTwoSum/","link":"","permalink":"http://hi2048.github.io/2018/01/10/arrayTwoSum/","excerpt":"","text":"求数组下标，下标区间数值之和为指定值 const twoSum = (nums, target) =&gt;{ let count = 0; for(let i = 0, len = nums.length; i &lt; len;){ count = nums[i]; if(count &gt; target){ i++ } else if(count === target){ return [i, i]; } else{ for(let j = i + 1; j &lt; len; j++){ count += nums[j]; if(count &gt; target){ i++; break; } else if(count === target){ return [i, j]; } } } } }","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hi2048.github.io/tags/算法/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"}]},{"title":"装饰模式","slug":"装饰模式","date":"2018-01-08T16:00:00.000Z","updated":"2019-10-11T12:41:25.983Z","comments":true,"path":"2018/01/09/装饰模式/","link":"","permalink":"http://hi2048.github.io/2018/01/09/装饰模式/","excerpt":"","text":"装饰模式（Decorator） 代码实例 github -- component.js class Component { constructor() { if(new.target === Component) { throw new Error(`${Component} cannot be initialized.`); } console.log(&apos;Component constructor.&apos;); } Operation() { console.log(&apos;Component operation.&apos;); return; } } module.exports = Component; -- concreteComponent.js const Component = require(&apos;./component&apos;); class ConcreteComponent extends Component { constructor() { super(); console.log(&apos;ConcreteComponent constructor.&apos;); } Operation() { console.log(&apos;ConcreteComponent Operation.&apos;); } } module.exports = ConcreteComponent; -- decorator.js const Component = require(&apos;./component&apos;); class Decoration extends Component { constructor(component) { if(new.target === Decoration) { throw new Error(`${Decoration} cannot be initialized.`); } super(); this.component = component; console.log(&apos;Decoration constructor.&apos;); } Operation() { if(this.component) { this.component.Operation(); } } } module.exports = Decoration; -- concreteDecoratorA.js const Decorator = require(&apos;./decorator&apos;); class ConcreteDecorationA extends Decorator { constructor(component) { super(); this.component = component; this.decoratorA = &apos;decoratorA&apos;; console.log(&apos;ConcreteDecorationA constructor.&apos;); } Operation() { super.Operation(); console.log(this.decoratorA); } } module.exports = ConcreteDecorationA; -- concreteDecoratorB.js const Decorator = require(&apos;./decorator&apos;); class ConcreteDecoratorB extends Decorator { constructor(component) { super(); this.component = component; this.decoratorB = &apos;decoratorB&apos;; console.log(&apos;ConcreteDecoratorB constructor.&apos;); } Operation() { super.Operation(); console.log(this.decoratorB); } } module.exports = ConcreteDecoratorB; -- client.js const ConcreteComponent = require(&apos;./concreteComponent&apos;); const ConcreteDecoratorA = require(&apos;./concreteDecoratorA&apos;); const ConcreteDecoratorB = require(&apos;./concreteDecoratorB&apos;); console.log(&apos;------&apos;); const concreteComponent = new ConcreteComponent(); concreteComponent.Operation(); console.log(&apos;------&apos;); // test decorator A 1 console.log(&apos;------&apos;); const decoratorA1 = new ConcreteDecoratorA(); decoratorA1.Operation(); console.log(&apos;------&apos;); // test decorator A 2 console.log(&apos;------&apos;); const decoratorA2 = new ConcreteDecoratorA(concreteComponent); decoratorA2.Operation(); console.log(&apos;------&apos;); // test decorator B console.log(&apos;------&apos;); const decoratorB = new ConcreteDecoratorB(concreteComponent); decoratorB.Operation(); console.log(&apos;------&apos;); // test decorator ABAAB const decorationABAAB = new ConcreteDecoratorB(new ConcreteDecoratorA(new ConcreteDecoratorA(new ConcreteDecoratorB(new ConcreteDecoratorA(new ConcreteComponent()))))); decorationABAAB.Operation();","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hi2048.github.io/tags/设计模式/"},{"name":"大话设计模式","slug":"大话设计模式","permalink":"http://hi2048.github.io/tags/大话设计模式/"}]},{"title":"移除链表元素","slug":"移除链表元素","date":"2017-12-09T16:00:00.000Z","updated":"2019-09-09T03:41:44.275Z","comments":true,"path":"2017/12/10/移除链表元素/","link":"","permalink":"http://hi2048.github.io/2017/12/10/移除链表元素/","excerpt":"","text":"删除单向链表中值为 val 的所有节点。 思路：可以添加指向头结节的Head*节点，然后进行删除操作。 function removeLinkNodes(head, val) { if(!head) return null; var prevElement = { this.next = head; } var sPointer = prevElement; while(sPointer.next){ if(sPointer.next.val === val){ sPointer.next = sPointer.next.next; } else{ sPointer = sPointer.next; } } return prevElement.next; };","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hi2048.github.io/tags/算法/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"}]},{"title":"策略模式","slug":"策略模式","date":"2017-12-07T16:00:00.000Z","updated":"2019-10-08T15:13:11.841Z","comments":true,"path":"2017/12/08/策略模式/","link":"","permalink":"http://hi2048.github.io/2017/12/08/策略模式/","excerpt":"","text":"策略模式（Strategy） 代码实例 github -- cashSuper.js class CashSuper { constructor() { if(new.target === CashSuper) throw new Error(`${CashSuper} cannot be initialized.`); console.log(&apos;CashSuper constructor.&apos;); } acceptCash(money) { console.log(&apos;CashSuper acceptCash.&apos;); return; } } module.exports = CashSuper; -- cashNormal.js const CashSuper = require(&apos;./cashSuper.js&apos;); class CashNormal extends CashSuper { constructor() { super(); console.log(&apos;CashNormal constructor.&apos;); } acceptCash(money) { return money; } } module.exports = CashNormal; -- casnRebate.js const CashSuper = require(&apos;./cashSuper&apos;); class CashRebate extends CashSuper { constructor({rebate = 1}) { super(); console.log(&apos;CashRebate constructor.&apos;); this.rebate = rebate; } acceptCash(money) { return money * this.rebate; } } module.exports = CashRebate; -- cashReturn.js const CashSuper = require(&apos;./cashSuper&apos;); class CashReturn extends CashSuper { constructor({condition = 0, moneyReturn = 0}) { super(); console.log(&apos;CashReturn constructor.&apos;); this.condition = condition; this.moneyReturn = moneyReturn; } acceptCash(money) { let result = money; if(money &gt;= this.condition) { result -= Math.floor(money / this.condition) * this.moneyReturn; } return result; } } module.exports = CashReturn; -- cashContext.js const CashNormal = require(&apos;./cashNormal&apos;); const CashRebate = require(&apos;./cashRebate&apos;); const CashReturn = require(&apos;./cashReturn&apos;); class CashContext { constructor(type, args) { switch(type.toUpperCase()) { case &apos;NORMAL&apos;: this.cs = new CashNormal(); break; case &apos;REBATE&apos;: this.cs = new CashRebate(args); break; case &apos;RETURN&apos;: this.cs = new CashReturn(args); break; default: this.cs = new CashNormal(); } } getResult(money) { return this.cs.acceptCash(money); } } module.exports = CashContext; -- client.js const CashContext = require(&apos;./cashContext&apos;); //test let cs = new CashContext(&apos;Normal&apos;); console.log(cs.getResult(100)); cs = new CashContext(&apos;REBATE&apos;, {&apos;rebate&apos;: .8}); console.log(cs.getResult(100)); cs = new CashContext(&apos;return&apos;, {&apos;condition&apos;: 300, &apos;moneyReturn&apos;: 100}); console.log(cs.getResult(300)); console.log(cs.getResult(500)); console.log(cs.getResult(600));","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hi2048.github.io/tags/设计模式/"},{"name":"大话设计模式","slug":"大话设计模式","permalink":"http://hi2048.github.io/tags/大话设计模式/"}]},{"title":"JavaScript中的循环中断","slug":"JavaScript中的循环中断","date":"2017-11-09T16:00:00.000Z","updated":"2019-09-10T15:25:41.717Z","comments":true,"path":"2017/11/10/JavaScript中的循环中断/","link":"","permalink":"http://hi2048.github.io/2017/11/10/JavaScript中的循环中断/","excerpt":"","text":"循环中断break, continue, return 比较 // break continue return // break跳出当前循环 continue结束当前条件 return 返回函数值 console.log(&quot;normal: &quot;) for(var i = 0; i &lt; 2; i++){ console.log(`${i} `); for(var j = 3; j &lt; 6; j++){ console.log(`${j} `); } } console.log(&quot;break: &quot;) for(var i = 0; i &lt; 2; i++){ console.log(`${i} `); for(var j = 3; j &lt; 6; j++){ if(j === 4) break; console.log(`${j} `); } } console.log(&quot;continue: &quot;) for(var i = 0; i &lt; 2; i++){ console.log(`${i} `); for(var j = 3; j &lt; 6; j++){ if(j === 4) continue; console.log(`${j} `); } } console.log(&quot;return: &quot;) for(var i = 0; i &lt; 2; i++){ console.log(`${i} `); for(var j = 3; j &lt; 6; j++){ if(j === 4){ return; } console.log(`${j} `); } } normal: 0 3 4 5 1 3 4 5 break: 0 3 1 3 continue: 0 3 5 1 3 5 return: 0 3","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"}]},{"title":"简单工厂模式","slug":"简单工厂模式","date":"2017-11-09T16:00:00.000Z","updated":"2019-09-29T10:25:35.738Z","comments":true,"path":"2017/11/10/简单工厂模式/","link":"","permalink":"http://hi2048.github.io/2017/11/10/简单工厂模式/","excerpt":"","text":"简单工厂模式 代码实例 github -- operation.js class Operation { constructor(numberA, numberB) { this.numberA = numberA; this.numberB = numberB; } getResult(numberA = this.numberA, numberB = this.numberB) { return; } } module.exports = Operation; -- add.js const Operation = require(&apos;./operation.js&apos;); class Add extends Operation{ constructor(numberA, numberB) { super(numberA, numberB); } getResult(numberA = this.numberA, numberB = this.numberB) { return numberA + numberB; } } module.exports = Add; -- subtract.js const Operation = require(&apos;./operation.js&apos;); class Subtract extends Operation{ constructor(numberA, numberB){ super(numberA, numberB); } getResult(numberA = this.numberA, numberB = this.numberB){ return numberA - numberB; } } module.exports = Subtract; -- multiply.js const Operation = require(&apos;./operation.js&apos;); class Multiply extends Operation{ constructor(numberA, numberB) { super(numberA, numberB); } getResult(numberA = this.numberA, numberB = this.numberB){ return numberA * numberB; } } module.exports = Multiply; -- division.js const Operation = require(&apos;./operation.js&apos;); class Division extends Operation{ constructor(numberA, numberB) { super(numberA, numberB); } getResult(numberA = this.numberA, numberB = this.numberB) { if(numberB === 0) { throw new Error(&apos;Exception with dividend 0.&apos;); } return numberA / numberB; } } module.exports = Division; -- operationFactory.js const Operation = require(&apos;./operation.js&apos;); const Add = require(&apos;./add.js&apos;); const Subtract = require(&apos;./subtract.js&apos;); const Multiply = require(&apos;./multiply.js&apos;); const Division = require(&apos;./division.js&apos;); class OperationFactory { constructor(operate){ this.operate = operate; } createOperator(operate) { switch(this.operate || operate) { case &apos;+&apos;: return new Add(); case &apos;-&apos;: return new Subtract(); case &apos;*&apos;: return new Multiply(); case &apos;/&apos;: return new Division(); default: return new Operation(); } } } module.exports = OperationFactory; -- test.js const OperationFactory = require(&apos;./operationFactory.js&apos;); const operationFactory = new OperationFactory(); const operation = operationFactory.createOperator(); const add = operationFactory.createOperator(&apos;+&apos;); const substract = operationFactory.createOperator(&apos;-&apos;); const multiply = operationFactory.createOperator(&apos;*&apos;); const division = operationFactory.createOperator(&apos;/&apos;); console.log(operation.getResult()); console.log(add.getResult(2, 3)); console.log(substract.getResult(2, 3)); console.log(multiply.getResult(2, 3)); console.log(division.getResult(2, 3)); console.log(division.getResult(2, 0));","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hi2048.github.io/tags/设计模式/"},{"name":"大话设计模式","slug":"大话设计模式","permalink":"http://hi2048.github.io/tags/大话设计模式/"}]},{"title":"js笔记","slug":"js笔记","date":"2017-09-01T00:00:00.000Z","updated":"2019-09-05T15:00:49.612Z","comments":true,"path":"2017/09/01/js笔记/","link":"","permalink":"http://hi2048.github.io/2017/09/01/js笔记/","excerpt":"","text":"JS基本数据类型：Number、String 、Boolean 、Null、Undefined null，undefined的区别？ null表示一个对象被定义了，但存放了空指针，转换为数值时为0。 undefined表示声明的变量未初始化，转换为数值时为NAN。 typeof(null) – object;typeof(undefined) – undefined 同源 要同时满足以下3个条件，才能叫同源： 协议相同 端口相同 主机相同","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"}]},{"title":"CD数量","slug":"CD数量","date":"2017-05-09T16:00:00.000Z","updated":"2019-09-10T15:35:24.506Z","comments":true,"path":"2017/05/10/CD数量/","link":"","permalink":"http://hi2048.github.io/2017/05/10/CD数量/","excerpt":"","text":"你作为一名出道的歌手终于要出自己的第一份专辑了，你计划收录 n 首歌而且每首歌的长度都是 s 秒，每首歌必须完整地收录于一张 CD 当中。每张 CD 的容量长度都是 L 秒，而且你至少得保证同一张 CD 内相邻两首歌中间至少要隔 1 秒。为了辟邪，你决定任意一张 CD 内的歌数不能被 13 这个数字整除，那么请问你出这张专辑至少需要多少张 CD ？ 需要考虑剩余为13倍数的情况，每张歌曲数量可以通过计算得来。 function getCDCount(n, s, l){ //计算每张CD歌曲数量 var countPerCD = Math.floor((l + 1) / (s + 1)); countPerCD = countPerCD &gt; n?n : countPerCD; if(countPerCD % 13 === 0){ countPerCD --; } var count = n / countPerCD; count = Math.ceil(count); //最后剩余数量为13的倍数且比每张少1，则总CD需要+1 var leftCount = n % countPerCD; if(leftCount !== 0 &amp;&amp; leftCount % 13 === 0 &amp;&amp; leftCount === countPerCD - 1){ count ++; } console.log(count); return count; }","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hi2048.github.io/tags/算法/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"}]},{"title":"self-introduction","slug":"self-introduction","date":"2017-01-20T16:00:00.000Z","updated":"2019-09-11T04:12:27.956Z","comments":true,"path":"2017/01/21/self-introduction/","link":"","permalink":"http://hi2048.github.io/2017/01/21/self-introduction/","excerpt":"","text":"Hi, I am Su Jiefeng. I obtained my master degree in computer science in Northwest Univercity. During my performance period at HW company, I utilized my skills to complete web projects and increase the working efficiency of our team with user interface greatly as a front-end engineer. The reason why I choosed this position is that I’m really impressed by the things you do and also I want to challenge and improve myself. As a self-motivated persion, I’m sure I can be a great asset to your group.","categories":[{"name":"未分类","slug":"未分类","permalink":"http://hi2048.github.io/categories/未分类/"}],"tags":[]},{"title":"reduce方法","slug":"reduce方法","date":"2017-01-09T16:00:00.000Z","updated":"2019-09-10T15:41:06.816Z","comments":true,"path":"2017/01/10/reduce方法/","link":"","permalink":"http://hi2048.github.io/2017/01/10/reduce方法/","excerpt":"","text":"数组reduce方法 // reduce a,b传入初始值则 b为数组第1个值，否则a为第1个，b为第2个，第二次运行则a为上一次的数据，b为第3个值 //array.reduce(function(total, currentValue, currentIndex, arr), initialValue) [1,2,3,4,5].reduce(function(a,b){ console.log(`${a}:${b}:${a + b}`) return a+b; }, 0); // 0:1:1 // 1:2:3 // 3:3:6 // 6:4:10 // 10:5:15 [1,2,3,4,5].reduce(function(a,b){ console.log(`${a}:${b}:${a + b}`) return a+b; }); // 1:2:3 // 3:3:6 // 6:4:10 // 10:5:15","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"}]},{"title":"curry","slug":"curry","date":"2016-12-27T16:00:00.000Z","updated":"2019-09-11T07:32:48.402Z","comments":true,"path":"2016/12/28/curry/","link":"","permalink":"http://hi2048.github.io/2016/12/28/curry/","excerpt":"","text":"什么是函数式编程curry：将带有多个参数的复杂函数，返回一个接受部分参数的函数，同时处理剩余的参数。 为什么要使用curry? 可以完成对高阶函数的降阶处理，简单来说就是可以将复杂问题拆分成简单问题。 let add = (x) =&gt; (y) =&gt; (x + y) let increment = add(1);","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hi2048.github.io/tags/算法/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"},{"name":"函数式","slug":"函数式","permalink":"http://hi2048.github.io/tags/函数式/"}]},{"title":"纯函数","slug":"纯函数","date":"2016-12-19T16:00:00.000Z","updated":"2019-09-11T07:47:00.355Z","comments":true,"path":"2016/12/20/纯函数/","link":"","permalink":"http://hi2048.github.io/2016/12/20/纯函数/","excerpt":"","text":"什么是纯函数 相同的输入必定有相同的输出 没有任何可观察的副作用 一般具有副作用的操作 访问函数以外的系统状态 修改以参数形式传递过来的对象或者数组 发起http请求，如Ajax等 使用或者保存用户输入 操作DOM 输出数据到控制台 Math.random(),或者当前时间,splice等方法 纯函数有什么用 容易测试 容易重构 结果可以缓存 let add = (x, y) =&gt; (x + y);","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"}]},{"title":"那年真的如风","slug":"那年真的如风","date":"2016-05-18T11:46:27.000Z","updated":"2019-08-28T14:39:04.087Z","comments":true,"path":"2016/05/18/那年真的如风/","link":"","permalink":"http://hi2048.github.io/2016/05/18/那年真的如风/","excerpt":"","text":"太多太多的事情，让我们分心，时间久了，慢慢地不记得了当初年少时的梦。 两年时间说长不长，说短也不短，经历了好多，却发现最不能忘却的还是曾经的自己，好想时光重回到2年前的那个傍晚，夕阳洒在脸膀。 这一次我想更加细细的走过。 &nbsp;","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hi2048.github.io/categories/杂谈/"}],"tags":[]},{"title":"工作之感悟","slug":"工作之感悟","date":"2015-11-09T16:00:00.000Z","updated":"2019-09-05T13:41:19.043Z","comments":true,"path":"2015/11/10/工作之感悟/","link":"","permalink":"http://hi2048.github.io/2015/11/10/工作之感悟/","excerpt":"","text":"不知不觉间，已经工作1年多了，从开春的3月，如今却已快入冬，时间就在你不经意间，悄悄划过，不留一丝的痕迹。 每天都在忙碌，每天都在重复，每天都在感叹时间太少，可是却也不曾做成什么不一样的事情。 从最初的最简单的JS函数写起，再到应用面向对象，再到后来的模块化编程，了解了函数式编程，再到AngularJS。研究了JS内存泄漏问题，特别喜欢HTML5与CSS3做出来的动画，喜欢Google的material design，做出了各种圆周运动的效果。如今却不知道前途如何，以后应该做些什么，在技术的道路一直走下去，还是去做点不一样的东西。 再回过头来看，自己确实是成长了不少。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hi2048.github.io/categories/杂谈/"}],"tags":[]},{"title":"闭包","slug":"闭包","date":"2015-06-07T16:00:00.000Z","updated":"2019-09-18T14:35:14.318Z","comments":true,"path":"2015/06/08/闭包/","link":"","permalink":"http://hi2048.github.io/2015/06/08/闭包/","excerpt":"","text":"闭包概念 能够读取其他函数内部变量的函数。 或简单理解为定义在一个函数内部的函数，内部函数持有外部函数内变量的引用。 function outFunc(){ var outAttr = &quot;outAttr&quot;; function innerFunc(){ console.log(outAttr); } return innerFunc; } var myFunc = outFunc(); // myFunc为一个引入outAttr的闭包 为什么有闭包 避免污染全局变量 利于代码的封装 使用时注意内在泄露","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"}]},{"title":"判断素数","slug":"判断素数","date":"2015-02-01T00:00:00.000Z","updated":"2019-09-11T10:08:07.035Z","comments":true,"path":"2015/02/01/判断素数/","link":"","permalink":"http://hi2048.github.io/2015/02/01/判断素数/","excerpt":"","text":"判断素数 function isPrimeN(n) { if(n == 0 || n==1){ return false; } if(n==2){ return true; } for(var i = 2; i &lt;= Math.sqrt(n); i++){ if(n % i == 0){ return false; } } return true; } http和https的区别 https 需要ca证书 http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"}]},{"title":"定寅时歌诀","slug":"定寅时歌诀","date":"2014-11-13T10:57:34.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2014/11/13/定寅时歌诀/","link":"","permalink":"http://hi2048.github.io/2014/11/13/定寅时歌诀/","excerpt":"","text":"正七五更二点徹， 二八五更四点歇， 三七平光是寅时， 四六日出定无别， 五月日高三太地， 十月十二四更一， 仲冬继到四更初， 此是寅时君须记。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"逐年客气歌","slug":"逐年客气歌","date":"2014-11-11T11:26:10.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2014/11/11/逐年客气歌/","link":"","permalink":"http://hi2048.github.io/2014/11/11/逐年客气歌/","excerpt":"","text":"每年退二是客乡， 上临实数下临方， 初中六气排轮取， 主客兴衰定弱强。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"定太阴出时歌诀","slug":"定太阴出时歌诀","date":"2014-10-14T11:37:31.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2014/10/14/定太阴出时歌诀/","link":"","permalink":"http://hi2048.github.io/2014/10/14/定太阴出时歌诀/","excerpt":"","text":"三辰五巳八午升， 初十出未十三申， 十五酉时十八戌， 二十玄上记其神， 二十三日子时出， 二十六日丑时行， 二十八日寅时立， 三十加来卯上轮。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"逐年主气歌","slug":"逐年主气歌","date":"2014-10-13T08:14:00.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2014/10/13/逐年主气歌/","link":"","permalink":"http://hi2048.github.io/2014/10/13/逐年主气歌/","excerpt":"","text":"初气逐年水主先， 二君三相火排连， 四来是土常为主， 五气金生六水天。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"定太阳出没歌诀","slug":"定太阳出没歌诀","date":"2014-09-22T06:38:44.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2014/09/22/定太阳出没歌诀/","link":"","permalink":"http://hi2048.github.io/2014/09/22/定太阳出没歌诀/","excerpt":"","text":"正九出乙入庚方， 二八出兔入鸡场， 三七发甲入辛地， 四六生寅入戌乡， 五月生艮居乾上， 仲冬出巽入坤方， 唯有十于十二月， 出辰入申仔细详。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"推五运","slug":"推五运","date":"2014-08-13T08:24:39.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2014/08/13/推五运/","link":"","permalink":"http://hi2048.github.io/2014/08/13/推五运/","excerpt":"","text":"十干行天地之运，天地之气有邪有正，相互消长，正气衰则邪气盛，邪气弱则正气强，此阴阳消长的结果。故五行之气，有本初之气、更革之气。本初为正气，更革为邪气。正气有定位，邪气无定位，古人于此深致意也。 法则：甲己化土一六同宗，乙庚化金二七同道，丙辛化水三八为朋，丁壬化木四九为友，戊癸化火五十同途，此五运化气皆为天地更革之气，不得中正也。阳年五运化气太过，阴年五运化气不及，过于不及都能为殃，是其六甲之岁堆阜之纪，岁土湿气流行，其邪于水羽音为孤。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"逐月六气歌","slug":"逐月六气歌","date":"2014-08-10T08:01:40.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2014/08/10/逐月六气歌/","link":"","permalink":"http://hi2048.github.io/2014/08/10/逐月六气歌/","excerpt":"","text":"厥阴木气大寒初， 君火春分土上居， 小满少阳三候主， 太阴大暑四交之， 秋分五是阳明位， 寒水终于小雪时。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"逐年六气歌","slug":"逐年六气歌","date":"2014-08-07T02:17:40.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2014/08/07/逐年六气歌/","link":"","permalink":"http://hi2048.github.io/2014/08/07/逐年六气歌/","excerpt":"","text":"子午少阴君火尊， 丑未湿土太阴临， 寅申少阳逐相位， 卯酉阳明值燥金， 辰戌太阳寒水是， 巳亥厥阴风木侵。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"逐年五运歌","slug":"逐年五运歌","date":"2014-08-05T10:37:56.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2014/08/05/逐年五运歌/","link":"","permalink":"http://hi2048.github.io/2014/08/05/逐年五运歌/","excerpt":"","text":"大寒木运始行初， 清明前三火运居， 芒种后三土运是， 立秋后六金运推， 立冬后九水运伏， 周而复始万年和。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"五运化气歌","slug":"五运化气歌","date":"2014-07-29T09:43:32.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2014/07/29/五运化气歌/","link":"","permalink":"http://hi2048.github.io/2014/07/29/五运化气歌/","excerpt":"","text":"甲己化土乙庚金，丁壬化木尽成林，丙辛化水滔滔去，戊癸南方火焰侵。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"五运六气","slug":"五运六气","date":"2014-07-27T08:50:19.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2014/07/27/五运六气/","link":"","permalink":"http://hi2048.github.io/2014/07/27/五运六气/","excerpt":"","text":"天符运气说： 运气：即五运六气。 五运：指十天干化运的五行。 六气：指十二支所值的五行。 凡开山造葬宜取山向于年月运气，相生则吉，比合次吉，山音克运气吉，运气克山凶。 五运有旋转之机，六气有迟早之变，天是以终始之因以地，地是以终始之因以物。运者即五行，六气者即五行变化（暑火湿燥寒），故一气生六十日，六六三百六十日，六甲终以阴阳寒暑之运而成一岁，冬至后得甲子为早，或在十二月节为中，或在正月为迟，夏至仿此，故物之生落迟早感应于此而已。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"让改变发生","slug":"让改变发生","date":"2014-07-19T16:37:23.000Z","updated":"2019-09-05T09:05:45.232Z","comments":true,"path":"2014/07/20/让改变发生/","link":"","permalink":"http://hi2048.github.io/2014/07/20/让改变发生/","excerpt":"","text":"4个月前，还在学校，做着美梦，心中放着豪言，只要给我网络，就没有什么做不出来的。如今，工作已经4个月了，回首往事，却发现自己把一切想的太简单太美好，原来不是你想做什么就可以做什么的。 总在想象着自己可以参与一款与从不同的产品，然后做出极致炫酷的UI，让千万人去感受去体验。 回想4个月的工作，每一天都在忙碌中度过，除了学到了一些繁琐的流程，做着一些缝缝补补的事情外，还学到的什么？我竟然答不上来，热情慢慢被磨灭，以前引以为傲的技术，也已经差不多费了。 无意间看到阿里的招聘，扫了一眼，发现差的好远呀。知道15个左右，算一算也只有AngularJS，Jsonp与Localstorage比较熟悉，算是用过。 下面把查到的信息共享出来，以供参考（如有错误，欢迎纠正哈）。 1. Angular AngularJS是Google推出的一款MVVM前端开发框架，其目的是简化前端的开发，其核心理念有依赖注入，数据绑定。 参考网址：https://angularjs.org/ 2. Backbone BackboneJS是一套web开发框架，通过提供model，collection，view来简化前端开发，需要underscore.js的支持。 参考网址：http://backbonejs.org/ 3. Console Console这里指的是前端Console控制台命令，用来调试JS代码。 参考网址：http://www.w3cfuns.com/article-5596431-1-1.html 4. Dir Dir这里不知是不是指的console.dir，打印输出一个对象中的所有属性。 5. Express Express这里不知是指的CSS Express还是NodeJS的一个框架。 参考网址：http://expressjs.com/ http://www.cnblogs.com/muguaworld/archive/2011/11/13/2247180.html 6. Fork Fork这里应该指的是GitHub上的Fork，本质是一个代码复制的操作。 7. Grunt Grunt是一款前端的任务运行器，可以帮助开发者完成一些可以自动化进行的操作。 参考网址：http://gruntjs.com/ 8. Haslayout Haslayout是Windows Internet Explorer渲染引擎的一个内部组成部分。 参考网址：http://baike.baidu.com/view/2945869.htm?fr=aladdin 9. Iconfont CSS3中自定义字体引入的一个概念，将网站常用的图标做成字体引入页面。 参考网址：http://www.qianduan.net/css3-icon-font-guide.html 10. Jsonp Jsonp主要是为了解决跨域数据获取的问题。 参考网址：http://www.cnblogs.com/yuzhongwusan/archive/2012/12/11/2812849.html 11. Kissy Kissy是阿里集团前端工程师们发起创建的一款跨终端、模块化、高性能、使用简单的 JavaScript 框架。 参考网址：http://docs.kissyui.com/ 12. Localstorage HTML5中提供的一种可供本地存储的方法。 参考网址：http://www.w3school.com.cn/html5/html_5_webstorage.asp 13. Media query CSS中提供的一种可以根据不同的设备或者分辨率使用不同的样式文件。 参考网址：http://www.cnblogs.com/asqq/archive/2012/04/13/2445912.html 14. Npm NodeJS中的包管理工具。 参考网址：https://www.npmjs.org/ 15. Opacity CSS中的一个属性，用来表示网页节点的透明度。 参考网址：https://developer.mozilla.org/en-US/docs/Web/CSS/opacity 16. Prototype JS中用来表示对象原型的引用。 参考网址：http://www.cnblogs.com/yjf512/archive/2011/06/03/2071914.html 17. Querystring Querystring用来表示网页中的查询字符串，页面跳转之间传递的参数。 参考网址：http://www.cnblogs.com/sunnycoder/archive/2010/02/28/1674998.html 18. Referer HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。 参考网址：http://baike.baidu.com/link?url=HPq8iBdf9ZETBOb8us9839ESWut9Xap6PS3nezO3mYvXl7ajLZBFVvCylffhRxcnTkNpfKw5f8KVPuwPE1BVUK 19. Seajs 开源项目，提供简单、极致的模块化开发体验。 参考网址：http://seajs.org/docs/ 20. Trim 去除空格的方法。 参考网址：http://www.cnblogs.com/qixuejia/archive/2010/08/11/1797523.html 21. Underscore Underscore是一个JS的库，提供了很多实用的方法。 参考网址：http://underscorejs.org/ 22. Vim 一款代码编辑器。 参考网址：http://bbs.blueidea.com/thread-2938273-1-1.html 23. Worker Web Worker的基本原理就是在当前javascript的主线程中，使用Worker类加载一个javascript文件来开辟一个新的线程，起到互不阻塞执行的效果，并且提供主线程和新线程之间数据交换的接口：postMessage，onmessage。 参考网址：http://www.w3school.com.cn/html5/html_5_webworkers.asp http://www.cnblogs.com/feng_013/archive/2011/09/20/2175007.html 24. Xss 跨站脚本攻击。 25. Yslow YSlow可以对网站的页面进行分析，并告诉你为了提高网站性能，如何基于某些规则而进行优化。 参考网址：http://baike.baidu.com/view/3383166.htm?fr=aladdin 26. Zepto 体积更小，效率更高的类Jquery库。 参考网址：http://www.cnblogs.com/samwu/archive/2013/06/06/3121649.html http://zeptojs.com/ 其它 Bootstrap 简洁、直观、强悍的前端开发框架，让web开发更迅速、简单。 参考网址：http://www.bootcss.com/ &nbsp; 结束语： 路还好漫长，努力做一个会写代码的设计师！","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[]},{"title":"命中六亲取用","slug":"命中六亲取用","date":"2014-07-10T08:32:49.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2014/07/10/命中六亲取用/","link":"","permalink":"http://hi2048.github.io/2014/07/10/命中六亲取用/","excerpt":"","text":"生我者为父母，偏印、正印；我生者为子孙，食神、伤官；克我者为官杀，偏官、正官；我克者为妻财，偏财、正财；比和者为兄弟，比肩、劫财。以日干为我在四柱中取用。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"让我们一起来做点与众不同的事情","slug":"让我们一起来做点与众不同的事情","date":"2014-07-02T14:08:52.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2014/07/02/让我们一起来做点与众不同的事情/","link":"","permalink":"http://hi2048.github.io/2014/07/02/让我们一起来做点与众不同的事情/","excerpt":"","text":"生活在不知不觉间，会慢慢将你磨平。给自己点信心，给自己点勇气，给自己梦想，加油，未来！","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hi2048.github.io/categories/杂谈/"}],"tags":[]},{"title":"JavaScript类与继承","slug":"JavaScript类与继承","date":"2014-05-04T16:00:00.000Z","updated":"2019-09-18T14:34:29.914Z","comments":true,"path":"2014/05/05/JavaScript类与继承/","link":"","permalink":"http://hi2048.github.io/2014/05/05/JavaScript类与继承/","excerpt":"","text":"定义类 //定义属性 function MyClass(attr1, attr2) { this.attr1 = attr1; this.attr2 = attr2; } //定义方法 MyClass.prototype = { constructor : MyClass, myFunc : function() { console.log(this.attr1); } }; 继承类 //定义父类 function SuperClass(attr) { this.attr = attr; } SuperClass.prototype = { superFunc : function() { console.log(this.attr); } }; //继承父类 function SubClass(attr, subAttr) { //继承属性 SuperClass.call(this, attr); this.subAttr = subAttr; } //继承方法 SubClass.prototype = new SuperClass();","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"}]},{"title":"十年之后","slug":"十年之后","date":"2014-02-22T11:21:46.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2014/02/22/十年之后/","link":"","permalink":"http://hi2048.github.io/2014/02/22/十年之后/","excerpt":"","text":"十年之后，我不敢想。 十年之前， 还记得那个朗诵诗文的自己， “寻梦？撑一支长篙，” 教室还是那个教室， 自己不再是原来那个自己， 少了点童真， 少了点执着， 多了份踌躇， 也多了份风轻云淡。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hi2048.github.io/categories/杂谈/"}],"tags":[]},{"title":"艮卦中干支旺衰","slug":"艮卦中干支旺衰","date":"2013-11-09T09:30:41.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/11/09/艮卦中干支旺衰/","link":"","permalink":"http://hi2048.github.io/2013/11/09/艮卦中干支旺衰/","excerpt":"","text":"艮卦 甲、寅、己、丑 ‘ 丙寅 世 ‘’ 丙子 ‘’ 丙戌 ‘ 丙申 应 ‘’ 丙午 ‘’ 丙辰艮卦是八纯卦之一，火旺土相，位居冬、春之月，甲、寅、己、丑、年、月、日、时，属土，旺于甲、寅、己、丑、纳音土，甲、寅木生火（丙火），丙火旺需泄生土（艮土)。所以艮卦納干表现为丙,在数字为八。丙申38、98…… 丙寅08、68……丙子18、78….. 丙午48、108……丙辰58、118…… 丙戌28、88……","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"兑卦中干支旺衰","slug":"兑卦中干支旺衰","date":"2013-11-07T04:44:01.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/11/07/兑卦中干支旺衰/","link":"","permalink":"http://hi2048.github.io/2013/11/07/兑卦中干支旺衰/","excerpt":"","text":"兑卦 辛、酉 ‘’ 丁未 世 ‘ 丁酉 ‘ 丁亥 ‘’ 丁丑 应 ‘ 丁卯 ‘ 丁巳 兑卦是八纯卦之一，位居西方，秋八月、辛、酉、年、月、日、时，属金，旺于秋、庚、申、辛、酉、纳音金。金旺需泄，泄则生出阴火（丁火）。所以兑卦納干表现为丁，在数字为七。 丁巳57、117…… 丁亥27、87…… 丁酉37、97….. 丁卯07、67…… 丁丑17、77…… 丁未47、107……","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"离卦中干支旺衰","slug":"离卦中干支旺衰","date":"2013-11-06T08:53:30.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/11/06/离卦中干支旺衰/","link":"","permalink":"http://hi2048.github.io/2013/11/06/离卦中干支旺衰/","excerpt":"","text":"离卦 丁、午 ‘ 己巳 世 ‘’ 己未 ‘ 己酉 ‘ 己亥 应 ‘’ 己丑 ‘ 己卯 离卦是八纯卦之一，位居南方，夏五月、丁、午年、月、日、时，属火，旺于夏、丁、巳、午、纳音火。火旺需泄，泄则生出土（己土），丁、午火生土。所以离卦納干表现为己，在数字为九。 己巳09、69…… 己亥39、99…… 己酉49、109….. 己卯19、79…… 己丑29、89…… 己未59、119……","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"坎卦中干支旺衰","slug":"坎卦中干支旺衰","date":"2013-11-04T09:08:33.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/11/04/坎卦中干支旺衰/","link":"","permalink":"http://hi2048.github.io/2013/11/04/坎卦中干支旺衰/","excerpt":"","text":"坎卦 癸、子 ‘’ 戊子 世 ‘ 戊戌 ‘’ 戊申 ‘’ 戊午 应 ‘ 戊辰 ‘’ 戊寅坎卦是八纯卦之一，水旺，位居十一月，癸、子年、月、日、时，属水，旺于冬、癸、壬、亥、子纳音水，水旺需耗（克)。水旺则需土（戊）蓄。所以坎卦納干表现为戊,在数字为一。戊申41、101…… 戊寅11、71……戊子21、81….. 戊午51、111……戊辰01、61…… 戊戌31、91……","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"鼻炎不用愁","slug":"鼻炎不用愁","date":"2013-11-02T10:45:45.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/11/02/鼻炎不用愁/","link":"","permalink":"http://hi2048.github.io/2013/11/02/鼻炎不用愁/","excerpt":"","text":"鼻炎的病理及治疗： 1、鼻流清涕，易喷嚏，易鼻塞。病在膀胱经、肾经，治宜祛风寒，清脾湿，补肺益肾。用刮痧法先刮后背，循督脉、膀胱经，刮到皮肤温热；秋冬遇风喘咳者，用艾条慢灸背俞，沿风门、肺俞、脾俞、肾俞，灸至穴位痒痛；怕冷怕风易过敏者，用取嚏法，喝姜枣汤助力，取到啑尽方休。 2、鼻流浊涕，花无香，饭无味。病在胃经、胆经，治宜清肝火，化痰浊，通肠利胆。体内多有湿寒，若胃寒肚冷，可以服附子理中丸以温里；若痰多不渴，宜多用参苓白术丸以祛湿，同时要少饮水；取啑不出者，可服补中益气丸以增心肺之力；若皮肤干燥，喷嚏无力者，可服人参生脉饮，以强心润肤。 &nbsp; &nbsp;","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hi2048.github.io/categories/杂谈/"}],"tags":[]},{"title":"巽卦中干支旺衰","slug":"巽卦中干支旺衰","date":"2013-10-27T10:17:25.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/10/27/巽卦中干支旺衰/","link":"","permalink":"http://hi2048.github.io/2013/10/27/巽卦中干支旺衰/","excerpt":"","text":"巽卦 丙、辰、巳 ‘ 辛卯 世 ‘ 辛巳 ‘’ 辛未 ‘ 辛酉 应 ‘ 辛亥 ‘’ 辛丑 巽卦是八纯卦之一，位居东南方，春夏之交辰、巳年、月、日、时，属木，旺于春末夏初、丙、巳、辰、纳音木。木旺需耗，耗则冲出金（辛金），辰酉合金助旺。所以巽卦納干表现为辛，在数字为四。 辛巳14、74…… 辛亥44、104…… 辛酉54、114….. 辛卯34、94…… 辛丑43、104…… 辛未04、64……","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"震卦中干支旺衰","slug":"震卦中干支旺衰","date":"2013-10-25T09:04:31.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/10/25/震卦中干支旺衰/","link":"","permalink":"http://hi2048.github.io/2013/10/25/震卦中干支旺衰/","excerpt":"","text":"震卦 乙、卯 ‘’ 庚戌 世 ‘’ 庚申 ‘ 庚午 ‘’ 庚辰 应 ‘’ 庚寅 ‘ 庚子震卦是八纯卦之一，木旺，位居二月，乙、卯年、月、日、时，属木，旺于春、乙、卯、纳音木，木旺需耗（克)。木旺则冲出金（庚），庚在震、乙、卯胎，庚金与乙木合为金，助金旺。所以震卦納干表现为庚,在数字为三。庚申53、113…… 庚寅23、83……庚子33、93….. 庚午03、63……庚辰13、73…… 庚戌43、103……","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"坤卦中干支旺衰","slug":"坤卦中干支旺衰","date":"2013-10-23T09:22:04.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/10/23/坤卦中干支旺衰/","link":"","permalink":"http://hi2048.github.io/2013/10/23/坤卦中干支旺衰/","excerpt":"","text":"坤卦 庚、申、戊、未 ‘’ 癸酉 世 ‘’ 癸亥 ‘’ 癸丑 ‘’ 乙卯 应 ‘’ 乙巳 ‘’ 乙未 坤卦是八纯卦之一，阴旺至极，位居辰、戌、丑、未月，未、申年、月、日、时，属土，旺于四季、戊、己、丑、未、辰、戌、纳音土，土旺需耗。土盛则蓄水（癸、子水），耗则被木克（乙、卯），癸、子水旺于申子辰三合水局，卯木生癸水。所以坤卦納干表现为癸、乙，在数字为0、2。 癸巳30、90…… 癸亥60、120…… 乙巳42、102….. 乙亥12、72…… 癸酉0、10、70….. 癸卯40、100…… 乙酉22、82….. 乙卯52、112…… 癸丑50、110…… 癸未20、80…… 乙丑02、62…… 乙未32、92……","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"全排列算法","slug":"全排列算法","date":"2013-10-20T11:50:26.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/10/20/全排列算法/","link":"","permalink":"http://hi2048.github.io/2013/10/20/全排列算法/","excerpt":"","text":"全排列中一种简单的算法是采用递归的思想，化繁为简。 对于字符数组cs，主要过程如下， 1. 交换cs[0]与递归开始索引sIndex，剩余的n - 1个字符，递归进行 2. 交换cs[1]与递归开始索引sIndex，剩余的n - 1个字符，递归进行 … 直到cs[n]，完成全排列。 Java具体实现代码如下， import java.util.*; public class STest { public static void fperm(char[] cs, int sIndex, int eIndex){ if(sIndex == eIndex) { for(int i = 0; i &lt; eIndex; i++) System.out.print(cs[i]); System.out.println(); } for(int i = sIndex; i &lt; eIndex; i++){ char temp = cs[sIndex]; cs[sIndex] = cs[i]; cs[i] = temp; fperm(cs, sIndex + 1, eIndex); cs[i] = cs[sIndex]; cs[sIndex] = temp; } } public static void main(String[] args){ char[] cs = {'a', 'b', 'c', 'd'}; fperm(cs, 0, cs.length); } } 程序运行结果如下， abcd abdc acbd acdb adcb adbc bacd badc bcad bcda bdca bdac cbad cbda cabd cadb cdab cdba dbca dbac dcba dcab dacb dabc","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://hi2048.github.io/tags/JAVA/"}]},{"title":"乾卦中干支旺衰","slug":"乾卦中干支旺衰","date":"2013-10-20T10:58:53.000Z","updated":"2019-09-05T09:00:17.271Z","comments":true,"path":"2013/10/20/乾卦中干支旺衰/","link":"","permalink":"http://hi2048.github.io/2013/10/20/乾卦中干支旺衰/","excerpt":"","text":"乾卦 壬、亥、戌 ‘ 壬戌 世 ‘ 壬申 ‘ 壬午 ‘ 甲辰 应 ‘ 甲寅 ‘ 甲子 乾卦是八纯卦之一，阳旺至极，位居九、十月之交，戌、亥、年、月、日、时，属金，旺于秋、庚、申、辛、酉、纳音金，金旺需泄（生）、耗（冲)。金盛则生水（壬水、亥），耗则冲出木（甲、寅），壬、亥水在乾、戌、亥旺，甲、寅木在亥水为长生。所以乾卦納干表现为壬、甲，在数字为五、六。 壬申06、66…… 壬寅36、96…… 甲申25、85….. 甲寅55、115…… 壬子46、106….. 壬午16、76…… 甲子05、65….. 甲午35、95…… 壬辰26、86…… 壬戌56、116…… 甲辰45、105…… 甲戌15、75……","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"三合中的数字(二）","slug":"三合中的数字(二）","date":"2013-10-18T07:28:26.000Z","updated":"2019-09-05T09:00:05.234Z","comments":true,"path":"2013/10/18/三合中的数字(二）/","link":"","permalink":"http://hi2048.github.io/2013/10/18/三合中的数字(二）/","excerpt":"","text":"乙巳 42、102…… 丁巳 57、117…… 己巳 09、69…… 辛巳 14、74…… 癸巳 30、90…… 乙酉 22、82…… 丁酉 37、97…… 己酉 49、109…… 辛酉 54、104…… 癸酉 10、70…… 乙丑 02、62…… 丁丑 17、77….. 己丑 29、89…… 辛丑 34、94…… 癸丑 50、110…… &nbsp; 乙亥 12、72…… 丁亥 27、97…… 己亥 39、99…… 辛亥 44、104…… 癸亥 60、120….. 乙卯 52、112…… 丁卯 07、67….. 己卯 19、79…… 辛卯 24、84…… 癸卯 40、100…… 乙未 32、92…… 丁未 47、107….. 己未 59、109…… 辛未 04、64…… 癸未 20、80……","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"三合中的数字（一）","slug":"三合中的数字（一）","date":"2013-10-16T11:02:20.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/10/16/三合中的数字（一）/","link":"","permalink":"http://hi2048.github.io/2013/10/16/三合中的数字（一）/","excerpt":"","text":"甲申25 、85…… 丙申38、98…… 戊申41 、101…… 庚申53、113…… 壬申06、66…… 甲子05 、 65…… 丙子18 、78…… 戊子21 、81 …… 庚子43、103…… 壬子46、106…… 甲辰 45 、105…… 丙辰58 、118…… 戊辰01、61…… 庚辰13、73…… 壬辰26、86…… &nbsp; 甲寅55 、115…… 丙寅08、68…… 戊寅11、71…… 庚寅23、83…… 壬寅46、106…… 甲午35 、95…… 丙午48 、108…… 戊午51、111…… 庚午03、63…… 壬午16、76…… 甲戌 15 、75…… 丙戌28、88…… 戊戌31、91…… 庚戌43、103…… 壬戌56、116…… &nbsp; &nbsp;","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"晕车不用愁","slug":"晕车不用愁","date":"2013-10-15T09:18:35.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/10/15/晕车不用愁/","link":"","permalink":"http://hi2048.github.io/2013/10/15/晕车不用愁/","excerpt":"","text":"晕车的原因 1、心下有水气，叫做“水气凌心”，会眩晕恶心; 2、胃肠有积食，叫做“宿食阻膈”，会恶心呕吐； 3、气不下行而上逆，叫做“浊气熏蒸”，也会令你头晕欲吐。 治疗 1、先按摩膀胱经的昆仑穴，再按摩心包经这个穴，最后按任脉的膻中穴。以消除心脏外部心包积液，解除心脏所受的压力，消除人体不适感; 2、推腹法。以通腹除胀，消除宿食阻膈; 3、揉肝经的太冲穴、胆经的阳陵穴,消除肝胆的浊气;揉胃经的足三里穴、脾经的公孙穴,消除肠胃的浊气。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hi2048.github.io/categories/杂谈/"}],"tags":[]},{"title":"八卦里的数字","slug":"八卦里的数字","date":"2013-10-13T07:20:18.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/10/13/八卦里的数字/","link":"","permalink":"http://hi2048.github.io/2013/10/13/八卦里的数字/","excerpt":"","text":"乾：5、15、25、35、45、55…… 6、16、26、36、46、56…… 坎：1、11、21、31、41、51…… 艮：8、18、28、38、48、58…… 震：3、13、23、33、43、53…… 巽：4、14、24、34、44、54…… 离：9、19、29、39、49、59…… 坤：2、12、22、32、42、52…… 0、 10、20、30、40、50…… 兑：7、17、27、37、47、57……","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"模式匹配-BF算法","slug":"模式匹配-BF算法","date":"2013-10-13T07:15:21.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/10/13/模式匹配-BF算法/","link":"","permalink":"http://hi2048.github.io/2013/10/13/模式匹配-BF算法/","excerpt":"","text":"BF算法是普通的模式匹配算法，效率较为低下，但是由于其思想与实现都较为简单，因此有一定的参考价值。 假设源串为S，目标串为T 算法过程： 1. 比较s[0]与t[0]是否相等，如果相等，则依次比较s[1]与t[1]，s[2]与t[2]直到结束，如果相等则匹配成功，并返回匹配成功的开始字符串索引，否则进入2 2. 比较s[1]与t[0]是否相等，与上相同 3. 直到s串结束，如果还未匹配成功，则匹配失败，返回-1。 程序实现如下： int bf(string s, string t){ int s_index = 0, t_index = 0; while(s_index &lt; s.size()){ while(t_index &lt; t.size()){ if(s[s_index + t_index] != t[t_index]) break; else t_index++; if(t_index == t.size()) return s_index; } s_index++; t_index = 0; } return -1; }","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hi2048.github.io/tags/算法/"},{"name":"C++","slug":"C","permalink":"http://hi2048.github.io/tags/C/"}]},{"title":"10000阶乘的未尾有几个0？","slug":"10000阶乘的未尾有几个0？","date":"2013-10-13T06:16:58.000Z","updated":"2019-09-05T08:50:51.314Z","comments":true,"path":"2013/10/13/10000阶乘的未尾有几个0？/","link":"","permalink":"http://hi2048.github.io/2013/10/13/10000阶乘的未尾有几个0？/","excerpt":"","text":"问题： 10000的阶乘未尾有几个0？ 1. 10是由2 * 5，其中因数2的数量远大于5，因此计算出5的个数就可以知道10的个数 2. 100是由2 2 25，其中25又是由5 * 5，因此25的个数与5的个数相加为100阶乘未尾0的个数 3. 依次可得， 10000的阶乘未尾0的个数为： 10000/5 + 10000/(5 5) + 10000/(5 5 5) + 10000/(5 5 5 5) + 10000/(5 5 5 5 5)= 2000 + 400 + 80 + 16 + 3结果最终为：2499","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hi2048.github.io/tags/算法/"}]},{"title":"预测中的原神、忌神、仇神","slug":"预测中的原神、忌神、仇神","date":"2013-10-12T08:24:05.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/10/12/预测中的原神、忌神、仇神/","link":"","permalink":"http://hi2048.github.io/2013/10/12/预测中的原神、忌神、仇神/","excerpt":"","text":"原神：生用神之爻。 忌神：克用神之爻。 仇神：克制原神反而生助忌神之爻。 用神：预测事物之爻。 如：乾卦用神为戌，午火生戌土为原神，寅木克戌土为忌神，亥水克午火原神，而生忌神寅木，亥水即为仇神。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"善待自己的身体","slug":"善待自己的身体","date":"2013-10-09T09:43:08.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/10/09/善待自己的身体/","link":"","permalink":"http://hi2048.github.io/2013/10/09/善待自己的身体/","excerpt":"","text":"随着改革开放，市场经济的冲击，社会的竞争越来越激烈，人们生活节奏的加快，从牙牙学语的小孩到拄着拐杖的老人无不感到身心疲惫。就拿小孩来说，当他们刚学会说话的时候，大人们就忙于教他们学这学那，不管年龄，还嫌小孩愚笨，何不顺应自然成长加以合理引导；当小孩进入少年时期，大人们就忙于教他们边学功课，边学其他，如音乐、书画、太极拳、外加补课等等，像是要他们把所有的东西都学完，而忘记他们正是长身体的时候，何不在他们精力充沛的情况下，培养和发展孩子的兴趣、爱好；还有现在的年轻人，动不动就熬夜，不按时吃饭，休息，有的为了挣多多的钱，不惜加班加点，全然把老祖宗的“日出而作，日落而息。”的传统置之不理；还有老人们也整天忙这忙那，全然忘记自己的身体已进入修养期；还有的年轻人，只图一时的美观，不管身体能不能接受，是热还是冷，只要好看就穿。等等一些现象，无不透支着自己身体的能量，消耗自身的气血，损伤元气，伤害身体，甚至使原本消耗的身体得不到恢复，继续消耗，渐渐的涌出了一批“过劳模”大军，使一些原本老年人得的慢性病。如颈椎病、冠心病、脑溢血、脑梗、高血压等病变进入了年轻人行列。 由此可见，大部分人们不太关心自己的身体，一直搞内耗，对自己不好，可我们想想：是谁在默默的支持着我们的学习、工作、娱乐等等无论你给它吃什么、喝什么、它都会接受。不管吃、喝的好坏，他都会把它消化、吸收、转化成能量，为你工作、学习、娱乐以及各种活动提供所需能量。其实我们的身体是很辛苦的，是我们的切身朋友，一定要善待自己的身体。 我们要活的有声有色，要有财富、荣耀、车子、房子等自己想要的一切，首先要善待自己的身体，养成良好的养生习惯，达到生活、学习、工作、娱乐个不误，走出一个适合自己良好发展路子来。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hi2048.github.io/categories/杂谈/"}],"tags":[]},{"title":"原神旺象的几种情况","slug":"原神旺象的几种情况","date":"2013-10-08T09:19:23.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/10/08/原神旺象的几种情况/","link":"","permalink":"http://hi2048.github.io/2013/10/08/原神旺象的几种情况/","excerpt":"","text":"1、原神临长生帝旺于日建。 2、原神动而化进神。 3、原神临月、日建。 4、原神临月、日建、又临动爻。 5、原神动，忌神也动。 6、原神临月、日建动而临空化空。 临空化空并非无用，因有动不为空，填空之日不为空，出空之间不为空。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"做人与做事","slug":"做人与做事","date":"2013-10-03T10:05:32.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/10/03/做人与做事/","link":"","permalink":"http://hi2048.github.io/2013/10/03/做人与做事/","excerpt":"","text":"做人与做事是相互联系的整体。先有做人的理念，树立正确的人生观，再做事就有了基础。人做好了，事也相应就做好了。而做人的价值、空间、质量就决定着做事的价值、空间、质量；但人的价值，只有在做事的过程中才能体现；人的潜能，只有在做事中才能得到开发；人的能力，只有在做事中才能得到最大的发挥；人的成就，只有在做事中才能得以实现；人的梦想，只有在做事中才能完成；人的威望，只有在做事的过程中才能树立。没有做事，做人就没有根基，所以二者是相互依存的整体。只有把二者有机的结合起来，才能使人的品德与才华得到升华，在人生的旅途中处处顺心，紧要关头化险为夷，社交中事事如意，商战中左右逢源，公司中受到上司的重视，同事的尊重，下级的拥戴。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hi2048.github.io/categories/杂谈/"}],"tags":[]},{"title":"一爻动的学问","slug":"一爻动的学问","date":"2013-10-02T09:38:27.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/10/02/一爻动的学问/","link":"","permalink":"http://hi2048.github.io/2013/10/02/一爻动的学问/","excerpt":"","text":"1、动爻是区别体卦、用卦的主要标志。动爻在那个卦，那个卦就为用卦，动爻在上卦，上卦则为用卦，动爻在下卦，下卦则为用卦。体卦为静、为主，用卦为动、为客。 2、动卦是变卦的前提和基础。有动就有变，有变就有新卦生成。 3、动卦是断卦的关键。分析动卦（用卦）与体卦的关系、旺、衰、生、克、空、绝、阴、阳等，来判断预测事物的情况。 4、这里的动爻是指一爻动。也有多爻动或六爻全动或全静不动的情况，这个以后再说吧。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"浅谈面试","slug":"浅谈面试","date":"2013-10-01T04:13:21.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/10/01/浅谈面试/","link":"","permalink":"http://hi2048.github.io/2013/10/01/浅谈面试/","excerpt":"","text":"找一个安静的地方，泡上一杯咖啡，坐下，闭上眼睛，想一个问题，我想要一个什么样的生活？ 然后再去找工作。 最近面试了很多公司，也被很多公司面试过。有外企，国企，创业型企业，大型企业，机关单位，主要面试的都是技术岗位，大大小小也有接近20多家公司，有发offer的，也有被拒的，感慨颇多。 总结了一下，一个良好的心态可以为你的成功增添更多的筹码。 1. 冷静。冷静的大脑会给你带来意想不到的惊喜。 2. 勇敢。屡败屡战，明知不可为而为之。 3. 思考。做一个独立思考者，而不要成为一个复读机。 我们不是天才，我们很普通，但是我们很努力，因为我们也有梦想。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hi2048.github.io/categories/杂谈/"}],"tags":[]},{"title":"真正的朋友","slug":"真正的朋友","date":"2013-09-29T08:35:34.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/09/29/真正的朋友/","link":"","permalink":"http://hi2048.github.io/2013/09/29/真正的朋友/","excerpt":"","text":"朋友是我们日常生活中常谈起的事情，人人都有朋友，但真正的朋友呢？是只求奉献，不求索取，而不是做一点奉献或好事，就斤斤计较，逢人就讲，挂在嘴边，生怕别人不知道；是在你人气最旺的时候，默默的祝福你，远远地望着你，时时的牵挂着你，而不是追随于你，鞍前马后，围着你转；在你人气消低或特别困难的时候，会义无反顾的帮助你，支持你，鼓励你，帮助你走出困境，而不是视若无睹、幸灾乐祸，或与你保持距离、远离你；当你做错了事，是理解你，对你动之以情，晓之以理，诚心的帮你改正，而不是责怪你，鄙视你，作弄你。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hi2048.github.io/categories/杂谈/"}],"tags":[]},{"title":"爻的六合","slug":"爻的六合","date":"2013-09-28T12:34:50.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/09/28/爻的六合/","link":"","permalink":"http://hi2048.github.io/2013/09/28/爻的六合/","excerpt":"","text":"世间万物，都有分有合，合久必分，分久必合，合中有克、有生；有先分后合，先合后分；有相合为好，有相合为坏，这都是自然界发展的必然规律。 爻的六合：子丑合、寅亥合、卯戌合、辰酉合、巳申合、午未合。爻与爻合，爻与日、月合，有贪合忘生，有贪合忘克，合中有吉、有凶。 合必是一一相合。如：一子合一丑；不能二合一或一和二。如：二子合一丑或二丑合一子，这争合为不牢之合。 二合的几种情况： 1、日、月与爻合。日、月与静爻、动爻合，是休囚之爻得旺相。 2、爻与爻合。爻动化合，为化生扶；**动爻与动爻相合，因动而逢合，合而受绊，难于行动。** 3、卦逢六合。内外六爻自行相合。 4、卦变六合。变卦内外六爻自行相合。 5、六合卦变六合卦。是先合而后又合。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"五行逐月节气生旺歌","slug":"五行逐月节气生旺歌","date":"2013-09-27T04:38:04.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/09/27/五行逐月节气生旺歌/","link":"","permalink":"http://hi2048.github.io/2013/09/27/五行逐月节气生旺歌/","excerpt":"","text":"子月上旬十日壬，中旬下旬方论癸。 丑月九日癸之余，却除三辛皆属己。 新春戊丙皆七朝，十六甲木方是真， 卯月阳木就初旬，中下两旬阴木是。 三月九朝万事乙，三日癸库余属戊。 初夏九日论庚金，十六丙火五戊持。 五月阳火属上旬，丁火十日九日己。 未月九日丁火明，三朝是乙余是己。 孟秋己七戊三朝，三壬十七庚金备。 酉月还有十日壬，二十辛金属旺地。 戌月九日辛金胜，三丁十八戊土居。 亥月七戊五日甲，余皆壬旺君须记。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"二叉树求取后序遍历","slug":"二叉树求取后序遍历","date":"2013-09-25T08:32:46.000Z","updated":"2019-09-05T09:05:45.210Z","comments":true,"path":"2013/09/25/二叉树求取后序遍历/","link":"","permalink":"http://hi2048.github.io/2013/09/25/二叉树求取后序遍历/","excerpt":"","text":"如何根据二叉树的前序遍历与中序遍历，求出后序遍历？ 二叉树的前序遍历：根 左 右 二叉树的中序遍历：左 根 右 可以从前序中得知二叉树的根所在，从中序遍历得知根的左右子树，最后使用递归求得二叉树，从而求出后序遍历的结果。 例如已知， 前序遍历为：a b d e c f g h i 中序遍历为：e d b c a h g i f 因而可以求得此二叉树如下， 从而后序遍历为：e d c b h i g f a 程序实现如下， #include&lt;stdio.h&gt; #include&lt;iostream&gt; using namespace std; int findRootIndex(char c, char *in, int in_start, int in_end){ for(int i = in_start; i &lt;= in_end; i++) if(c == in[i]) return i; return -1; } void calPostorderTraversal(char *p, int p_start, int p_end, char *in, int in_start, int in_end){ char c = p[p_start]; int n = findRootIndex(p[p_start], in, in_start, in_end); if(in_start &gt; in_end) return; if(in_end == in_start) { cout&lt;&lt;c; return; } calPostorderTraversal(p, p_start + 1, p_start + n - in_start, in, in_start, n - 1); calPostorderTraversal(p, p_start + n + 1 - in_start, p_end, in, n + 1, in_end); cout&lt;&lt;c; } int main(){ char preorder[] = &quot;abdecfghi&quot;; char inorder[] = &quot;edbcahgif&quot;; int len = sizeof(preorder); calPostorderTraversal(preorder, 0, len - 1, inorder, 0, len - 1); return 0; }","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hi2048.github.io/tags/算法/"},{"name":"C++","slug":"C","permalink":"http://hi2048.github.io/tags/C/"}]},{"title":"十二地支中所藏干歌诀","slug":"十二地支中所藏干歌诀","date":"2013-09-24T08:39:22.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/09/24/十二地支中所藏干歌诀/","link":"","permalink":"http://hi2048.github.io/2013/09/24/十二地支中所藏干歌诀/","excerpt":"","text":"子宫单癸水， 丑辛己癸逢， 寅宫甲丙戊， 卯中独乙木， 辰藏癸戊乙， 巳丙戊庚同， 午宫丁己土， 未内乙己丁， 申宫庚壬水， 酉内独辛金， 戌宫辛丁戊， 亥宫壬甲宗。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"十二地支的关系","slug":"十二地支的关系","date":"2013-09-23T11:53:46.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/09/23/十二地支的关系/","link":"","permalink":"http://hi2048.github.io/2013/09/23/十二地支的关系/","excerpt":"","text":"十二地支：子、丑、寅、卯、辰、巳、午、未、申、酉、戌、亥。 五行：子亥属水、寅卯属木、巳午属火、申酉属金、丑未辰戌属土。 阴阳：子寅辰午申戌属阳、丑卯巳未酉亥属阴。 二合：子丑、寅亥、卯戌、辰酉、巳申、午未。 二合属性：子丑属土、寅亥属木、卯戌属火、辰酉属金、巳申属水、午未属土。 三合：申子辰、寅午戌、亥卯未、巳酉丑。 三合属性：申子辰属水、寅午戌属火、亥卯未属木、巳酉丑属金。 相刑：子刑卯、卯刑子、丑刑戌、寅刑巳、辰刑辰、巳刑申、午刑午、未刑丑、申刑寅、酉刑酉、戌刑未、亥刑亥。 相冲：子午冲、丑未冲、寅申冲、卯酉冲、辰戌冲巳亥冲。 支属四时：寅卯辰春旺、巳午未夏旺、申酉戌秋旺、亥子丑冬旺。 支属三季：寅申巳亥为四孟、子午卯酉为四仲、辰戌丑未为四季。 支属卦位：子属坎、丑寅属艮、卯属震、辰巳属巽、午属离、未申属坤、酉属兑、戌亥属乾。四正卦属单支，四维卦属两支。 &nbsp; &nbsp; &nbsp;","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"十天干关系","slug":"十天干关系","date":"2013-09-22T04:46:57.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/09/22/十天干关系/","link":"","permalink":"http://hi2048.github.io/2013/09/22/十天干关系/","excerpt":"","text":"十干：甲、乙、丙、丁、戊、己、庚、辛、壬、癸。 五行：甲阳木、乙阴木、丙阳火、丁阴火、戊阳土、己阴土、庚阳金、辛阴金、壬阳水、癸阴水。 相合：甲己合、乙庚合、丙辛合、丁壬合、戊癸合。 合化：甲己化土、乙庚化金、丙辛化水、丁壬化木、戊癸化火。 相生：甲木生丁火、乙木生丙火、丙火生己土、丁火生戊土、戊土生酉金、己土生庚金、庚金生癸水、辛金生壬水、壬水生乙木、癸水生甲木。 相克：甲木克戊土、乙木克己土、丙火克庚金、丁火克辛金、戊土克壬水、己土克癸水、庚金克甲木、辛金克乙木、壬水克丙火、癸水克丁火。 相食：甲食丙禄、乙食丁禄、丙食戊禄、丁食己禄、戊食庚禄、己食辛禄、庚食壬禄、辛食癸禄、壬食甲禄、癸食乙禄。 支刃：丙戊以午为羊刃、子为飞刃，丁己以巳为羊刃、亥为飞刃，庚以酉为羊刃、卯为飞刃，辛以申为羊刃、寅为飞刃，壬以子为羊刃、午为飞刃，癸以亥为羊刃、巳为飞刃，甲以卯为羊刃、酉为飞刃，乙以寅为羊刃、申为飞刃。（禄前一位为羊刃，禄后五位为飞刃。） 四时：甲乙春旺、丙丁夏旺、庚辛秋旺、壬癸冬旺、戊己四季旺。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"JavaScript中浅复制与深复制","slug":"JavaScript中浅复制与深复制","date":"2013-09-20T10:51:06.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/09/20/JavaScript中浅复制与深复制/","link":"","permalink":"http://hi2048.github.io/2013/09/20/JavaScript中浅复制与深复制/","excerpt":"","text":"在进行面向对象的编程中，一个常见的问题就是对象之间的赋值，由于JavaScript采用的是引用的传递，因而当需要建立一个新的对象时，就需要使用到对象的复制。 常用的对象复制包含了浅复制与深复制。 所谓的浅复制，指的是仅仅复制对象中的基本类型，而深复制，则指的是利用递归的方法，对对象进行全面的复制，包含对象中的对象。 浅复制实现代码， Object.prototype.clone1 = function(){ var o = new Object(); for(var e in this) o[e] = this[e]; return o; } 深复制实现代码， Object.prototype.clone2 = function(){ var o = new Object(); for(var e in this){ if(typeof this[e] != &#039;object&#039;){ o[e] = this[e]; } else{ o[e] = this[e].clone2(); } } return o; } 测试1， var obj1 = { &#039;name&#039; : &#039;obj1&#039;, &#039;obj_inner&#039; : {&#039;name&#039; : &#039;obj11&#039;} } var obj2 = obj1; alert(&#039;obj1 name: &#039; + obj1.name + &#039;, &#039; + &#039;obj1 obj_inner name: &#039; + obj1.obj_inner.name); alert(&#039;obj2 name: &#039; + obj2.name + &#039;, &#039; + &#039;obj2 obj_inner name: &#039; + obj2.obj_inner.name); obj2.name = &#039;obj2&#039;; obj2.obj_inner.name = &#039;obj22&#039;; alert(&#039;obj1 name: &#039; + obj1.name + &#039;, &#039; + &#039;obj1 obj_inner name: &#039; + obj1.obj_inner.name); alert(&#039;obj2 name: &#039; + obj2.name + &#039;, &#039; + &#039;obj2 obj_inner name: &#039; + obj2.obj_inner.name); 运行程序结果为， obj1 name: obj1, obj1 obj_inner name: obj11 obj2 name: obj1, obj2 obj_inner name: obj11 obj1 name: obj2, obj1 obj_inner name: obj22 obj2 name: obj2, obj2 obj_inner name: obj22 测试2， var obj1 = { &#039;name&#039; : &#039;obj1&#039;, &#039;obj_inner&#039; : {&#039;name&#039; : &#039;obj11&#039;} } var obj3 = obj1.clone1(); alert(&#039;obj1 name: &#039; + obj1.name + &#039;, &#039; + &#039;obj1 obj_inner name: &#039; + obj1.obj_inner.name); alert(&#039;obj3 name: &#039; + obj3.name + &#039;, &#039; + &#039;obj3 obj_inner name: &#039; + obj3.obj_inner.name); obj3.name = &#039;obj3&#039;; obj3.obj_inner.name = &#039;obj33&#039;; alert(&#039;obj1 name: &#039; + obj1.name + &#039;, &#039; + &#039;obj1 obj_inner name: &#039; + obj1.obj_inner.name); alert(&#039;obj3 name: &#039; + obj3.name + &#039;, &#039; + &#039;obj3 obj_inner name: &#039; + obj3.obj_inner.name); 运行程序结果为， obj1 name: obj1, obj1 obj_inner name: obj11 obj3 name: obj1, obj3 obj_inner name: obj11 obj1 name: obj1, obj1 obj_inner name: obj33 obj3 name: obj3, obj3 obj_inner name: obj33 测试3， var obj1 = { &#039;name&#039; : &#039;obj1&#039;, &#039;obj_inner&#039; : {&#039;name&#039; : &#039;obj11&#039;} } var obj4 = obj1.clone2(); alert(&#039;obj1 name: &#039; + obj1.name + &#039;, &#039; + &#039;obj1 obj_inner name: &#039; + obj1.obj_inner.name); alert(&#039;obj4 name: &#039; + obj4.name + &#039;, &#039; + &#039;obj4 obj_inner name: &#039; + obj4.obj_inner.name); obj4.name = &#039;obj4&#039;; obj4.obj_inner.name = &#039;obj44&#039;; alert(&#039;obj1 name: &#039; + obj1.name + &#039;, &#039; + &#039;obj1 obj_inner name: &#039; + obj1.obj_inner.name); alert(&#039;obj4 name: &#039; + obj4.name + &#039;, &#039; + &#039;obj4 obj_inner name: &#039; + obj4.obj_inner.name); 运行程序结果为， obj1 name: obj1, obj1 obj_inner name: obj11 obj4 name: obj1, obj4 obj_inner name: obj11 obj1 name: obj1, obj1 obj_inner name: obj11 obj4 name: obj4, obj4 obj_inner name: obj44","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"}]},{"title":"JavaScript闭包","slug":"JavaScript闭包","date":"2013-09-20T08:44:18.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/09/20/JavaScript闭包/","link":"","permalink":"http://hi2048.github.io/2013/09/20/JavaScript闭包/","excerpt":"","text":"JavaScript中的闭包是一个很有用的概念，可以实现面向对象编程中封装的特性。 闭包的官方解释，指的是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。简单的讲，通过闭包，可以实现在函数外部访问函数内部的局部变量。闭包实例如下， function f(){ var n = 1; return function(){ return n; } } var f1 = f(); &nbsp; 闭包练习， 1\\. 下面程序输出结果是， function f(){ var n = 1; f1 = function(){ n++; } return function(){ alert(n); } } var f2 = f(); f2(); f1(); f2(); 程序运行结果为， 1 2 2\\. 下面程序输出结果是， var s = \"outer\"; var obj = { s : \"inner\", func : function(){ var that = this; return function(){ return that.s; }; } }; alert(obj.func()()); 程序运行结果为， inner","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"}]},{"title":"五行关系","slug":"五行关系","date":"2013-09-20T07:59:00.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/09/20/五行关系/","link":"","permalink":"http://hi2048.github.io/2013/09/20/五行关系/","excerpt":"","text":"五行：水、火、木、金、土。 相生：金生水、水生木、木生火、火生土、土生金。 相克：金克木、木克土、土克水、水克火、火克金。 比和：金见金、木见木、水见水、火见火、土见土。 旺相：当生者旺，所生者相，生我者休，克我者囚，我克者死。 春木旺、火相、水休、金囚、土死。 夏火旺、土相、木休、水囚、金死。 秋金旺、水相、土休、火囚、木死。 冬水旺、木相、金休、土囚、火死。 &nbsp;","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"JavaScript去掉数组中的重复元素","slug":"JavaScript去掉数组中的重复元素","date":"2013-09-19T13:13:37.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/09/19/JavaScript去掉数组中的重复元素/","link":"","permalink":"http://hi2048.github.io/2013/09/19/JavaScript去掉数组中的重复元素/","excerpt":"","text":"在使用JavaScript的时候，经常需要去掉数组中的一些重复元素，从而使得数组中的元素具有唯一性。 大体上来说，有三种实现的思路， 1. 常规方法 var unique1 = function(arr){ var ret = []; if(arr.length &lt; 2) return arr; var isRepeat = function(arr, elt){ for(var i = 0, len = arr.length; i &lt; len; i++) if(arr[i] == elt) return true; return false; } for(var i = 0, len = arr.length; i &lt; len; i++) if(!isRepeat(ret, arr[i])) ret.push(arr[i]); return ret; } 2\\. 利用对象 var unique2 = function(arr){ var ret = [], o = {}; if(arr.length &lt; 2) return arr; for(var i = 0, len = arr.length; i &lt; len; i++) if(!o[arr[i]]){ o[arr[i]] = 1; ret.push(arr[i]); } return ret; } 3\\. 利用正则表达式 var unique3 = function(arr){ return (arr.reverse().join(&#039; &#039;).match(/(\\b[^ ]+\\b)(?!.* \\1( |$))/ig).reverse()); } 测试数据， var arr1 = [&#039;1&#039;]; var arr2 = [&#039;1&#039;, &#039;123&#039;, &#039;123&#039;, &#039;231&#039;, &#039;2&#039;, &#039;3&#039;]; 运行结果， 数据1：1 数据2：1，123，231，2，3","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"}]},{"title":"十干在十二宫长生表","slug":"十干在十二宫长生表","date":"2013-09-19T08:55:59.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/09/19/十干在十二宫长生表/","link":"","permalink":"http://hi2048.github.io/2013/09/19/十干在十二宫长生表/","excerpt":"","text":"宫 长生 沐浴 冠带 临官 帝旺 衰 病 死 墓 绝 胎 养 十干 甲 亥 子 丑 寅 卯 辰 巳 午 未 申 酉 戌 丙（戊） 寅 卯 辰 巳 午 未 申 酉 戌 亥 子 丑 庚 巳 午 未 申 酉 戌 亥 子 丑 寅 卯 辰 壬 申 酉 戌 亥 子 丑 寅 卯 辰 巳 午 未 乙 午 巳 辰 卯 寅 丑 子 亥 戌 酉 申 未 丁（己） 酉 申 未 午 巳 辰 卯 寅 丑 子 亥 戌 辛 子 亥 戌 酉 申 未 午 巳 辰 卯 寅 丑 癸 卯 寅 丑 子 亥 戌 酉 申 未 午 巳 辰","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"JavaScript中事件冒泡","slug":"JavaScript中事件冒泡","date":"2013-09-19T08:02:37.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/09/19/JavaScript中事件冒泡/","link":"","permalink":"http://hi2048.github.io/2013/09/19/JavaScript中事件冒泡/","excerpt":"","text":"所谓的事件冒泡，主要指的是从里向外的一种事件传播机制。 例如以下代码， HTML结构为， &lt;div id=&quot;t1&quot;&gt; &lt;div id=&quot;t11&quot;&gt;我是里层的t11。&lt;/div&gt; &lt;div id=&quot;t12&quot;&gt;我是里层的t12。&lt;/div&gt; &lt;/div&gt; JS代码为， window.onload = function(){ var t1 = document.getElementById(\"t1\"); var t11 = document.getElementById(\"t11\"); var t12 = document.getElementById(\"t12\"); var body = document.body; window.onclick = function(event){ alert('我是window.onclick。'); } document.onclick = function(event){ alert('我是document.onclick。'); } body.onclick = function(event){ alert('我是body.onclick。'); } t1.onclick = function(event){ alert('我是外层的。'); } t11.onclick = function(event){ alert('我是里层的。'); } } 代码运行结果为， 点击t11： 我是里层的。 我是外层的。 我是body.onclick。 我是document.onclick。 我是window.onclick。 点击t12： 我是外层的。 我是body.onclick。 我是document.onclick。 我是window.onclick。 如何阻止事件的冒泡， function stopBubble(e){ if(e && e.stopPropagation) e.stopPropagation(); else window.event.cancelBubble = true; } 加入阻止事件冒泡代码, t11.onclick = function(event){ alert('我是里层的。'); stopBubble(event); } 程序运行结果， 点击t11： 我是里层的。 点击t12： 我是外层的。 我是body.onclick。 我是document.onclick。 我是window.onclick。","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"}]},{"title":"十二宫解释","slug":"十二宫解释","date":"2013-09-18T09:48:02.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/09/18/十二宫解释/","link":"","permalink":"http://hi2048.github.io/2013/09/18/十二宫解释/","excerpt":"","text":"《三命通会》十二宫解释： 长生象万物发生向荣，如人始生而向长也。 沐浴（败）象以万物始生，形体柔脆，易为所损，如人生后三日，以沐浴之，不至困绝也。 冠带象万物渐荣秀，如人具衣冠也。 临官如人之临官也。 帝旺象万物成熟，如人之兴旺也。 衰象万物形衰，如人之气衰也。 病象万物病，如人之病也。 死象万物死，如人之死也。 墓（库）象万物成功之藏库，如人之终而归墓也。 绝（受气、胞）象万物在地中，未有其象，如母腹空，未有物也。 胎（受胎）象天地气交，氤氲造物，其物在地中萌芽，始有其气，如人受父母之气也。 养（形成）象万物在地中形成，如人之在母腹成形也。 &nbsp;","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"十干生旺实用图","slug":"十干生旺实用图","date":"2013-09-17T08:56:41.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/09/17/十干生旺实用图/","link":"","permalink":"http://hi2048.github.io/2013/09/17/十干生旺实用图/","excerpt":"","text":"甲丙戊庚壬五阳干（顺转） 甲木生在亥， 丙戊生于寅， 庚金生在巳， 壬水生居申。 乙丁己辛癸五阴干（逆转） 乙木生在午， 丁己生于酉， 辛金生在子， 癸水生居卯。 甲 丙（戊） 庚 壬 败 胎 死 旺 子 乙 丁（己） 辛 癸 病 绝 生 临 &nbsp; 甲 丙（戊） 庚 壬 冠 养 墓 衰 丑 乙 丁（己） 辛 癸 衰 墓 养 冠 &nbsp; 甲 丙（戊） 庚 壬 临 生 绝 病 寅 乙 丁（己） 辛 癸 旺 死 胎 败 &nbsp; 甲 丙（戊） 庚 壬 旺 败 胎 死 卯 乙 丁（己） 辛 癸 临 病 绝 生 &nbsp; 甲 丙（戊） 庚 壬 衰 冠 养 墓 辰 乙 丁（己） 辛 癸 冠 衰 墓 养 &nbsp; 甲 丙（戊） 庚 壬 病 临 生 绝 巳 乙 丁（己） 辛 癸 败 旺 死 胎 &nbsp; 甲 丙（戊） 庚 壬 死 旺 败 胎 午 乙 丁（己） 辛 癸 生 临 病 绝 &nbsp; 甲 丙（戊） 庚 壬 墓 衰 冠 养 未 乙 丁（己） 辛 癸 养 冠 衰 墓 &nbsp; 甲 丙（戊） 庚 壬 绝 病 临 生 申 乙 丁（己） 辛 癸 胎 败 旺 死 &nbsp; 甲 丙（戊） 庚 壬 胎 死 旺 败 酉 乙 丁（己） 辛 癸 绝 生 临 病 &nbsp; 甲 丙（戊） 庚 壬 养 墓 衰 冠 戌 乙 丁（己） 辛 癸 墓 养 冠 衰 &nbsp; 甲 丙（戊） 庚 壬 生 绝 病 临 亥 乙 丁（己） 辛 癸 死 胎 败 旺 &nbsp; &nbsp; &nbsp; &nbsp;","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"分宫卦象二","slug":"分宫卦象二","date":"2013-09-16T06:34:53.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/09/16/分宫卦象二/","link":"","permalink":"http://hi2048.github.io/2013/09/16/分宫卦象二/","excerpt":"","text":"巽宫 巽为风 风天小畜 风火家人 风雷益 天雷无妄 火雷噬嗑 山雷颐 山风蛊 离宫 离为火 火山旅 火风鼎 火水未济 山水蒙 风水涣 天水讼 天火同人 坤宫 坤为地 地雷复 地泽临 地天泰 雷天大壮 泽天夬 水天需 水地比 兑宫 兑为泽 泽水困 泽地萃 泽山咸 水山蹇 地山谦 雷山小过 雷泽归妹","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"最长公共子串","slug":"最长公共子串","date":"2013-09-16T03:08:26.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/09/16/最长公共子串/","link":"","permalink":"http://hi2048.github.io/2013/09/16/最长公共子串/","excerpt":"","text":"最长公共子串问题主要是让用户输入两个字符串，经过程序的运算，输出两个字符串中的最长的公共子串。 LCS算法可以很好的解决上述问题，核心是使用矩阵，假设字符串1水平排列，字符串2垂直排列，则可以用一个二维数组来表示，字符串2中的每一个字符与字符串1中的进行比较，相同则置为1，不同则置为0。 假设两个字符串为， 字符串1为：TESTBZZGGZCTESTD 字符串2为：BEGZZGGZCEND 其表示矩阵为， 0000100000000100 0100000000001000 1000000110000000 0000011002000000 0000012001000000 0000000310000000 0000000140000000 0000011005000000 0000000000600100 0100000000001000 1000000000000000 0000000000000001 示例代码为， //最长公共子串LCS算法 void lcsAlgo(){ string str1, str2; cin&gt;&gt;str1&gt;&gt;str2; int maxLen = 0; int maxLoc = 0; int len1 = str1.size(); int len2 = str2.size(); int lcs[100 * 100] = {0}; for(int i = 0; i &lt; len2; i++){ for(int j = 0; j &lt; len1; j++){ if(str2.at(i) == str1.at(j)){ if(i&gt; 0 &amp;&amp; j&gt; 0){ lcs[i * len2 + j] = lcs[(i - 1) * len2 + j - 1] + 1; if(lcs[i * len2 + j] &gt; maxLen){ maxLen = lcs[i * len2 + j]; maxLoc = j; } } else{ lcs[i * len2 + j] = 1; } } } } for(i = 0; i &lt; len2; i++){ for(int j = 0; j &lt; len1; j++){ cout&lt;&lt;lcs[i * len2 + j]; } cout&lt;&lt;endl; } for(int k = maxLen - 1; k &gt;= 0; k--){ if(maxLoc - k &gt;= 0) cout&lt;&lt;str1.at(maxLoc - k); } } 最长公共子串的运行结果为， ZZGGZC","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hi2048.github.io/tags/算法/"},{"name":"C++","slug":"C","permalink":"http://hi2048.github.io/tags/C/"}]},{"title":"分宫卦象一","slug":"分宫卦象一","date":"2013-09-15T07:31:26.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/09/15/分宫卦象一/","link":"","permalink":"http://hi2048.github.io/2013/09/15/分宫卦象一/","excerpt":"","text":"乾宫 乾为天 天风姤 天山遁 天地否 风地观 山地剥 火地晋 火天大有 坎宫 坎为水 水泽节 水雷屯 水火既济 泽火革 雷火丰 地火明夷 地水师 艮宫 艮为山 山火贲 山天大畜 山泽损 火泽睽 天泽履 风泽中孚 风山渐 震宫 震为雷 雷地豫 雷水解 雷风恒 地风升 水风井 泽风大过 泽雷随 &nbsp;","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"卦名次序歌","slug":"卦名次序歌","date":"2013-09-14T09:48:11.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/09/14/卦名次序歌/","link":"","permalink":"http://hi2048.github.io/2013/09/14/卦名次序歌/","excerpt":"","text":"乾坤屯蒙需讼师，比小畜兮履泰否。 同人大有谦豫随，蛊临观兮噬嗑贲。 剥复无妄大畜颐，大过坎离三十备。 咸恒遁兮及大壮，晋与明夷家人睽。 蹇解损益夬姤萃，升困井革鼎震继。 艮渐归妹丰旅巽，兑涣节兮中孚至。 小过既济兼未济，是为下经三十四。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"指针数组和数组指针","slug":"指针数组和数组指针","date":"2013-09-13T13:48:20.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/09/13/指针数组和数组指针/","link":"","permalink":"http://hi2048.github.io/2013/09/13/指针数组和数组指针/","excerpt":"","text":"指针数组即存储指针的数组；数组指针即指向数组的指针。 指针数组的形式， int *p[n]; 数组指针的形式， int (*p)[n] 指针数组与数组指针在实际中的应用， int a[3] = {1, 2, 3}; int *p1[3], (*p2)[3]; for(int i = 0; i < 3; i++){ p1[i] = &a[i]; } p2 = &a; printf(\"%d\", *p1[1]); printf(\"\\n\"); printf(\"%d\", (*p2)[2]);","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://hi2048.github.io/tags/C/"}]},{"title":"卦气旺衰","slug":"卦气旺衰","date":"2013-09-11T06:47:25.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/09/11/卦气旺衰/","link":"","permalink":"http://hi2048.github.io/2013/09/11/卦气旺衰/","excerpt":"","text":"春木旺，震卦，巽卦属木，则卦气就旺，坤卦、艮卦则气衰； 夏火旺，离卦属火，则卦气就旺，乾卦、兑卦则卦气就衰； 秋金旺，乾卦，兑卦属金，则卦气就旺，震卦、巽卦则气衰； 冬水旺，坎卦属水，则卦气就旺，离卦则卦气就衰； 四季的末月（三、六、九、十二月）属土，坤卦、艮卦属土，则卦气就旺，坎卦则气衰。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"冒泡算法及改进","slug":"冒泡算法及改进","date":"2013-09-11T04:33:05.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/09/11/冒泡算法及改进/","link":"","permalink":"http://hi2048.github.io/2013/09/11/冒泡算法及改进/","excerpt":"","text":"在排序算法中，冒泡算法属于稳定排序，虽然效率较低，但由于其实现简单，在很多地方还是很有实用价值的。 冒泡算法（假定是从小到大的排序）的具体实现过程， 1. 比较第j个数与第j + 1个数的大小，如果大于，则进行交换。 2. 进行一轮比较与交换，最后一个数则为最大数。 3. 循环进行1，2步骤，直到所有数据都排序完成。 &nbsp; 简单实现代码，其中a为待排序的数组，n为数组长度，temp为交换中的临时变量。 void bubble(int* a, int n){ int temp; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n - 1; j++) if(a[j] &gt; a[j + 1]){ temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; } } 下面将分别从空间与时间的复杂度上对上述代码进行改进。 1\\. 时间复杂度上考虑，由于每进行一趟，数组最后都会完成一位数的排序，因此只需对前n - 1 - i个数据进行比较，i为已经进行的趟数。 void bubble_p1(int* a, int n){ int temp; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n - 1 - i; j++) if(a[j] &gt; a[j + 1]){ temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; } } 2\\. 时间复杂度上考虑，假如数组开始排序前就有已经排序好的数据，则可以不用再进行冒泡排序，因此可以保存一个变量k，使其为每一趟排序中最后一次交换的数组下标，从而实现算法优化。最优情况为数组本身为有序数组，则只需进行一趟排序。 void bubble_p2(int* a, int n){ int temp; int k = 0; for(int i = n - 1; i &gt; 0; i = k) for(int j = 0; j &lt; i; j++) if(a[j] &gt; a[j + 1]){ k = j; temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; } } 3\\. 空间复杂度上考虑，可以利用数组的长度n，每一次排序完成后，重新计算所需排序的长度n - i，其中i为已经排序完成的数目。 void bubble_p3(int* a, int n){ int temp; for(int i = n; i &gt; 1; i = n) for(int j = 0; j &lt; i - 1; j++) if(a[j] &gt; a[j + 1]){ n = j + 1; temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; } } 4. 空间复杂度上考虑，利用运算进行数据的交换，可以节省temp的空间。 void bubble_p4(int* a, int n){ for(int i = n; i &gt; 1; i = n) for(int j = 0; j &lt; i - 1; j++) if(a[j] &gt; a[j + 1]){ n = j + 1; a[j] = a[j] + a[j + 1]; a[j + 1] = a[j] - a[j + 1]; a[j] = a[j] - a[j + 1]; } }","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hi2048.github.io/tags/算法/"},{"name":"C++","slug":"C","permalink":"http://hi2048.github.io/tags/C/"}]},{"title":"JavaScript中类的创建","slug":"JavaScript中类的创建","date":"2013-09-10T09:02:09.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/09/10/JavaScript中类的创建/","link":"","permalink":"http://hi2048.github.io/2013/09/10/JavaScript中类的创建/","excerpt":"","text":"JavaScript中的所有事物都是对象，其中对象是带有属性和方法的特殊数据类型，也可以将对象看作是一个无序的属性集合。常用的类的定义方法有3种， 1. 直接定义类 方式1： var obj = {}; obj.id = 1; obj.name = 'object'; obj.func = function(){ alert(this.id + ': ' + this.name); } 方式2： var obj = { 'id': 1, 'name': 'object', 'func': function(){ alert(this.id + ': ' + this.name); } }; 2\\. 使用关键字function定义类 function Obj(){ var self = this; self.id = 1; self.name = 'object'; self.func = function(){ alert(self.id + ': ' + self.name); } } 3\\. 使用原型的方式定义类 function Obj(){} Obj.prototype.id = 1; Obj.prototype.name = 'object'; Obj.prototype.func = function(){ alert(this.id + ': ' + this.name); }","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"}]},{"title":"JavaScript中变量的作用域","slug":"JavaScript中变量的作用域","date":"2013-09-10T08:04:50.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/09/10/JavaScript中变量的作用域/","link":"","permalink":"http://hi2048.github.io/2013/09/10/JavaScript中变量的作用域/","excerpt":"","text":"JavaScript中变量的作用域主要是指变量的适用范围。 根据作用域可以将变量划分为全局变量与局部变量。其中全局变量定义在函数体外，可以在程序的任何地方使用；局部变量则一般定义在函数体内，只能在该函数内部使用。 1. 全局变量的3种声名方式 方法1：var global = ‘value’; //在函数外定义方法2：global = ‘value’;方法3：window.global = ‘value’;2. 局部变量的声名方式 var local = ‘value’; //在函数内定义&nbsp; JavaScript变量的作用域练习， 1. 以下程序的输出值是什么？ function f1(){ var x = 1; function f2(){ alert(x); var x = 100; alert(x); } f2(); alert(x);}f1();程序的输出值为：undefined、100、1。 2. 以下程序的输出值是什么？ function f1(){ var x = 1; function f2(){ alert(x); x = 100; alert(x); } f2(); alert(x);}f1();程序的输出值为：1、100、100。","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"}]},{"title":"预测起卦的形式","slug":"预测起卦的形式","date":"2013-09-10T07:26:12.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/09/10/预测起卦的形式/","link":"","permalink":"http://hi2048.github.io/2013/09/10/预测起卦的形式/","excerpt":"","text":"起卦的方法很多，如：年、月、日、时起卦；看到数字起卦；听到声音数起卦；来人方向起卦；看到物件长度起卦；问卦人说的字、一句话、一个时辰、一个数字、一个动作、色彩等起卦；三个麻钱摇掷起卦；感应起卦等等。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"JavaScript中的数据类型","slug":"JavaScript中的数据类型","date":"2013-09-10T06:09:50.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/09/10/JavaScript中的数据类型/","link":"","permalink":"http://hi2048.github.io/2013/09/10/JavaScript中的数据类型/","excerpt":"","text":"JavaScript是一种大小写敏感的计算机语言，有5种原始的数据类型Undefined、Null、Boolean、Number、和String。 1. Undefined Undefined类型只有一个值，undefined。表示未初始化变量的默认值。 2. Null Null类型只有一个值，null。表示尚未存在的对象。 注意：alert(null == undefined); //将返回true3. Boolean Boolean有两个值true和false。 4. Number Number可以表示32位整数，或是64位浮点数。其中8进制数以0开头，16进制数以0x开头。另外在Number中有一个特殊的值NaN，表示一个非数，即Not a Number。 注意：alert(NaN == NaN); //将返回false5. String String用来表示一个没有固定大小的字符串。","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"}]},{"title":"JavaScript类型转换","slug":"JavaScript类型转换","date":"2013-09-09T12:33:13.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/09/09/JavaScript类型转换/","link":"","permalink":"http://hi2048.github.io/2013/09/09/JavaScript类型转换/","excerpt":"","text":"JavaScript支持类型的自动转换。 1. - * /在运算中会将字符串自动转换为数字。 2. +在运算中字符串则不会转换。 3. eval会将字符串表达式运行并返回数字。 var a = “9”;alert(typeof(a + 1) + “: “ + (a + 1));alert(typeof(a - 1) + “: “ + (a - 1));alert(typeof(a 1) + “: “ + (a 1));alert(typeof(a / 1) + “: “ + (a / 1));alert(typeof(eval(“a + 1”)) + “: “ + eval(“a + 1”));根据上述， 输出值分别为string: 91，number: 8，number: 9，number: 9，string: 91。","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hi2048.github.io/tags/JavaScript/"}]},{"title":"日干推时干歌诀","slug":"日干推时干歌诀","date":"2013-09-09T03:09:53.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/09/09/日干推时干歌诀/","link":"","permalink":"http://hi2048.github.io/2013/09/09/日干推时干歌诀/","excerpt":"","text":"甲己还生甲， 乙庚丙作初， 丙辛从戊起， 丁壬庚子居， 戊癸何方发？ 壬子是真途。 例如：戊寅日子时的时干推算，口诀是戊癸何方发，壬子是真途。那么子时的时干是壬，即子时干支是壬子，丑时是癸丑，寅时是甲寅…….以此类推即可。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"年推月干口诀","slug":"年推月干口诀","date":"2013-09-08T03:07:02.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/09/08/年推月干口诀/","link":"","permalink":"http://hi2048.github.io/2013/09/08/年推月干口诀/","excerpt":"","text":"甲己之年丙作首， 乙庚之年戊为头， 丙辛必定寻庚起， 丁壬壬位顺行流， 更有戊癸何方觅， 甲寅之上好追求。 例如：今年是癸巳年，根据口诀壬癸何方觅，甲寅之上好追求，那么正月为甲寅，二月为乙卯……..以此类推即可。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"二十四节气口诀","slug":"二十四节气口诀","date":"2013-09-07T07:28:14.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/09/07/二十四节气口诀/","link":"","permalink":"http://hi2048.github.io/2013/09/07/二十四节气口诀/","excerpt":"","text":"春雨惊春清谷天， 夏满芒夏暑相连， 秋处露秋寒霜降， 冬雪雪冬小大寒。 上半年是六、二一， 下半年是八、二三， 二十四节紧相连， 天后相差一两天。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"HTTP协议请求过程","slug":"HTTP协议请求过程","date":"2013-09-07T03:31:50.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/09/07/HTTP协议请求过程/","link":"","permalink":"http://hi2048.github.io/2013/09/07/HTTP协议请求过程/","excerpt":"","text":"HTTP是一个应用层协议，是一种通讯规范。其请求过程分为4步， 1. 建立连接，主要包括连接请求，DNS解析。 2. HTTP请求，主要是指浏览器向WEB服务器发送HTTP请求，一般分为GET和POST。 3. HTTP响应，主要是指WEB服务器解析请求，定位请求资源，并同时返回HTML。 4. 关闭连接，其中服务器主动关闭连接，客户端被动关闭连接。 &nbsp; HTTP协议请求过程练习， 从输入URL到显示网页，后台发生了什么？HTTP： a. 浏览器中输入URL b. DNS解析 c. 浏览器发送HTTP请求 d. 服务器响应请求，并返回HTML e. 浏览器解析HTML，并开始显示 *f. 浏览器循环发送请求，获取嵌入在HTML中的对象，如js文件，css文件，图片等 *g. 浏览器执行JavaScript等脚本 *h. 浏览器处理AJAX请求 其中f，g，h非必需过程，视具体页面而定。","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[]},{"title":"周易预测月份的划定","slug":"周易预测月份的划定","date":"2013-09-06T10:35:25.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/09/06/周易预测月份的划定/","link":"","permalink":"http://hi2048.github.io/2013/09/06/周易预测月份的划定/","excerpt":"","text":"我们在周易预测中，月（农历月）有严格的划定： 正月寅，从立春节经雨水气到交惊蛰节止； 二月卯，从惊蛰节经春分气到交清明节止； 三月辰，从清明节经谷雨气到交立夏节止； 四月巳，从立夏节经小满气到交芒种节止； 五月午，从芒种节经夏至气到交小暑节止； 六月未，从小暑节经大暑气到交立秋节止； 七月申，从立秋节经处暑气到交白露节止； 八月酉，从白露节经秋分气到交寒露节止； 九月戌，从寒露节经霜降气到交立冬节止； 十月亥，从立冬节经小雪气到交大雪节止； 十一月子，从大雪节经冬至气到交小寒节止； 十二月丑，从小寒节经大寒气到交立春节止。 每个月包含一个节和一个气，也就是一年共有二十四节气。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"六十甲子及纳音","slug":"六十甲子及纳音","date":"2013-09-05T10:45:51.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/09/05/六十甲子及纳音/","link":"","permalink":"http://hi2048.github.io/2013/09/05/六十甲子及纳音/","excerpt":"","text":"1、甲子、2、乙丑海中金； 3、丙寅、4、丁卯炉中火； 5、戊辰、6、己巳大林木； 7、庚午、8、辛未路旁土； 9、壬申、10、癸酉剑锋金； 11、甲戌、12、乙亥山头火； 13、丙子、14、丁丑涧下水； 15、戊寅、16、己卯城头土； 17、庚辰、18、辛巳白蜡金； 19、壬午、20、癸未杨柳木； 21、甲申、22、乙酉泉中水； 23、丙戌、24、丁亥屋上土； 25、戊子、26、己丑霹雳火； 27、庚寅、28、辛卯炉中火； 29、壬辰、30、癸巳长流水； 31、甲午、32、乙未沙中金； 33、丙申、34、丁酉山下火； 35、戊戌、36、己亥平地木； 37、庚子、38、辛丑壁上土； 39、壬寅、40、癸卯金箔金； 41、甲辰、42、乙巳复灯火； 43、丙午、44、丁未天河水； 45、戊申、46、己酉大驿土； 47、庚戌、48、辛亥钗钏金； 49、壬子、50、癸丑桑柘木； 51、甲寅、52、乙卯大溪水； 53、丙辰、54、丁巳沙中土； 55、戊午、56、己未天上火； 57、庚申、58、辛酉石榴木； 59、壬戌、60、癸亥大海水。 &nbsp; &nbsp; &nbsp;","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"C++宏的使用","slug":"C++宏的使用","date":"2013-09-04T13:49:48.000Z","updated":"2019-09-05T08:52:29.234Z","comments":true,"path":"2013/09/04/C++宏的使用/","link":"","permalink":"http://hi2048.github.io/2013/09/04/C++宏的使用/","excerpt":"","text":"宏在使用中，需要注意以下3点， 1. 尽量不要定义变量，防止出现重复定义的错误，redefinition。 2. 尽量使用括号，防止运算的优先级出现问题。 3. 宏定义的结尾不要使用分号，原因是宏定义一般是作为一个表达式出现，而不是一行语句。 &nbsp; 宏定义练习， 1. 定义一个宏实现两个数交换。 C++ source code: #define swap(x, y) (x) = (x) + (y); (y) = (x) - (y); (x) = (x) - (y) 2\\. 定义一个宏实现返回两个数的较大者。 C++ source code: #define max(x, y) (x) &gt; (y) ? (x) : (y) 3\\. 定义一个宏实现返回两个数的和。 C++ source code: #define add(x, y) ((x) + (y))","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://hi2048.github.io/tags/C/"}]},{"title":"八卦卦象八","slug":"八卦卦象八","date":"2013-09-03T06:44:32.000Z","updated":"2019-09-05T09:05:45.231Z","comments":true,"path":"2013/09/03/八卦卦象八/","link":"","permalink":"http://hi2048.github.io/2013/09/03/八卦卦象八/","excerpt":"","text":"兑卦在自然为泽，天时为星、新月，在人为少女，属性为说，动物为羊，在身体为口，在方位为西，在季节为秋，在月令为八月，在数目为二、四、九，在其它物象为:喜悦、谗毁、巫、妾、肺、奴、带口之物、近泽之物、乐器、废铁、坠落、辛辣之物、白色等。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"SSDAY","slug":"SSDAY","date":"2013-09-02T07:45:12.000Z","updated":"2019-09-05T09:43:17.048Z","comments":true,"path":"2013/09/02/SSDAY/","link":"","permalink":"http://hi2048.github.io/2013/09/02/SSDAY/","excerpt":"","text":"使用java编写的个人博客。主要使用SSH、html5、struts2 标签完成，界面风格仿word press。 实际运行截图， 项目GitHub地址：点我","categories":[{"name":"我的作品","slug":"我的作品","permalink":"http://hi2048.github.io/categories/我的作品/"}],"tags":[]},{"title":"拖拽式留言墙","slug":"拖拽式留言墙","date":"2013-09-02T07:39:50.000Z","updated":"2019-09-05T09:11:24.511Z","comments":true,"path":"2013/09/02/拖拽式留言墙/","link":"","permalink":"http://hi2048.github.io/2013/09/02/拖拽式留言墙/","excerpt":"","text":"页面整体上分为留言墙与留言表单。其中留言墙使用JQuery实现了留言的可拖拽效果；在留言表单的交互中则使用了大量的动画，用来提升页面的流畅度与用户体验。 留言表单运行效果， 留言墙运行效果， 页面展示地址：点我","categories":[{"name":"我的作品","slug":"我的作品","permalink":"http://hi2048.github.io/categories/我的作品/"}],"tags":[]},{"title":"八卦卦象七","slug":"八卦卦象七","date":"2013-09-02T07:05:10.000Z","updated":"2019-09-05T09:05:45.231Z","comments":true,"path":"2013/09/02/八卦卦象七/","link":"","permalink":"http://hi2048.github.io/2013/09/02/八卦卦象七/","excerpt":"","text":"离卦在自然为火，在人为中女，属性为丽，动物为雉，在身体为目，在方位为南，在季节为夏，在月令为五月，在数目为三、二、七，在其它物象为:日、电、霞、虹、文人、兵戈、甲胄、大腹、鳖、赢、壳物、干燥、槁木、赤、红、紫、苦味等。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"DIC-NOTE模板","slug":"DIC-NOTE模板","date":"2013-09-01T07:46:36.000Z","updated":"2019-09-05T08:58:02.132Z","comments":true,"path":"2013/09/01/DIC-NOTE模板/","link":"","permalink":"http://hi2048.github.io/2013/09/01/DIC-NOTE模板/","excerpt":"","text":"页面整体划分为导航区（navigator），横幅区（banner），主内容区（content），与页尾（footer），同时使用了大量动画，用来提升页面切换的流畅感与用户的体验。 实际效果截图如下， 页面展示地址：点我","categories":[{"name":"我的作品","slug":"我的作品","permalink":"http://hi2048.github.io/categories/我的作品/"}],"tags":[]},{"title":"八卦卦象六","slug":"八卦卦象六","date":"2013-09-01T04:25:31.000Z","updated":"2019-09-05T09:05:45.231Z","comments":true,"path":"2013/09/01/八卦卦象六/","link":"","permalink":"http://hi2048.github.io/2013/09/01/八卦卦象六/","excerpt":"","text":"巽卦在自然为风，在人为长女，属性为入，动物为鸡，在身体为股，在方位为东南，在季节为春夏间，在月令为三、四月，在数目为五、八、三，在其它物象为:木、花果菜园、绳、直、白、长、高、工、进退不果、臭、寡发、广额、多白眼、近利市三倍、百草、香气、羽、帆、扇、仙道、酸味、青绿、碧洁白、百禽等。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"微享","slug":"微享","date":"2013-09-01T03:29:37.000Z","updated":"2019-09-05T08:49:15.884Z","comments":true,"path":"2013/09/01/微享/","link":"","permalink":"http://hi2048.github.io/2013/09/01/微享/","excerpt":"","text":"微享是一个基于phonegap框架，采用HTML5与CSS3制作的移动应用，主要是对陕西省科技厅文档数字化管理与资源共享平台，“13115科技创新项目”，关于移动平台的扩展，主要功能是使得用户可以在移动端，随时、随地，方便、快捷、友好地访问文档数字化管理与资源共享平台的资源。 该系统主要功能有： 1. Pin风格的UI设计与实现 2. 文档、音频、视频、图片4大类资源的播放 3. 基于jsonp的资源获取与搜索 4. 资源的个性化推送 &nbsp; 系统实际截图，实测机型为三星N7100： 主页面展示， 底部菜单栏展示， 内容页面展示， &nbsp;","categories":[{"name":"我的作品","slug":"我的作品","permalink":"http://hi2048.github.io/categories/我的作品/"}],"tags":[]},{"title":"第9天","slug":"第9天","date":"2013-08-31T08:49:09.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/08/31/第9天/","link":"","permalink":"http://hi2048.github.io/2013/08/31/第9天/","excerpt":"","text":"我喜欢南阳，从第一刻来到这里，亭台，流水，古老的桥，还有那一栋栋古朴的房屋，都深深地让我沉迷。 顺利来到高府外，一则告示深深地吸引了我的注意，只见上面写着一条招聘家丁的消息，看完之后，我心中不禁感慨道，真的好巧呀！ 进入高府后，总管安排我去填写报名表格，一切都搞定之后。 总管打了个手势，问我想不想明天顺利通过。 我没给，他不高兴。 但是， 那又怎样。","categories":[{"name":"杀手日记","slug":"杀手日记","permalink":"http://hi2048.github.io/categories/杀手日记/"}],"tags":[]},{"title":"八卦卦象五","slug":"八卦卦象五","date":"2013-08-31T08:34:53.000Z","updated":"2019-09-05T09:05:45.231Z","comments":true,"path":"2013/08/31/八卦卦象五/","link":"","permalink":"http://hi2048.github.io/2013/08/31/八卦卦象五/","excerpt":"","text":"坤卦在自然为地，天时为云、阴、雾气，在人为母，属性为顺，动物为牛，在身体为腹，在方位为西南，在季节为夏秋间，在月令为六、七月，在数目为八、五、十，在其它物象为:田野、柔物、文章、车、船、五谷、方物、衣裳、书、村舍、吝啬、众多、釜、黑黄色、腹脏、甘味等。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"八卦卦象四","slug":"八卦卦象四","date":"2013-08-30T09:55:39.000Z","updated":"2019-09-05T09:05:45.231Z","comments":true,"path":"2013/08/30/八卦卦象四/","link":"","permalink":"http://hi2048.github.io/2013/08/30/八卦卦象四/","excerpt":"","text":"艮卦在自然为山，天时为云、雾，在人为少男，属性为止，动物为狗，在身体为手，在方位为东北，在季节为冬春间，在月令为十二月，在数目为五、七、十，在其它物象为:山路、小石、阻止、门阙、阍寺、狗、狐、虎、身体为脾胃、为木是坚而多节、土中之物、鼻、藤、黔啄之属、为黄色等。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"八卦卦象三","slug":"八卦卦象三","date":"2013-08-29T11:13:22.000Z","updated":"2019-09-05T09:05:45.231Z","comments":true,"path":"2013/08/29/八卦卦象三/","link":"","permalink":"http://hi2048.github.io/2013/08/29/八卦卦象三/","excerpt":"","text":"坎卦在自然为水，天时为雨、雪，在人为中男，属性为陷，动物为豕（猪），在身体为耳，在方位为北，在季节为冬，在月令为十一月，在数目为一、六，在其它物象为：沟渎、池、血、酒器、弓轮隐伏，对人为心病、忧、耳痛、月、蹄、赤、黑色、律、棘、狐、桎梏、水族、猪肉、鱼盐河泊、水阁等。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"第8天：五千杀手下江南","slug":"第8天：五千杀手下江南","date":"2013-08-28T04:01:25.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/08/28/第8天：五千杀手下江南/","link":"","permalink":"http://hi2048.github.io/2013/08/28/第8天：五千杀手下江南/","excerpt":"","text":"如果注定会被遗忘，我们又为了什么而奋不顾身；如果注定会彼此相忘，又为了什么而肝肠寸断；如果一切都是谎言，又为了什么而生死相许！ 师父说我是一个疯子，说那有杀手会写日记，会去记录自己所做的一切，因为记录的东西是秘密，他总有一天会把你带入地狱。不过我还是一直在写着，因为我更害怕没有人知道我曾真实的在这个世界上生活过。 和往常一样，练功，吃饭。 不过今天注定是不同的，因为晚上师父扔给我一枚金色令牌，和一份任务合约。 合约上的任务非常简单，赏茶、温水。后面是一行备注清楚地写着一定要成功！ 批注：赏茶、温水是组织的暗语。我这次的任务主要是监视目标的生活习惯，寻找机会。组织为掩人耳目，将刺杀任务一般分为4步，分别是沏茶、赏茶、闻茶与饮茶。分别代指刺杀目标的搜寻、监视、刺杀准备与执行。温水、烈水与冷水分别指代任务执行时间较为充裕、严重不足与任务的起始。再下面就是一些更加详细地描述。 任务级别：A级。 批注：这算是目前为止，我接手地最大的一个任务，当然就是在组织中也算是一个大案了。任务总赏金：一千万。 批注：我星星的，在组织中我们每一个人都是有身价的，身价会随着你能力与贡献而增加，可是经过了这么多年地努力，我的终于到了九千，于是我数完了手指和脚趾也没搞明白这次任务目标的身价是我的多少倍，不过这都没什么，因为我是一个干大事的人，不会纠结于这样的小事的，但是师父也才九千万，她已经到了师父的九分之一。不过我是一个有智商的人，于是我推断出，她一定是个很重要的人，对，一定很重要，对此，我深信不移。任务细节： 这份合约上只有第一步， 去南阳，混入高府，做厨子。 赏金:1。 还没等到，我对于赏金地吐槽，只听师父说到你有4998个手下已经出发，记住你是这次行动的二当家，对于这次行动，你是关键，记住这次行动非常重要，一定要记住，非常重要！ 当时我总感觉这句话好熟悉啊！ 于是，我拿起了令牌，孤身上路。","categories":[{"name":"杀手日记","slug":"杀手日记","permalink":"http://hi2048.github.io/categories/杀手日记/"}],"tags":[]},{"title":"DARING","slug":"DARING","date":"2013-08-27T13:09:04.000Z","updated":"2019-09-05T08:57:04.366Z","comments":true,"path":"2013/08/27/DARING/","link":"","permalink":"http://hi2048.github.io/2013/08/27/DARING/","excerpt":"","text":"daring是一个基于phonegap框架，采用HTML5与CSS3制作的移动应用，主要是对该博客系统进行的移动端扩展。 该系统的主要功能有， 1. HTML5与CSS3的系统UI设计与实现。 2. JSONP进行跨域的数据访问。 3. 独立的推送子系统。 &nbsp; 系统的实际截图，实测机型为三星N7100： 主界面展示， 侧边栏菜单展示， 文章浏览界面展示，","categories":[{"name":"我的作品","slug":"我的作品","permalink":"http://hi2048.github.io/categories/我的作品/"}],"tags":[]},{"title":"苏小蜂的个人博客","slug":"苏小蜂的个人博客","date":"2013-08-27T12:57:01.000Z","updated":"2019-09-05T09:14:50.513Z","comments":true,"path":"2013/08/27/苏小蜂的个人博客/","link":"","permalink":"http://hi2048.github.io/2013/08/27/苏小蜂的个人博客/","excerpt":"","text":"该博客系统是一个采用wordpress进行驱动，并进行了独立的主题制作，同时进行了邮件RSS订阅，社会化评论，JSONP的开放API等扩展，形成的一套完整的个人博客系统。 系统的主要功能有： 1. pin风格的主题 2. RSS的邮件订阅 3. 集成友言的社会化评论 4. 制作JSONP的开放API，为系统的移动扩展DARING提供了基础。 &nbsp; 系统的实际截图： 主面展示， 列表页面展示， &nbsp; 文章页面展示，","categories":[{"name":"我的作品","slug":"我的作品","permalink":"http://hi2048.github.io/categories/我的作品/"}],"tags":[]},{"title":"八卦的卦象二","slug":"八卦的卦象二","date":"2013-08-27T08:41:21.000Z","updated":"2019-09-05T09:05:45.231Z","comments":true,"path":"2013/08/27/八卦的卦象二/","link":"","permalink":"http://hi2048.github.io/2013/08/27/八卦的卦象二/","excerpt":"","text":"震卦在天时为雷，在人为长男，属性为动，动物为龙，身体为足，方位为东，在季节为春，在月令为二月，在数目为四、八、三，在其它物象为：黑青、绿碧、大道、施舍、决断、小青竹、芦苇、善鸣马、白额马、发、百虫、乐器、草木、树、花草繁鲜之物、木竹、果实在根部的植物等。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"放慢脚步，享受生活","slug":"放慢脚步，享受生活","date":"2013-08-26T07:15:59.000Z","updated":"2019-09-05T09:05:45.232Z","comments":true,"path":"2013/08/26/放慢脚步，享受生活/","link":"","permalink":"http://hi2048.github.io/2013/08/26/放慢脚步，享受生活/","excerpt":"","text":"离开繁闹的都市，来到宁静的乡村。一下子，生活节奏放慢了太多太多，这才发现，原来不知不觉间，我们已经失去了好多。 生命中除了努力、奋斗，还有很多值得我们去追寻的事物。 放慢脚步，体会山风带动风车的声音，沿着石子小路，向远方缓缓行去。 风景让我们轻松、愉快。 文化让我们内敛、自信。 可曾记得家乡那特有的文化，平凡中透露着幸福。 生命本该如此！ 打完收工，打猎去~","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hi2048.github.io/categories/杂谈/"}],"tags":[]},{"title":"八卦的卦象一","slug":"八卦的卦象一","date":"2013-08-25T04:11:42.000Z","updated":"2019-09-05T09:05:45.231Z","comments":true,"path":"2013/08/25/八卦的卦象一/","link":"","permalink":"http://hi2048.github.io/2013/08/25/八卦的卦象一/","excerpt":"","text":"乾卦在天时象天，在人象父，属性是健，在动物象马，在身体象首（头），在方位是西北，在季节是秋冬间、九、十月之交，在数目一、四、九、在其它物象有：金，玉、寒、冰、君、官贵、园物、果木、冠、骨、镜、京都、公门、大赤色、玄色、刃、狮、象、刚物等。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"那些我们一起经历过的","slug":"那些我们一起经历过的","date":"2013-08-24T13:29:42.000Z","updated":"2019-09-05T09:05:45.232Z","comments":true,"path":"2013/08/24/那些我们一起经历过的/","link":"","permalink":"http://hi2048.github.io/2013/08/24/那些我们一起经历过的/","excerpt":"","text":"这么多年，我和她经历过的，生的，死的，你真的知道吗？！我不可以没有她，她也不可以没有我。你知道。。你知道。。对不起，你可能真的不知道。 第一次是故事的主角-应无求，哭着，说了出来，第二次是电视的主角-离歌笑，半哭半笑，说了出来。同样的台词，笑着说却更让人伤感。 最后再引用一句， 我离歌笑，一杯酒，一个朋友。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hi2048.github.io/categories/杂谈/"}],"tags":[]},{"title":"八卦五行归类","slug":"八卦五行归类","date":"2013-08-24T04:10:36.000Z","updated":"2019-09-05T09:05:45.231Z","comments":true,"path":"2013/08/24/八卦五行归类/","link":"","permalink":"http://hi2048.github.io/2013/08/24/八卦五行归类/","excerpt":"","text":"卦体 五行 五方 五季 五气 五估 五色 五味 五音 五声 五志 五常 五体 五脏 五腑 五官 震巽 木 东 春 风 生 青 酸 角 呼 怒 信 筋 肝 胆 目 离 火 南 夏 暑 长 赤 苦 征 笑 喜 礼 脉 心 小肠 舌 艮坤 土 中 长夏 湿 化 黄 甘 宫 歌 思 仁 肉 脾 胃 口 乾兑 金 西 秋 燥 收 白 辛 商 哭 忧 义 皮毛 肺 大肠 鼻 坎 水 北 冬 寒 藏 黑 咸 羽 呻 恐 智 骨 肾 膀胱 耳 &nbsp;","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"后天八卦定位","slug":"后天八卦定位","date":"2013-08-23T07:47:31.000Z","updated":"2019-09-05T09:05:45.231Z","comments":true,"path":"2013/08/23/后天八卦定位/","link":"","permalink":"http://hi2048.github.io/2013/08/23/后天八卦定位/","excerpt":"","text":"后天阵而方位正后天八卦即文王八卦，置乾于西北，以长子用事代父施行，乾为老阳，故退于不用之地，置坤于西南，以长女用事代母施行，坤为老阴，故退居于不用之地，震为雷能发育万物，春为阳之始，故震居正东，巽为风，能长养万物，春夏交替之时，故巽居东南，燥万物者莫燥乎炎，正南阳极之地，离为火故居之，滋万物者莫润乎水，正北阴极之地，坎为水故居之，兑为泽有潴聚之义，能悦万物，西为杀气昼敛之始，故兑居之，艮为山有成悦之义，终始万物，东北为冬冬末春初之交，故艮居之。此后天八卦所以定方位之源，而为先天阴阳之用。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"第2-7天","slug":"第2-7天","date":"2013-08-22T13:43:20.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/08/22/第2-7天/","link":"","permalink":"http://hi2048.github.io/2013/08/22/第2-7天/","excerpt":"","text":"和往常一样，练功，睡觉，吃饭，发呆。 日子单调而又平凡。","categories":[{"name":"杀手日记","slug":"杀手日记","permalink":"http://hi2048.github.io/categories/杀手日记/"}],"tags":[]},{"title":"先天八卦定位","slug":"先天八卦定位","date":"2013-08-22T04:49:03.000Z","updated":"2019-09-05T09:05:45.230Z","comments":true,"path":"2013/08/22/先天八卦定位/","link":"","permalink":"http://hi2048.github.io/2013/08/22/先天八卦定位/","excerpt":"","text":"先天八卦盡而理气明先天八卦即伏羲八卦。天地定位乾对坤，山泽通气艮对兑，雷风相博震对巽，水火不相容坎对离。乾纯阳为天，位于上居南，坤纯阴为地，位于下居北，离火外阳内阴，位于东，日生于东，坎水外阴内阳，位于西，月生于西，西北多山，故艮为山，东南泽萃故兑，兑为泽，雷起东北，故为震，阳动于下为雷，风起西南故为巽，阴入于下为风。乾坤正上下之位，坎离列左右之门，天地之所以开辟，日月之所以出入，春夏秋冬、寒暑昼夜莫不由是而推之。此先天八卦所以为理气之源，历法因之以推二十四气，运化之机而为后天阴阳之体。 &nbsp;","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"《尸兄》观后感","slug":"《尸兄》观后感","date":"2013-08-21T14:06:37.000Z","updated":"2019-09-05T08:59:20.078Z","comments":true,"path":"2013/08/21/《尸兄》观后感/","link":"","permalink":"http://hi2048.github.io/2013/08/21/《尸兄》观后感/","excerpt":"","text":"以前挺喜欢看The Walking Dead，从生与死中，主角一路走来，看的是惊心动魄，但总是感觉缺点什么，或许是文化的原因，总是少了那么点归属感。 龙门镖局的宣传片中也提到了文化作品接地气的重要性。 最近看到尸兄，感觉作者的想象力真的很棒，将中国的古代文化与现代科技相结合，用漫画将这种题材发挥的淋漓尽致。漫画上的夸张用在这类作品上，看得很是过瘾。 很喜欢这类作品，行走在生与死的边缘。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://hi2048.github.io/categories/杂谈/"}],"tags":[]},{"title":"八卦取象歌","slug":"八卦取象歌","date":"2013-08-21T08:49:29.000Z","updated":"2019-09-05T09:05:45.231Z","comments":true,"path":"2013/08/21/八卦取象歌/","link":"","permalink":"http://hi2048.github.io/2013/08/21/八卦取象歌/","excerpt":"","text":"八卦取象歌：乾三连，坤六断， 震仰盂，艮覆碗， 离中虚，坎中满， 兑上缺，巽下断。","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"Jquery打造图片播放的遮罩效果","slug":"Jquery打造图片播放的遮罩效果","date":"2013-08-21T08:13:43.000Z","updated":"2019-09-05T09:29:09.588Z","comments":true,"path":"2013/08/21/Jquery打造图片播放的遮罩效果/","link":"","permalink":"http://hi2048.github.io/2013/08/21/Jquery打造图片播放的遮罩效果/","excerpt":"","text":"Jquery是一个JavaScript函数库，可以大大简化JavaScript的使用。 使用Jquery打造图片播放的遮罩效果非常简洁，效果图如上，具体过程分三步， 1. 实现HTML文档结构 遮罩层放在BODY标签下，具体的HTML结构如下， &lt;div class=”shade”&gt; &lt;img src=”” title=”CSS3播放图片-遮罩效果” /&gt;&lt;/div&gt;待播放图片的HTML结构如下， &lt;div class=”demo-content”&gt; &lt;img src=”待播放图片地址” title=”CSS3播放图片-遮罩效果” /&gt;&lt;/div&gt;2. 使用CSS布局遮罩层 通过CSS的position属性，布局遮罩层，使其不会影响到原有页面的布局，display与text-align属性使其下面的图片居中显示。 具体代码如下， .shade{width: 100%; height: 100%; position: absolute; top: 0; left: 0; background: #ddd; text-align: center; display: none;}.shade img{max-height: 99%;}3. 调用Jquery实现图片播放的遮罩效果 通过Jquery的函数toggle来实现遮罩层的显示与隐藏。使用Jquery的attr函数来将要显示图片的地址传给遮罩层中的img标签。 toggle函数的具体作用为：当调用的节点隐藏时，则显示它；调用节点显示时，则隐藏它。 具体代码如下， $(document).ready(function(){ $(‘.demo-content img’).click(function(){ $(‘.shade img’).attr(‘src’, $(this).attr(‘src’)); $(‘.shade’).toggle(); }); $(&apos;.shade&apos;).click(function(){ $(this).toggle(); }); });效果展示页面：点我","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"Jquery","slug":"Jquery","permalink":"http://hi2048.github.io/tags/Jquery/"}]},{"title":"第1天：代号风神","slug":"第1天：代号风神","date":"2013-08-21T03:48:25.000Z","updated":"2016-05-31T16:43:38.000Z","comments":true,"path":"2013/08/21/第1天：代号风神/","link":"","permalink":"http://hi2048.github.io/2013/08/21/第1天：代号风神/","excerpt":"","text":"往事已经不堪回首。 人，究竟为什么要走这么一遭？ 第一天 代号风神 没有人会记得我的名字，以至久了，甚至连我自己也记不清了。 我只有代号，代号就是我的生命，是我的一切。 在我的组织里，我应该是一个牛逼的人，也仅仅是应该而已。我的师父是组织的九大创始人之一，代号刀君。听下面的人说师父的刀，是天下第一刀，不过我却从来都没有见过师父用刀，而且他也从来没有教过我任何刀法，只是给了我一本戟书，就没再管过我了。 我的代号是风神，我一直坚信，这个代号将会成为 一个永恒的传奇的。","categories":[{"name":"杀手日记","slug":"杀手日记","permalink":"http://hi2048.github.io/categories/杀手日记/"}],"tags":[{"name":"风神","slug":"风神","permalink":"http://hi2048.github.io/tags/风神/"}]},{"title":"CSS3打造呼吸灯效果","slug":"CSS3打造呼吸灯效果","date":"2013-08-21T01:37:19.000Z","updated":"2019-09-05T08:55:08.405Z","comments":true,"path":"2013/08/21/CSS3打造呼吸灯效果/","link":"","permalink":"http://hi2048.github.io/2013/08/21/CSS3打造呼吸灯效果/","excerpt":"","text":"使用CSS3打造呼吸灯效果，效果图如上，实现主要分两步， 1. 使用CSS3绘制同心圆 / CSS3绘制同心圆代码 /width: 120px;height: 120px;border: 27px solid #8e44ad;background: #fff;-webkit-border-radius: 120px;-moz-border-radius: 120px;-o-border-radius: 120px;-ms-border-radius: 120px;border-radius: 120px;2. 使用CSS3动画实现呼吸灯效果 第一步先定义效果的动画，具体代码如下，@keyframes blink{ 0% {border-color: #8e44ad;} 50% {border-color: #3498db;} 100% {border-color: #8e44ad;}}@-moz-keyframes blink{ 0% {border-color: #8e44ad;} 50% {border-color: #3498db;} 100% {border-color: #8e44ad;}}@-webkit-keyframes blink{ 0% {border-color: #8e44ad;} 50% {border-color: #3498db;} 100% {border-color: #8e44ad;}}@-o-keyframes blink{ 0% {border-color: #8e44ad;} 50% {border-color: #3498db;} 100% {border-color: #8e44ad;}}@-ms-keyframes blink{ 0% {border-color: #8e44ad;} 50% {border-color: #3498db;} 100% {border-color: #8e44ad;}}第二步调用上述动画，具体代码如下， animation: blink 2s infinite;-moz-animation: blink 2s infinite;-webkit-animation: blink 2s infinite;-o-animation: blink 2s infinite;-ms-animation: blink 2s infinite;到此，CSS3的呼吸灯效果就实现了，使用CSS3处理一些网页动画效果是非常简单的~ ^_^ 效果展示页面： 点我","categories":[{"name":"设计与代码","slug":"设计与代码","permalink":"http://hi2048.github.io/categories/设计与代码/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://hi2048.github.io/tags/CSS3/"}]},{"title":"八卦的来历","slug":"八卦的来历","date":"2013-08-20T10:50:11.000Z","updated":"2019-09-05T09:05:45.231Z","comments":true,"path":"2013/08/20/八卦的来历/","link":"","permalink":"http://hi2048.github.io/2013/08/20/八卦的来历/","excerpt":"","text":"太极生两仪，两仪生四象，四象生八卦。八卦为：乾、兑、离、震、巽、坎、艮、坤。 _ 1、_ 太极本无极虚 涵万化之根。 2、两仪分 阳（━） 、 阴（━ ━）实具五行之本。 3、四象生而奇偶之数分。 太阳 少阳 太阴 少阴 4、八卦形而爻象之理定。 乾 兑 离 震 巽 坎 艮 坤 &nbsp;","categories":[{"name":"周易","slug":"周易","permalink":"http://hi2048.github.io/categories/周易/"}],"tags":[]},{"title":"序：杀手日记","slug":"序：杀手日记","date":"2013-08-20T09:05:22.000Z","updated":"2019-09-05T09:40:20.450Z","comments":true,"path":"2013/08/20/序：杀手日记/","link":"","permalink":"http://hi2048.github.io/2013/08/20/序：杀手日记/","excerpt":"","text":"我不知从何而来，也不知将去往何方。 自打我记事起，我就是一名杀手，命运，我无法选择，但是我却依然做着一个美丽的梦，梦中的我，手执方天画戟，所向披靡，全天下都在看着我，这一刻，天下是属于我的，因为这将成为我的舞台。 /* 杀手日记 */ **声明： 本小说纯属虚构，如有雷同，纯属巧合。 ^_^** 体裁： 日记体武侠 &amp; 情景喜剧 Author： Jsu Date： 12.22 - 2012 License： MIT ^_^ Language： 中文 开发环境： nodpad++ 主页： [/topics/杀手日记](/topics/杀手日记)","categories":[{"name":"杀手日记","slug":"杀手日记","permalink":"http://hi2048.github.io/categories/杀手日记/"}],"tags":[{"name":"小说","slug":"小说","permalink":"http://hi2048.github.io/tags/小说/"},{"name":"情景喜剧","slug":"情景喜剧","permalink":"http://hi2048.github.io/tags/情景喜剧/"},{"name":"杀手","slug":"杀手","permalink":"http://hi2048.github.io/tags/杀手/"},{"name":"武侠","slug":"武侠","permalink":"http://hi2048.github.io/tags/武侠/"}]}]}